"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ContentReferenceImage: () => (/* binding */ ContentReferenceImage),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseBlob: () => (/* binding */ FunctionResponseBlob),\n/* harmony export */   FunctionResponseFileData: () => (/* binding */ FunctionResponseFileData),\n/* harmony export */   FunctionResponsePart: () => (/* binding */ FunctionResponsePart),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   InlinedEmbedContentResponse: () => (/* binding */ InlinedEmbedContentResponse),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SingleEmbedContentResponse: () => (/* binding */ SingleEmbedContentResponse),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMethod: () => (/* binding */ TuningMethod),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TuningTask: () => (/* binding */ TuningTask),\n/* harmony export */   TurnCompleteReason: () => (/* binding */ TurnCompleteReason),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   VideoGenerationMaskMode: () => (/* binding */ VideoGenerationMaskMode),\n/* harmony export */   VideoGenerationReferenceType: () => (/* binding */ VideoGenerationReferenceType),\n/* harmony export */   createFunctionResponsePartFromBase64: () => (/* binding */ createFunctionResponsePartFromBase64),\n/* harmony export */   createFunctionResponsePartFromUri: () => (/* binding */ createFunctionResponsePartFromUri),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_stream_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:stream/promises */ \"node:stream/promises\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nlet _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */\nfunction setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */\nfunction getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl,\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */\nfunction getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        }\n        else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key) => {\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : '';\n        }\n        else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for (let i = 0; i < keys.length - 1; i++) {\n        const key = keys[i];\n        if (key.endsWith('[]')) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({ length: value.length }, () => ({}));\n                }\n                else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for (let j = 0; j < arrayData.length; j++) {\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                }\n                else {\n                    for (const d of arrayData) {\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        }\n        else if (key.endsWith('[0]')) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [{}];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== 'object') {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value ||\n            (typeof value === 'object' && Object.keys(value).length === 0)) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === 'object' &&\n            typeof value === 'object' &&\n            existingData !== null &&\n            value !== null) {\n            Object.assign(existingData, value);\n        }\n        else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    }\n    else {\n        if (keyToSet === '_self' &&\n            typeof value === 'object' &&\n            value !== null &&\n            !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        }\n        else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys, defaultValue = undefined) {\n    try {\n        if (keys.length === 1 && keys[0] === '_self') {\n            return data;\n        }\n        for (let i = 0; i < keys.length; i++) {\n            if (typeof data !== 'object' || data === null) {\n                return defaultValue;\n            }\n            const key = keys[i];\n            if (key.endsWith('[]')) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return defaultValue;\n                    }\n                    return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));\n                }\n                else {\n                    return defaultValue;\n                }\n            }\n            else {\n                data = data[key];\n            }\n        }\n        return data;\n    }\n    catch (error) {\n        if (error instanceof TypeError) {\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n/**\n * Moves values from source paths to destination paths.\n *\n * Examples:\n *   moveValueByPath(\n *     {'requests': [{'content': v1}, {'content': v2}]},\n *     {'requests[].*': 'requests[].request.*'}\n *   )\n *     -> {'requests': [{'request': {'content': v1}}, {'request': {'content': v2}}]}\n */\nfunction moveValueByPath(data, paths) {\n    for (const [sourcePath, destPath] of Object.entries(paths)) {\n        const sourceKeys = sourcePath.split('.');\n        const destKeys = destPath.split('.');\n        // Determine keys to exclude from wildcard to avoid cyclic references\n        const excludeKeys = new Set();\n        let wildcardIdx = -1;\n        for (let i = 0; i < sourceKeys.length; i++) {\n            if (sourceKeys[i] === '*') {\n                wildcardIdx = i;\n                break;\n            }\n        }\n        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {\n            // Extract the intermediate key between source and dest paths\n            // Example: source=['requests[]', '*'], dest=['requests[]', 'request', '*']\n            // We want to exclude 'request'\n            for (let i = wildcardIdx; i < destKeys.length; i++) {\n                const key = destKeys[i];\n                if (key !== '*' && !key.endsWith('[]') && !key.endsWith('[0]')) {\n                    excludeKeys.add(key);\n                }\n            }\n        }\n        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);\n    }\n}\n/**\n * Recursively moves values from source path to destination path.\n */\nfunction _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {\n    if (keyIdx >= sourceKeys.length) {\n        return;\n    }\n    if (typeof data !== 'object' || data === null) {\n        return;\n    }\n    const key = sourceKeys[keyIdx];\n    if (key.endsWith('[]')) {\n        const keyName = key.slice(0, -2);\n        const dataRecord = data;\n        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {\n            for (const item of dataRecord[keyName]) {\n                _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n            }\n        }\n    }\n    else if (key === '*') {\n        // wildcard - move all fields\n        if (typeof data === 'object' && data !== null && !Array.isArray(data)) {\n            const dataRecord = data;\n            const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith('_') && !excludeKeys.has(k));\n            const valuesToMove = {};\n            for (const k of keysToMove) {\n                valuesToMove[k] = dataRecord[k];\n            }\n            // Set values at destination\n            for (const [k, v] of Object.entries(valuesToMove)) {\n                const newDestKeys = [];\n                for (const dk of destKeys.slice(keyIdx)) {\n                    if (dk === '*') {\n                        newDestKeys.push(k);\n                    }\n                    else {\n                        newDestKeys.push(dk);\n                    }\n                }\n                setValueByPath(dataRecord, newDestKeys, v);\n            }\n            for (const k of keysToMove) {\n                delete dataRecord[k];\n            }\n        }\n    }\n    else {\n        // Navigate to next level\n        const dataRecord = data;\n        if (key in dataRecord) {\n            _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tBytes$1(fromBytes) {\n    if (typeof fromBytes !== 'string') {\n        throw new Error('fromImageBytes must be a string');\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['operationName'], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, ['resourceName']);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, ['_url', 'resourceName'], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['encodedVideo']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/** Outcome of the code execution. */\nvar Outcome;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Programming language of the `code`. */\nvar Language;\n(function (Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */\n    Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */\n    Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Specifies how the response should be scheduled in the conversation. */\nvar FunctionResponseScheduling;\n(function (FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */\n    FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */\n    FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */\n    FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */\n    FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** The type of the data. */\nvar Type;\n(function (Type) {\n    /**\n     * Not specified, should not be used.\n     */\n    Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */\n    Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */\n    Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */\n    Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */\n    Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */\n    Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */\n    Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */\n    Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */\nvar Mode;\n(function (Mode) {\n    /**\n     * Always trigger retrieval.\n     */\n    Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */\n    Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** Type of auth scheme. This enum is not supported in Gemini API. */\nvar AuthType;\n(function (AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */\n    AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */\n    AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */\n    AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */\n    AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */\n    AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */\n    AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The API spec that the external API implements. This enum is not supported in Gemini API. */\nvar ApiSpec;\n(function (ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */\n    ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */\n    ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */\n    ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Harm category. */\nvar HarmCategory;\n(function (HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is harassment.\n     */\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is hate speech.\n     */\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is sexually explicit content.\n     */\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is dangerous content.\n     */\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */\n    HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is for jailbreak prompts. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_JAILBREAK\"] = \"HARM_CATEGORY_JAILBREAK\";\n})(HarmCategory || (HarmCategory = {}));\n/** Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. This enum is not supported in Gemini API. */\nvar HarmBlockMethod;\n(function (HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */\n    HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */\n    HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */\n    HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** The harm block threshold. */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */\n    HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\nIf empty, the model has not stopped generating the tokens. */\nvar FinishReason;\n(function (FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */\n    FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */\n    FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */\n    FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */\n    FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */\n    FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */\n    FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */\n    FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */\n    FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n    /**\n     * The model was expected to generate an image, but none was generated.\n     */\n    FinishReason[\"NO_IMAGE\"] = \"NO_IMAGE\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */\nvar HarmProbability;\n(function (HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */\n    HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. This enum is not supported in Gemini API. */\nvar HarmSeverity;\n(function (HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */\n    HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Status of the url retrieval. */\nvar UrlRetrievalStatus;\n(function (UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall. This enum value is not supported in Vertex AI.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe. This enum value is not supported in Vertex AI.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the prompt was blocked. */\nvar BlockedReason;\n(function (BlockedReason) {\n    /**\n     * The blocked reason is unspecified.\n     */\n    BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * The prompt was blocked for safety reasons.\n     */\n    BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The prompt was blocked for other reasons. For example, it may be due to the prompt's language, or because it contains other harmful content.\n     */\n    BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * The prompt was blocked because it contains a term from the terminology blocklist.\n     */\n    BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * The prompt was blocked because it contains prohibited content.\n     */\n    BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * The prompt was blocked because it contains content that is unsafe for image generation.\n     */\n    BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The prompt was blocked by Model Armor. This enum value is not supported in Gemini API.\n     */\n    BlockedReason[\"MODEL_ARMOR\"] = \"MODEL_ARMOR\";\n    /**\n     * The prompt was blocked as a jailbreak attempt. This enum value is not supported in Gemini API.\n     */\n    BlockedReason[\"JAILBREAK\"] = \"JAILBREAK\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. This enum is not supported in Gemini API. */\nvar TrafficType;\n(function (TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */\n    TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * Type for Pay-As-You-Go traffic.\n     */\n    TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */\n    TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */\nvar Modality;\n(function (Modality) {\n    /**\n     * The modality is unspecified.\n     */\n    Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */\n    Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */\n    Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */\n    Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */\nvar MediaResolution;\n(function (MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Tuning mode. This enum is not supported in Gemini API. */\nvar TuningMode;\n(function (TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */\n    TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Adapter size for tuning. This enum is not supported in Gemini API. */\nvar AdapterSize;\n(function (AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */\n    AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */\n    AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */\n    AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */\n    AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */\n    AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */\n    AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */\n    AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Job state. */\nvar JobState;\n(function (JobState) {\n    /**\n     * The job state is unspecified.\n     */\n    JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */\n    JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */\n    JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */\n    JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */\n    JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */\n    JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */\n    JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */\n    JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */\n    JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */\n    JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */\n    JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */\n    JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** The tuning task. Either I2V or T2V. This enum is not supported in Gemini API. */\nvar TuningTask;\n(function (TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */\n    TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */\n    TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */\n    TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n})(TuningTask || (TuningTask = {}));\n/** Options for feature selection preference. */\nvar FeatureSelectionPreference;\n(function (FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */\nvar Behavior;\n(function (Behavior) {\n    /**\n     * This value is unused.\n     */\n    Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */\n    Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */\n    Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */\nvar DynamicRetrievalConfigMode;\n(function (DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */\n    DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */\n    DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** The environment being operated. */\nvar Environment;\n(function (Environment) {\n    /**\n     * Defaults to browser.\n     */\n    Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */\n    Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Config for the function calling config mode. */\nvar FunctionCallingConfigMode;\n(function (FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */\n    FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */\n    FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */\n    FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model decides to predict either a function call or a natural language response, but will validate function calls with constrained decoding. If \"allowed_function_names\" are set, the predicted function call will be limited to any one of \"allowed_function_names\", else the predicted function call will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */\nvar SafetyFilterLevel;\n(function (SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */\nvar PersonGeneration;\n(function (PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */\n    PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */\n    PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */\n    PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */\nvar ImagePromptLanguage;\n(function (ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */\n    ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */\n    ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */\n    ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */\n    ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */\n    ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */\n    ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */\n    ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */\n    ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */\nvar MaskReferenceMode;\n(function (MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */\nvar ControlReferenceType;\n(function (ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */\nvar SubjectReferenceType;\n(function (SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */\nvar EditMode;\n(function (EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */\nvar SegmentMode;\n(function (SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */\nvar VideoGenerationReferenceType;\n(function (VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */\n    VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */\n    VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */\nvar VideoGenerationMaskMode;\n(function (VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */\n    VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */\n    VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */\n    VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */\n    VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */\nvar VideoCompressionQuality;\n(function (VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */\n    VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */\n    VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** Enum representing the tuning method. */\nvar TuningMethod;\n(function (TuningMethod) {\n    /**\n     * Supervised fine tuning.\n     */\n    TuningMethod[\"SUPERVISED_FINE_TUNING\"] = \"SUPERVISED_FINE_TUNING\";\n    /**\n     * Preference optimization tuning.\n     */\n    TuningMethod[\"PREFERENCE_TUNING\"] = \"PREFERENCE_TUNING\";\n})(TuningMethod || (TuningMethod = {}));\n/** State for the lifecycle of a File. */\nvar FileState;\n(function (FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */\nvar FileSource;\n(function (FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */\nvar TurnCompleteReason;\n(function (TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */\n    TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */\n    TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */\n    TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */\nvar MediaModality;\n(function (MediaModality) {\n    /**\n     * The modality is unspecified.\n     */\n    MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */\n    MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */\n    MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */\n    MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */\n    MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */\n    MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */\nvar StartSensitivity;\n(function (StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */\n    StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */\nvar EndSensitivity;\n(function (EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */\n    EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */\nvar ActivityHandling;\n(function (ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */\n    ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */\n    ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */\n    ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */\nvar TurnCoverage;\n(function (TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */\n    TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */\n    TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */\n    TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Scale of the generated music. */\nvar Scale;\n(function (Scale) {\n    /**\n     * Default value. This value is unused.\n     */\n    Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */\n    Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */\n    Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */\n    Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */\n    Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */\n    Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */\n    Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */\n    Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */\n    Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */\n    Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */\n    Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */\n    Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */\n    Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */\nvar MusicGenerationMode;\n(function (MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */\n    MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */\n    MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */\n    MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */\n    MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */\nvar LiveMusicPlaybackControl;\n(function (LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */\n    LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */\n    LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */\n    LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */\n    LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */\n    LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\nText should not be sent as raw bytes, use the FunctionResponse.response\nfield. */\nclass FunctionResponseBlob {\n}\n/** URI based data for function response. */\nclass FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\nA `FunctionResponsePart` consists of data which has an associated datatype. A\n`FunctionResponsePart` can only contain one of the accepted types in\n`FunctionResponsePart.data`.\n\nA `FunctionResponsePart` must have a fixed IANA MIME type identifying the\ntype and subtype of the media if the `inline_data` field is filled with raw\nbytes. */\nclass FunctionResponsePart {\n}\n/**\n * Creates a `FunctionResponsePart` object from a `base64` encoded `string`.\n */\nfunction createFunctionResponsePartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType,\n        },\n    };\n}\n/**\n * Creates a `FunctionResponsePart` object from a `URI` string.\n */\nfunction createFunctionResponsePartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType,\n        },\n    };\n}\n/** A function response. */\nclass FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */\nfunction createPartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType,\n        },\n    };\n}\n/**\n * Creates a `Part` object from a `text` string.\n */\nfunction createPartFromText(text) {\n    return {\n        text: text,\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */\nfunction createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args,\n        },\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */\nfunction createPartFromFunctionResponse(id, name, response, parts = []) {\n    return {\n        functionResponse: Object.assign({ id: id, name: name, response: response }, (parts.length > 0 && { parts })),\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */\nfunction createPartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType,\n        },\n    };\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */\nfunction createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output,\n        },\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */\nfunction createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language,\n        },\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === 'object' && obj !== null) {\n        return ('fileData' in obj ||\n            'text' in obj ||\n            'functionCall' in obj ||\n            'functionResponse' in obj ||\n            'inlineData' in obj ||\n            'videoMetadata' in obj ||\n            'codeExecutionResult' in obj ||\n            'executableCode' in obj);\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === 'string') {\n        parts.push(createPartFromText(partOrString));\n    }\n    else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    }\n    else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error('partOrString cannot be an empty array');\n        }\n        for (const part of partOrString) {\n            if (typeof part === 'string') {\n                parts.push(createPartFromText(part));\n            }\n            else if (_isPart(part)) {\n                parts.push(part);\n            }\n            else {\n                throw new Error('element in PartUnion must be a Part object or string');\n            }\n        }\n    }\n    else {\n        throw new Error('partOrString must be a Part object, string, or array');\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */\nfunction createUserContent(partOrString) {\n    return {\n        role: 'user',\n        parts: _toParts(partOrString),\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */\nfunction createModelContent(partOrString) {\n    return {\n        role: 'model',\n        parts: _toParts(partOrString),\n    };\n}\n/** A wrapper class for the http response. */\nclass HttpResponse {\n    constructor(response) {\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()) {\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. Note: This is sent only in the first stream chunk and only if no candidates were generated due to content violations. */\nclass GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about response(s). This data type is not supported in Gemini API. */\nclass GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */\nclass GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */\n    get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning text from the first one.');\n        }\n        let text = '';\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning data from the first one.');\n        }\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */\n    get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning function calls from the first one.');\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */\n    get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning executable code from the first one.');\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode) => executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */\n    get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning code execution result from the first one.');\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult) => codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */\nclass EmbedContentResponse {\n}\n/** The output images response. */\nclass GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */\nclass EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */\nclass RecontextImageResponse {\n}\n/** The output images response. */\nclass SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */\nclass CountTokensResponse {\n}\n/** Response for computing tokens. */\nclass ComputeTokensResponse {\n}\n/** Response with generated videos. */\nclass GenerateVideosResponse {\n}\n/** A video generation operation. */\nclass GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, isVertexAI, }) {\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        }\n        else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */\nclass ListTuningJobsResponse {\n}\n/** Empty response for caches.delete method. */\nclass DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Response for the list files method. */\nclass ListFilesResponse {\n}\n/** Response for the create file method. */\nclass CreateFileResponse {\n}\n/** Response for the delete file method. */\nclass DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */\nclass InlinedResponse {\n}\n/** Config for `response` parameter. */\nclass SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */\nclass InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */\nclass ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */\nclass ReplayResponse {\n}\n/** A raw reference image.\n\nA raw reference image represents the base image to edit, provided by the user.\nIt can optionally be provided in addition to a mask reference image or\na style reference image. */\nclass RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_RAW',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\nThis encapsulates either a mask image provided by the user and configs for\nthe user provided mask, or only config parameters for the model to generate\na mask.\n\nA mask image is an image whose non-zero values indicate where to edit the base\nimage. If the user provides a mask image, the mask must be in the same\ndimensions as the raw image. */\nclass MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_MASK',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\nThe image of the control reference image is either a control image provided\nby the user, or a regular image which the backend will use to generate a\ncontrol image of. In the case of the latter, the\nenable_control_image_computation field in the config should be set to True.\n\nA control image is an image that represents a sketch image of areas for the\nmodel to fill in based on the prompt. */\nclass ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTROL',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\nThis encapsulates a style reference image provided by the user, and\nadditionally optional config parameters for the style reference image.\n\nA raw reference image can also be provided as a destination for the style to\nbe applied to. */\nclass StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_STYLE',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\nThis encapsulates a subject reference image provided by the user, and\nadditionally optional config parameters for the subject reference image.\n\nA raw reference image can also be provided as a destination for the subject to\nbe applied to. */\nclass SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_SUBJECT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\nA content reference image represents a subject to reference (ex. person,\nproduct, animal) provided by the user. It can optionally be provided in\naddition to a style reference image (ex. background, style reference). */\nclass ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTENT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */\nclass LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */\n    get text() {\n        var _a, _b, _c;\n        let text = '';\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c;\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\nIndividual `FunctionResponse` objects are matched to the respective\n`FunctionCall` objects by the `id` field.\n\nNote that in the unary and server-streaming GenerateContent APIs function\ncalling happens by exchanging the `Content` parts, while in the bidi\nGenerateContent APIs function calling happens over this dedicated set of\nmessages. */\nclass LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */\nclass LiveSendToolResponseParameters {\n    constructor() {\n        /** Tool responses to send to the session. */\n        this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */\nclass LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */\n    get audioChunk() {\n        if (this.serverContent &&\n            this.serverContent.audioChunks &&\n            this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tModel(apiClient, model) {\n    if (!model || typeof model !== 'string') {\n        throw new Error('model is required and must be a string');\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith('publishers/') ||\n            model.startsWith('projects/') ||\n            model.startsWith('models/')) {\n            return model;\n        }\n        else if (model.indexOf('/') >= 0) {\n            const parts = model.split('/', 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        }\n        else {\n            return `publishers/google/models/${model}`;\n        }\n    }\n    else {\n        if (model.startsWith('models/') || model.startsWith('tunedModels/')) {\n            return model;\n        }\n        else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return '';\n    }\n    if (transformedModel.startsWith('publishers/') && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    }\n    else if (transformedModel.startsWith('models/') && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    }\n    else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob) => tBlob(blob));\n    }\n    else {\n        return [tBlob(blobs)];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === 'object' && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('image/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('audio/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('PartUnion is required');\n    }\n    if (typeof origin === 'object') {\n        return origin;\n    }\n    if (typeof origin === 'string') {\n        return { text: origin };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('PartListUnion is required');\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tPart(item));\n    }\n    return [tPart(origin)];\n}\nfunction _isContent(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'parts' in origin &&\n        Array.isArray(origin.parts));\n}\nfunction _isFunctionCallPart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionCall' in origin);\n}\nfunction _isFunctionResponsePart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionResponse' in origin);\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('ContentUnion is required');\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: 'user',\n        parts: tParts(origin),\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item) => {\n            const content = tContent(item);\n            if (content.parts &&\n                content.parts.length > 0 &&\n                content.parts[0].text !== undefined) {\n                return [content.parts[0].text];\n            }\n            return [];\n        });\n    }\n    else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts &&\n            content.parts.length > 0 &&\n            content.parts[0].text !== undefined) {\n            return [content.parts[0].text];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tContent(item));\n    }\n    return [tContent(origin)];\n}\nfunction tContents(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('contents are required');\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them');\n        }\n        return [tContent(origin)];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin) {\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error('Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them');\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        }\n        else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them');\n        }\n        else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({ role: 'user', parts: tParts(accumulatedParts) });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/\nfunction flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes('null')) {\n        resultingSchema['nullable'] = true;\n    }\n    const listWithoutNull = typeList.filter((type) => type !== 'null');\n    if (listWithoutNull.length === 1) {\n        resultingSchema['type'] = Object.values(Type).includes(listWithoutNull[0].toUpperCase())\n            ? listWithoutNull[0].toUpperCase()\n            : Type.TYPE_UNSPECIFIED;\n    }\n    else {\n        resultingSchema['anyOf'] = [];\n        for (const i of listWithoutNull) {\n            resultingSchema['anyOf'].push({\n                'type': Object.values(Type).includes(i.toUpperCase())\n                    ? i.toUpperCase()\n                    : Type.TYPE_UNSPECIFIED,\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = ['items'];\n    const listSchemaFieldNames = ['anyOf'];\n    const dictSchemaFieldNames = ['properties'];\n    if (_jsonSchema['type'] && _jsonSchema['anyOf']) {\n        throw new Error('type and anyOf cannot be both populated.');\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */\n    const incomingAnyOf = _jsonSchema['anyOf'];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[1];\n        }\n        else if (incomingAnyOf[1]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema['type'] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema['type'], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == 'type') {\n            if (fieldValue === 'null') {\n                throw new Error('type: null can not be the only possible type for the field.');\n            }\n            if (fieldValue instanceof Array) {\n                // we have already handled the type field with array of types in the\n                // beginning of this function.\n                continue;\n            }\n            genAISchema['type'] = Object.values(Type).includes(fieldValue.toUpperCase())\n                ? fieldValue.toUpperCase()\n                : Type.TYPE_UNSPECIFIED;\n        }\n        else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] =\n                processJsonSchema(fieldValue);\n        }\n        else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue) {\n                if (item['type'] == 'null') {\n                    genAISchema['nullable'] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] =\n                listSchemaFieldValue;\n        }\n        else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)) {\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] =\n                dictSchemaFieldValue;\n        }\n        else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === 'additionalProperties') {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === 'object') {\n        return speechConfig;\n    }\n    else if (typeof speechConfig === 'string') {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig,\n                },\n            },\n        };\n    }\n    else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if ('multiSpeakerVoiceConfig' in speechConfig) {\n        throw new Error('multiSpeakerVoiceConfig is not supported in the live API.');\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations) {\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes('$schema')) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                }\n                else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema =\n                            functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes('$schema')) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                }\n                else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema =\n                            functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error('tools is required');\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error('tools is required and must be an array of Tools');\n    }\n    const result = [];\n    for (const tool of tools) {\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */\nfunction resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) &&\n        resourceName.split('/').length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith('projects/')) {\n            return resourceName;\n        }\n        else if (resourceName.startsWith('locations/')) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        }\n        else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        }\n        else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        }\n        else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== 'string') {\n        throw new Error('name must be a string');\n    }\n    return resourceName(apiClient, name, 'cachedContents');\n}\nfunction tTuningJobStatus(status) {\n    switch (status) {\n        case 'STATE_UNSPECIFIED':\n            return 'JOB_STATE_UNSPECIFIED';\n        case 'CREATING':\n            return 'JOB_STATE_RUNNING';\n        case 'ACTIVE':\n            return 'JOB_STATE_SUCCEEDED';\n        case 'FAILED':\n            return 'JOB_STATE_FAILED';\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'name' in origin);\n}\nfunction isGeneratedVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'video' in origin);\n}\nfunction isVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'uri' in origin);\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === 'string') {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error('Could not extract file name from the provided input.');\n    }\n    if (name.startsWith('https://')) {\n        const suffix = name.split('files/')[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    }\n    else if (name.startsWith('files/')) {\n        name = name.split('files/')[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? 'publishers/google/models' : 'models';\n    }\n    else {\n        res = baseModels ? 'models' : 'tunedModels';\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of ['models', 'tunedModels', 'publisherModels']) {\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === 'object' && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema['name'],\n        description: mcpToolSchema['description'],\n        parametersJsonSchema: mcpToolSchema['inputSchema'],\n    };\n    if (mcpToolSchema['outputSchema']) {\n        functionDeclaration['responseJsonSchema'] = mcpToolSchema['outputSchema'];\n    }\n    if (config.behavior) {\n        functionDeclaration['behavior'] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration,\n        ],\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */\nfunction mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools) {\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return { functionDeclarations: functionDeclarations };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === 'string') {\n        if (client.isVertexAI()) {\n            if (src.startsWith('gs://')) {\n                sourceObj = { format: 'jsonl', gcsUri: [src] };\n            }\n            else if (src.startsWith('bq://')) {\n                sourceObj = { format: 'bigquery', bigqueryUri: src };\n            }\n            else {\n                throw new Error(`Unsupported string source for Vertex AI: ${src}`);\n            }\n        }\n        else {\n            // MLDEV\n            if (src.startsWith('files/')) {\n                sourceObj = { fileName: src }; // Default to fileName for string input\n            }\n            else {\n                throw new Error(`Unsupported string source for Gemini API: ${src}`);\n            }\n        }\n    }\n    else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error('InlinedRequest[] is not supported in Vertex AI.');\n        }\n        sourceObj = { inlinedRequests: src };\n    }\n    else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName,\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error('Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.');\n        }\n    }\n    else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error('Exactly one of `inlinedRequests`, `fileName`, ' +\n                'must be set for Gemini API.');\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== 'string') {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith('gs://')) {\n        return {\n            format: 'jsonl',\n            gcsUri: destString,\n        };\n    }\n    else if (destString.startsWith('bq://')) {\n        return {\n            format: 'bigquery',\n            bigqueryUri: destString,\n        };\n    }\n    else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== 'object' || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj['inlinedResponses'];\n    if (typeof inlineResponsesVal !== 'object' || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj['inlinedResponses'];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray) {\n        if (typeof responseItem !== 'object' || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj['response'];\n        if (typeof responseVal !== 'object' || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj['embedding'] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj['inlinedEmbedContentResponses'] = obj['inlinedResponses'];\n        delete obj['inlinedResponses'];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split('/').pop();\n        }\n        else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split('/').pop();\n    }\n    else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    }\n    else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === 'BATCH_STATE_UNSPECIFIED') {\n        return 'JOB_STATE_UNSPECIFIED';\n    }\n    else if (stateString === 'BATCH_STATE_PENDING') {\n        return 'JOB_STATE_PENDING';\n    }\n    else if (stateString === 'BATCH_STATE_RUNNING') {\n        return 'JOB_STATE_RUNNING';\n    }\n    else if (stateString === 'BATCH_STATE_SUCCEEDED') {\n        return 'JOB_STATE_SUCCEEDED';\n    }\n    else if (stateString === 'BATCH_STATE_FAILED') {\n        return 'JOB_STATE_FAILED';\n    }\n    else if (stateString === 'BATCH_STATE_CANCELLED') {\n        return 'JOB_STATE_CANCELLED';\n    }\n    else if (stateString === 'BATCH_STATE_EXPIRED') {\n        return 'JOB_STATE_EXPIRED';\n    }\n    else {\n        return stateString;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['responsesFile']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        'inlinedResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['inlinedResponses'], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        'inlinedEmbedContentResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['inlinedEmbedContentResponses'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['predictionsFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        'gcsDestination',\n        'outputUriPrefix',\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigqueryDestination',\n        'outputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['predictionsFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsDestination', 'outputUriPrefix'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryDestination', 'outputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedResponses']) !== undefined) {\n        throw new Error('inlinedResponses parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedEmbedContentResponses']) !==\n        undefined) {\n        throw new Error('inlinedEmbedContentResponses parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        'metadata',\n        'displayName',\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['metadata', 'state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        'metadata',\n        'createTime',\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'metadata',\n        'endTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        'metadata',\n        'updateTime',\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['metadata', 'model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, ['metadata', 'output']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, ['inputConfig']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['src'], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, ['outputConfig']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['instancesFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsSource', 'uris']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigquerySource',\n        'inputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['format']) !== undefined) {\n        throw new Error('format parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['bigqueryUri']) !== undefined) {\n        throw new Error('bigqueryUri parameter is not supported in Gemini API.');\n    }\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, ['requests', 'requests'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['instancesFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsSource', 'uris'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigquerySource', 'inputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedRequests']) !== undefined) {\n        throw new Error('inlinedRequests parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['safetyRatings'], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['citations'], transformedList);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, ['dest']) !== undefined) {\n        throw new Error('dest parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, ['dest']);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, ['outputConfig'], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['inputConfig'], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['requests[]', 'request', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['_self'], embedContentConfigToMldev$1(fromConfig, toObject));\n        moveValueByPath(toObject, { 'requests[].*': 'requests[].request.*' });\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['file_name'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, ['requests'], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], fromImageConfig);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['request', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['request', 'contents'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['request', 'generationConfig'], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ['request'], {})));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    if (getValueByPath(fromObject, ['filter']) !== undefined) {\n        throw new Error('filter parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, ['operations']);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        'batchPredictionJobs',\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], fromFunctionCall);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$4(fromFileData));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$4(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$4(fromGoogleMaps));\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nvar PagedItem;\n(function (PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n    PagedItem[\"PAGED_ITEM_RAG_STORES\"] = \"ragStores\";\n    PagedItem[\"PAGED_ITEM_DOCUMENTS\"] = \"documents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */\nclass Pager {\n    constructor(name, request, response, params) {\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = { config: {} };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = { config: {} };\n        }\n        else if (typeof params === 'object') {\n            requestParams = Object.assign({}, params);\n        }\n        else {\n            requestParams = params;\n        }\n        if (requestParams['config']) {\n            requestParams['config']['pageToken'] = response['nextPageToken'];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize =\n            (_b = (_a = requestParams['config']) === null || _a === void 0 ? void 0 : _a['pageSize']) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */\n    get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */\n    get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */\n    get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */\n    get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */\n    get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */\n    get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */\n    getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */\n    [Symbol.asyncIterator]() {\n        return {\n            next: async () => {\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return { value: item, done: false };\n            },\n            return: async () => {\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */\n    async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error('No more pages to fetch.');\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */\n    hasNextPage() {\n        var _a;\n        if (((_a = this.params['config']) === null || _a === void 0 ? void 0 : _a['pageToken']) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Batches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.create = async (params) => {\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n            }\n            return this.createInternal(params);\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.createEmbeddings = async (params) => {\n            console.warn('batches.createEmbeddings() is experimental and may change without notice.');\n            if (this.apiClient.isVertexAI()) {\n                throw new Error('Vertex AI does not support batches.createEmbeddings.');\n            }\n            return this.createEmbeddingsInternal(params);\n        };\n        /**\n         * Lists batch job configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, // Use instance apiClient\n        params);\n        const urlParams = body['_url'];\n        const path = formatMap('{model}:batchGenerateContent', urlParams);\n        const batch = body['batch'];\n        const inputConfig = batch['inputConfig'];\n        const requestsWrapper = inputConfig['requests'];\n        const requests = requestsWrapper['requests'];\n        const newRequests = [];\n        for (const request of requests) {\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict['systemInstruction']) {\n                const systemInstructionValue = requestDict['systemInstruction'];\n                delete requestDict['systemInstruction'];\n                const requestContent = requestDict['request'];\n                requestContent['systemInstruction'] = systemInstructionValue;\n                requestDict['request'] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper['requests'] = newRequests;\n        delete body['config'];\n        delete body['_url'];\n        delete body['_query'];\n        return { path, body };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('gs://') ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('bq://') ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = `genaiBatchJob_${timestampStr}`;\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith('.jsonl')) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;\n                }\n                else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = `${gcsUri}_dest_${timestampStr}`;\n                }\n            }\n            else if (bigqueryUri) {\n                newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;\n            }\n            else {\n                throw new Error('Unsupported source for Vertex AI: No GCS or BigQuery URI found.');\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchGenerateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:asyncBatchEmbedContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n        else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap('batches', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$3(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    if (getValueByPath(fromObject, ['kmsKeyName']) !== undefined) {\n        throw new Error('kmsKeyName parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, ['kmsKeyName']);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, ['encryption_spec', 'kmsKeyName'], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], fromFunctionCall);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$3(fromFileData));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$3(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$3(fromGoogleMaps));\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Caches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached content configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */\n    async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns true if the response is valid, false otherwise.\n */\nfunction isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts) {\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */\nfunction validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history) {\n        if (content.role !== 'user' && content.role !== 'model') {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */\nfunction extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while (i < length) {\n        if (comprehensiveHistory[i].role === 'user') {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        }\n        else {\n            const modelOutput = [];\n            let isValid = true;\n            while (i < length && comprehensiveHistory[i].role === 'model') {\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            }\n            else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */\nclass Chats {\n    constructor(modelsModule, apiClient) {\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */\n    create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, \n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */\nclass Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []) {\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */\n    async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        this.sendPromise = (async () => {\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory =\n                    (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [outputContent] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(() => {\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */\n    async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse\n            .then(() => undefined)\n            .catch(() => undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */\n    getHistory(curated = false) {\n        const history = curated\n            ? extractCuratedHistory(this.history)\n            : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 &&\n            modelOutput.every((content) => content.role !== undefined)) {\n            outputContents = modelOutput;\n        }\n        else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: 'model',\n                parts: [],\n            });\n        }\n        if (automaticFunctionCallingHistory &&\n            automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        }\n        else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * API errors raised by the GenAI API.\n */\nclass ApiError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.name = 'ApiError';\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, ['file']);\n    if (fromFile != null) {\n        setValueByPath(toObject, ['file'], fromFile);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, ['files']);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['files'], transformedList);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Files extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists all current project files from the service.\n         *\n         * @param params - The parameters for the list request\n         * @return The paginated results of the list of files\n         *\n         * @example\n         * The following code prints the names of all files from the service, the\n         * size of each page is 10.\n         *\n         * ```ts\n         * const listResponse = await ai.files.list({config: {'pageSize': 10}});\n         * for await (const file of listResponse) {\n         *   console.log(file.name);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */\n    async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Vertex AI does not support uploading files. You can share files through a GCS bucket.');\n        }\n        return this.apiClient\n            .uploadFile(params.file, params.config)\n            .then((resp) => {\n            return resp;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */\n    async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap('files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap('upload/v1beta/files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generationConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, ['enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToVertex$1(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    if (getValueByPath(fromObject, ['enableEnhancedCivicAnswers']) !==\n        undefined) {\n        throw new Error('enableEnhancedCivicAnswers parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], generationConfigToVertex$1(fromGenerationConfig));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], fromSessionResumption);\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        'musicGenerationConfig',\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, ['musicGenerationConfig'], fromMusicGenerationConfig);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        'weightedPrompts',\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['weightedPrompts'], transformedList);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return blobToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], blobToMldev$2(tAudioBlob(fromAudio)));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], blobToMldev$2(tImageBlob(fromVideo)));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        'setupComplete',\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, ['setupComplete'], fromSetupComplete);\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        'serverContent',\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, ['serverContent'], fromServerContent);\n    }\n    const fromToolCall = getValueByPath(fromObject, ['toolCall']);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, ['toolCall'], fromToolCall);\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        'toolCallCancellation',\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, ['toolCallCancellation'], fromToolCallCancellation);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, ['goAway']);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, ['goAway'], fromGoAway);\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        'sessionResumptionUpdate',\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, ['sessionResumptionUpdate'], fromSessionResumptionUpdate);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], fromFunctionCall);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$2(fromFileData));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$2(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, ['multiSpeakerVoiceConfig']) !== undefined) {\n        throw new Error('multiSpeakerVoiceConfig parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$2(fromGoogleMaps));\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        'promptTokenCount',\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, ['promptTokenCount'], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        'candidatesTokenCount',\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, ['responseTokenCount'], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        'toolUsePromptTokenCount',\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, ['toolUsePromptTokenCount'], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        'thoughtsTokenCount',\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, ['thoughtsTokenCount'], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        'totalTokenCount',\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, ['totalTokenCount'], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        'promptTokensDetails',\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['promptTokensDetails'], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        'cacheTokensDetails',\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cacheTokensDetails'], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        'candidatesTokensDetails',\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['responseTokensDetails'], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        'toolUsePromptTokensDetails',\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['toolUsePromptTokensDetails'], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, ['trafficType']);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, ['trafficType'], fromTrafficType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['safetyRatings'], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['citations'], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, ['tokensInfo']);\n    if (fromTokensInfo != null) {\n        let transformedList = fromTokensInfo;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['tokensInfo'], transformedList);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, ['values']);\n    if (fromValues != null) {\n        setValueByPath(toObject, ['values'], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, ['statistics']);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, ['statistics'], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, ['truncated']);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, ['truncated'], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['token_count']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, ['controlType']);\n    if (fromControlType != null) {\n        setValueByPath(toObject, ['controlType'], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        'enableControlImageComputation',\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, ['computeControl'], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['systemInstruction']) !== undefined) {\n        throw new Error('systemInstruction parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['tools']) !== undefined) {\n        throw new Error('tools parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['generationConfig']) !== undefined) {\n        throw new Error('generationConfig parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['generationConfig'], generationConfigToVertex(fromGenerationConfig));\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromEditMode = getValueByPath(fromObject, ['editMode']);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, ['parameters', 'editMode'], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'editConfig', 'baseSteps'], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['instances[]', 'task_type'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['instances[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, ['instances[]', 'mimeType'], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, ['autoTruncate']);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, ['parameters', 'autoTruncate'], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['requests[]', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, ['model']);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, ['requests[]', 'model'], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['instances[]', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, ['embeddings']);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        'predictions[]',\n        'embeddings',\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['endpoint']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        'deployedModelId',\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, ['deployedModelId'], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], fromImageConfig);\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], fromImageConfig);\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['negativePrompt']) !== undefined) {\n        throw new Error('negativePrompt parameter is not supported in Gemini API.');\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, ['addWatermark']) !== undefined) {\n        throw new Error('addWatermark parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['enhancePrompt']) !== undefined) {\n        throw new Error('enhancePrompt parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['fps']) !== undefined) {\n        throw new Error('fps parameter is not supported in Gemini API.');\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, ['pubsubTopic']) !== undefined) {\n        throw new Error('pubsubTopic parameter is not supported in Gemini API.');\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, ['generateAudio']) !== undefined) {\n        throw new Error('generateAudio parameter is not supported in Gemini API.');\n    }\n    const fromLastFrame = getValueByPath(fromObject, ['lastFrame']);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, ['instances[0]', 'lastFrame'], imageToMldev(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return videoGenerationReferenceImageToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['mask']) !== undefined) {\n        throw new Error('mask parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['compressionQuality']) !== undefined) {\n        throw new Error('compressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, ['parameters', 'fps'], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, ['pubsubTopic']);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, ['parameters', 'pubsubTopic'], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        'generateAudio',\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, ['parameters', 'generateAudio'], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, ['lastFrame']);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, ['instances[0]', 'lastFrame'], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, ['mask']);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, ['instances[0]', 'mask'], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        'compressionQuality',\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'compressionQuality'], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['instances[0]', 'video'], videoToMldev(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, ['instances[0]', 'video'], videoToMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, ['enhancedPrompt'], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, ['_self']);\n    if (fromMask != null) {\n        setValueByPath(toObject, ['mask'], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['labels'], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generationConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, ['enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToVertex(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    if (getValueByPath(fromObject, ['enableEnhancedCivicAnswers']) !==\n        undefined) {\n        throw new Error('enableEnhancedCivicAnswers parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        'segmentationClasses',\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, ['maskClasses'], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, ['dilation'], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['version']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        'inputTokenLimit',\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, ['inputTokenLimit'], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        'outputTokenLimit',\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, ['outputTokenLimit'], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        'supportedGenerationMethods',\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, ['supportedActions'], fromSupportedActions);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['versionId']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, ['deployedModels']);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['endpoints'], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, ['checkpoints']);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['checkpoints'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], fromFunctionCall);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$1(fromFileData));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$1(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, ['productImage']);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'editConfig', 'baseSteps'], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, ['personImage']);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'personImage', 'image'], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        'productImages',\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'productImages'], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        'referenceImage',\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, ['referenceImage'], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, ['referenceId']);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, ['referenceId'], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        'maskImageConfig',\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, ['maskImageConfig'], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        'controlImageConfig',\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, ['controlImageConfig'], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        'styleImageConfig',\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, ['styleImageConfig'], fromStyleImageConfig);\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        'subjectImageConfig',\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, ['subjectImageConfig'], fromSubjectImageConfig);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        'maxPredictions',\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, ['parameters', 'maxPredictions'], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        'confidenceThreshold',\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'confidenceThreshold'], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, ['parameters', 'maskDilation'], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        'binaryColorThreshold',\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'binaryColorThreshold'], fromBinaryColorThreshold);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, ['predictions']);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedMasks'], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        'scribbleImage',\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'scribble'], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, ['multiSpeakerVoiceConfig']) !== undefined) {\n        throw new Error('multiSpeakerVoiceConfig parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$1(fromGoogleMaps));\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        'labels',\n        'google-vertex-llm-tuning-base-model-id',\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        'enhanceInputImage',\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'enhanceInputImage'], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        'imagePreservationFactor',\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'imagePreservationFactor'], fromImagePreservationFactor);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        'upscaleFactor',\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, ['parameters', 'upscaleConfig', 'upscaleFactor'], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['encodedVideo']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['_self'], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToMldev(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoToMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['videoBytes']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['encodedVideo'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['encoding'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['videoBytes']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst CONTENT_TYPE_HEADER = 'Content-Type';\nconst SERVER_TIMEOUT_HEADER = 'X-Server-Timeout';\nconst USER_AGENT_HEADER = 'User-Agent';\nconst GOOGLE_API_CLIENT_HEADER = 'x-goog-api-client';\nconst SDK_VERSION = '1.28.0'; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = 'v1beta1';\nconst GOOGLE_AI_API_DEFAULT_VERSION = 'v1beta';\nconst responseLineRE = /^\\s*data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */\nclass ApiClient {\n    constructor(opts) {\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion =\n                (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        }\n        else {\n            // Gemini API\n            initHttpOptions.apiVersion =\n                (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */\n    baseUrlFromProjectLocation() {\n        if (this.clientOptions.project &&\n            this.clientOptions.location &&\n            this.clientOptions.location !== 'global') {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */\n    normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error('API version is not set.');\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error('Base URL is not set.');\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        }\n        else {\n            throw new Error('Headers are not set.');\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions ||\n            httpOptions.baseUrl === undefined ||\n            httpOptions.apiVersion === undefined) {\n            throw new Error('HTTP options are not correctly set.');\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith('/')\n            ? httpOptions.baseUrl.slice(0, -1)\n            : httpOptions.baseUrl;\n        const urlElement = [baseUrl];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== '') {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join('/');\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == 'http:' ? 'ws' : 'wss';\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        }\n        else {\n            throw new Error('HTTP options are not correctly set.');\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [this.getRequestUrlInternal(httpOptions)];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== '') {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join('/')}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith('projects/')) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === 'GET' &&\n            request.path.startsWith('publishers/google/models')) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)) {\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === 'GET') {\n            if (request.body && request.body !== '{}') {\n                throw new Error('Request body should be empty for GET request, but got non empty request body');\n            }\n        }\n        else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)) {\n            // Records compile to objects.\n            if (typeof value === 'object') {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            }\n            else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has('alt') || url.searchParams.get('alt') !== 'sse') {\n            url.searchParams.set('alt', 'sse');\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {\n        if ((httpOptions && httpOptions.timeout) || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle &&\n                    typeof timeoutHandle.unref ===\n                        'function') {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener('abort', () => {\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions, url);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder('utf-8');\n            if (!reader) {\n                throw new Error('Response body is empty');\n            }\n            try {\n                let buffer = '';\n                while (true) {\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error('Incomplete JSON segment at the end');\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, { stream: true });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if ('error' in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson['error']));\n                            const status = errorJson['status'];\n                            const code = errorJson['code'];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code,\n                                });\n                                throw apiError;\n                            }\n                        }\n                    }\n                    catch (e) {\n                        const error = e;\n                        if (error.name === 'ApiError') {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while (match) {\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText,\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        }\n                        catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e) => {\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + ' ' + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = 'application/json';\n        return headers;\n    }\n    async getHeadersInternal(httpOptions, url) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)) {\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers, url);\n        return headers;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link types.UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */\n    async uploadFile(file, config) {\n        var _a, _b;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith('files/')) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === '') {\n            throw new Error('Can not determine mimeType. Please provide mimeType in the config.');\n        }\n        fileToUpload.mimeType = mimeType;\n        let fileName = '';\n        if (typeof file === 'string') {\n            fileName = file.replace(/[/\\\\]+$/, '');\n            fileName = (_b = fileName.split(/[/\\\\]/).pop()) !== null && _b !== void 0 ? _b : '';\n        }\n        const uploadUrl = await this.fetchUploadUrl(fileToUpload, fileName, config);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * types.DownloadFileParameters}\n     */\n    async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(file, fileName, config) {\n        var _a;\n        let httpOptions = {};\n        if (config === null || config === void 0 ? void 0 : config.httpOptions) {\n            httpOptions = config.httpOptions;\n        }\n        else {\n            httpOptions = {\n                apiVersion: '',\n                headers: Object.assign({ 'Content-Type': 'application/json', 'X-Goog-Upload-Protocol': 'resumable', 'X-Goog-Upload-Command': 'start', 'X-Goog-Upload-Header-Content-Length': `${file.sizeBytes}`, 'X-Goog-Upload-Header-Content-Type': `${file.mimeType}` }, (fileName ? { 'X-Goog-Upload-File-Name': fileName } : {})),\n            };\n        }\n        const body = {\n            'file': file,\n        };\n        const httpResponse = await this.request({\n            path: formatMap('upload/v1beta/files', body['_url']),\n            body: JSON.stringify(body),\n            httpMethod: 'POST',\n            httpOptions,\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error('Server did not return an HttpResponse or the returned HttpResponse did not have headers.');\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a['x-goog-upload-url'];\n        if (uploadUrl === undefined) {\n            throw new Error('Failed to get upload url. Server did not return the x-google-upload-url in the headers');\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error('response is undefined');\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n            errorBody = await response.json();\n        }\n        else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText,\n                },\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status,\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */\nfunction includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn('includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.');\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === 'string' && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === 'object' &&\n                parsedBody !== null &&\n                !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            }\n            else {\n                console.warn('includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.');\n                return;\n            }\n            /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */\n        }\n        catch (e) {\n            console.warn('includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.');\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue &&\n                    typeof sourceValue === 'object' &&\n                    !Array.isArray(sourceValue) &&\n                    targetValue &&\n                    typeof targetValue === 'object' &&\n                    !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                }\n                else {\n                    if (targetValue &&\n                        sourceValue &&\n                        typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = 'mcp_used/unknown';\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools) {\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === 'object' && 'inputSchema' in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : '';\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return (object !== null &&\n        typeof object === 'object' &&\n        object instanceof McpCallableTool);\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient, maxTools = 100) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while (numTools < maxTools) {\n            const t = yield __await(mcpClient.listTools({ cursor }));\n            for (const tool of t.tools) {\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nclass McpCallableTool {\n    constructor(mcpClients = [], config) {\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */\n    static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */\n    async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients) {\n            try {\n                for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls) {\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout,\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args,\n                }, \n                // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError\n                            ? { error: callToolResponse }\n                            : callToolResponse,\n                    },\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return (client !== null &&\n        typeof client === 'object' &&\n        'listTools' in client &&\n        typeof client.listTools === 'function');\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nfunction mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error('No MCP clients provided');\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    }\n    else {\n        data = JSON.parse(event.data);\n    }\n    Object.assign(serverMessage, data);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */\nclass LiveMusic {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Live music is not supported for Vertex AI.');\n        }\n        console.warn('Live music generation is experimental and may change in future versions.');\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = { model };\n        const clientMessage = { setup };\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass LiveMusicSession {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */\n    async setWeightedPrompts(params) {\n        if (!params.weightedPrompts ||\n            Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error('Weighted prompts must be set and contain at least one entry.');\n        }\n        const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);\n        this.conn.send(JSON.stringify({ clientContent }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */\n    async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        this.conn.send(JSON.stringify(setConfigParameters));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = { playbackControl };\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */\n    play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */\n    pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */\n    stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */\n    resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst FUNCTION_RESPONSE_REQUIRES_ID = 'FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.';\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    }\n    else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    }\n    else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    }\n    else {\n        const resp = data;\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */\nclass Live {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error('The Live module does not support httpOptions at request-level in' +\n                ' LiveConnectConfig yet. Please use the client-level httpOptions' +\n                ' configuration instead.');\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers, url);\n        }\n        else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = 'BidiGenerateContent';\n            let keyName = 'key';\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith('auth_tokens/')) {\n                console.warn('Warning: Ephemeral token support is experimental and may change in future versions.');\n                if (apiVersion !== 'v1alpha') {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = 'BidiGenerateContentConstrained';\n                keyName = 'access_token';\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() &&\n            transformedModel.startsWith('publishers/')) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel =\n                `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() &&\n            ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = { responseModalities: [Modality.AUDIO] };\n            }\n            else {\n                params.config.responseModalities = [Modality.AUDIO];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn('Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).');\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools) {\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            }\n            else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks,\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        }\n        else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage['config'];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return 'callTool' in tool && typeof tool.callTool === 'function';\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true,\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass Session {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (!apiClient.isVertexAI()) {\n                    contents = contents.map((item) => contentToMldev$1(item));\n                }\n            }\n            catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: { turns: contents, turnComplete: params.turnComplete },\n            };\n        }\n        return {\n            clientContent: { turnComplete: params.turnComplete },\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error('functionResponses is required.');\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [params.functionResponses];\n        }\n        else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error('functionResponses is required.');\n        }\n        for (const functionResponse of functionResponses) {\n            if (typeof functionResponse !== 'object' ||\n                functionResponse === null ||\n                !('name' in functionResponse) ||\n                !('response' in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !('id' in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: { functionResponses: functionResponses },\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */\n    sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */\n    sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToVertex(params),\n            };\n        }\n        else {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToMldev(params),\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */\n    sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error('Tool response parameters are required.');\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */\nfunction shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if ((maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls))) ||\n        maxCalls == 0) {\n        console.warn('Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:', maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return 'callTool' in tool && typeof tool.callTool === 'function';\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n// Checks whether the list of tools contains any non-callable tools. Will return\n// true if there is at least one non-Callable tool.\nfunction hasNonCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => !isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */\nfunction shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Models extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.generateContent = async (params) => {\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            if (hasNonCallableTools(params)) {\n                throw new Error('Automatic function calling with CallableTools and Tools is not yet supported.');\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while (remoteCalls < maxRemoteCalls) {\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: 'user',\n                    parts: functionResponseParts,\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory =\n                    automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */\n        this.generateContentStream = async (params) => {\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            }\n            else {\n                return await this.processAfcStream(params);\n            }\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.generateImages = async (params) => {\n            return await this.generateImagesInternal(params).then((apiResponse) => {\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages) {\n                        if (generatedImage &&\n                            (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) &&\n                            ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === 'Positive Prompt') {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        }\n                        else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params) => {\n            var _a;\n            const defaultConfig = {\n                queryBase: true,\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig,\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error('Filtering tuned models list for Vertex AI is not currently supported');\n                    }\n                    else {\n                        actualParams.config.filter = 'labels.tune-type:*';\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.editImage = async (params) => {\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config,\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.upscaleImage = async (params) => {\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: 'upscale',\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig,\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */\n        this.generateVideos = async (params) => {\n            var _a, _b, _c, _d, _e, _f;\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error('Source and prompt/image/video are mutually exclusive. Please only use source.');\n            }\n            // Gemini API does not support video bytes.\n            if (!this.apiClient.isVertexAI()) {\n                if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {\n                    params.video = {\n                        uri: params.video.uri,\n                        mimeType: params.video.mimeType,\n                    };\n                }\n                else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) &&\n                    ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {\n                    params.source.video = {\n                        uri: params.source.video.uri,\n                        mimeType: params.source.video.mimeType,\n                    };\n                }\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */\n    maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes('$schema')) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */\n    async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool) => {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools }),\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {\n                    if (!declaration.name) {\n                        throw new Error('Function declaration name is required.');\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return (function (models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function* () {\n                var _c, e_1, _d, _e;\n                while (remoteCallCount < maxRemoteCalls) {\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true) {\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []) {\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error('Function call name was not returned by the model.');\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        }\n                                        else {\n                                            const responseParts = yield __await(afcTools\n                                                .get(part.functionCall.name)\n                                                .callTool([part.functionCall]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: 'user',\n                                    parts: functionResponses,\n                                },\n                            },\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: 'user',\n                            parts: functionResponses,\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            });\n        })(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true) {\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                });\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true) {\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */\n    async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchEmbedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */\n    async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */\n    async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */\n    async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-preview-08-04',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */\n    async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */\n    async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:computeTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */\n    async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Operations extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false,\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false,\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap('{resourceName}:fetchPredictOperation', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        'newSessionExpireTime',\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, ['newSessionExpireTime'], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, ['uses']);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, ['uses'], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        'liveConnectConstraints',\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, ['bidiGenerateContentSetup'], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        'lockAdditionalFields',\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, ['fieldMask'], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction googleMapsToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], fromFunctionCall);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev(fromFileData));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev(fromGoogleMaps));\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */\nfunction getFieldMasks(setup) {\n    const fields = [];\n    for (const key in setup) {\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === 'object' &&\n                value != null &&\n                Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk) => `${key}.${kk}`);\n                fields.push(...field);\n            }\n            else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(',');\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */\nfunction convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict['bidiGenerateContentSetup'];\n    if (typeof bidiGenerateContentSetupValue === 'object' &&\n        bidiGenerateContentSetupValue !== null &&\n        'setup' in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue\n            .setup;\n        if (typeof innerSetup === 'object' && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict['bidiGenerateContentSetup'] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        }\n        else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict['bidiGenerateContentSetup'];\n        }\n    }\n    else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict['bidiGenerateContentSetup'];\n    }\n    const preExistingFieldMask = requestDict['fieldMask'];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict['fieldMask'] = generatedMaskFromBidi;\n            }\n            else {\n                delete requestDict['fieldMask']; // If mask is empty, effectively no\n                // specific fields locked by bidi\n            }\n        }\n        else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            config.lockAdditionalFields.length > 0 &&\n            preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                'temperature',\n                'topK',\n                'topP',\n                'maxOutputTokens',\n                'responseModalities',\n                'seed',\n                'speechConfig',\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                    // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict['fieldMask'] = finalMaskParts.join(',');\n            }\n            else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict['fieldMask'];\n            }\n        }\n        else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict['fieldMask'];\n        }\n    }\n    else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict['fieldMask'] = preExistingFieldMask.join(',');\n        }\n        else {\n            delete requestDict['fieldMask'];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */\n    async create(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('The client.tokens.create method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap('auth_tokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['config'];\n            delete body['_url'];\n            delete body['_query'];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GOOGLE_API_KEY_HEADER = 'x-goog-api-key';\nconst REQUIRED_VERTEX_AI_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\nclass NodeAuth {\n    constructor(opts) {\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers, url) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith('auth_tokens/')) {\n                throw new Error('Ephemeral tokens are only supported by the live API.');\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers, url);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error('Trying to set API key header but apiKey is not set');\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers, url) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error('Trying to set google-auth headers but googleAuth is unset');\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders(url);\n        for (const [key, value] of authHeaders) {\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, value);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [REQUIRED_VERTEX_AI_SCOPE],\n        };\n        return authOptions;\n    }\n    else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [REQUIRED_VERTEX_AI_SCOPE];\n            return authOptions;\n        }\n        else if ((typeof authOptions.scopes === 'string' &&\n            authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE) ||\n            (Array.isArray(authOptions.scopes) &&\n                authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0)) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(params.downloadPath);\n                const body = node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable.fromWeb(response.responseInternal.body);\n                body.pipe(writer);\n                await (0,node_stream_promises__WEBPACK_IMPORTED_MODULE_4__.finished)(writer);\n            }\n            else {\n                try {\n                    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile)(params.downloadPath, response, {\n                        encoding: 'base64',\n                    });\n                }\n                catch (error) {\n                    throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                }\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: 'GET',\n            queryParams: {\n                'alt': 'media',\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n        });\n    }\n    else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === 'string') {\n            return videoBytes;\n        }\n        else {\n            throw new Error('Failed to download generated video, Uri or videoBytes not found.');\n        }\n    }\n    else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === 'string') {\n            return videoBytes;\n        }\n        else {\n            throw new Error('Failed to download video, Uri or videoBytes not found.');\n        }\n    }\n    else {\n        throw new Error('Unsupported file type');\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks) {\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_5__.WebSocket(this.url, { headers: this.headers });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.close();\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['validationDataset']) !== undefined) {\n        throw new Error('validationDataset parameter is not supported in Gemini API.');\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, ['description']) !== undefined) {\n        throw new Error('description parameter is not supported in Gemini API.');\n    }\n    const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'epochCount'], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        'learningRateMultiplier',\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, ['tuningTask', 'hyperparameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, ['exportLastCheckpointOnly']) !==\n        undefined) {\n        throw new Error('exportLastCheckpointOnly parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['preTunedModelCheckpointId']) !==\n        undefined) {\n        throw new Error('preTunedModelCheckpointId parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['adapterSize']) !== undefined) {\n        throw new Error('adapterSize parameter is not supported in Gemini API.');\n    }\n    const fromBatchSize = getValueByPath(fromObject, ['batchSize']);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'batchSize'], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, ['learningRate']);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'learningRate'], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['beta']) !== undefined) {\n        throw new Error('beta parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorValidationDataset = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorValidationDataset === undefined) {\n        discriminatorValidationDataset = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorValidationDataset === 'SUPERVISED_FINE_TUNING') {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            'validationDataset',\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec'], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    else if (discriminatorValidationDataset === 'PREFERENCE_TUNING') {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            'validationDataset',\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec'], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    let discriminatorEpochCount = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorEpochCount === undefined) {\n        discriminatorEpochCount = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorEpochCount === 'SUPERVISED_FINE_TUNING') {\n        const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n        }\n    }\n    else if (discriminatorEpochCount === 'PREFERENCE_TUNING') {\n        const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n        }\n    }\n    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorLearningRateMultiplier === undefined) {\n        discriminatorLearningRateMultiplier = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorLearningRateMultiplier === 'SUPERVISED_FINE_TUNING') {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            'learningRateMultiplier',\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n        }\n    }\n    else if (discriminatorLearningRateMultiplier === 'PREFERENCE_TUNING') {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            'learningRateMultiplier',\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                'preferenceOptimizationSpec',\n                'hyperParameters',\n                'learningRateMultiplier',\n            ], fromLearningRateMultiplier);\n        }\n    }\n    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ['config', 'method']);\n    if (discriminatorExportLastCheckpointOnly === undefined) {\n        discriminatorExportLastCheckpointOnly = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorExportLastCheckpointOnly === 'SUPERVISED_FINE_TUNING') {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            'exportLastCheckpointOnly',\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n        }\n    }\n    else if (discriminatorExportLastCheckpointOnly === 'PREFERENCE_TUNING') {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            'exportLastCheckpointOnly',\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n        }\n    }\n    let discriminatorAdapterSize = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorAdapterSize === undefined) {\n        discriminatorAdapterSize = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorAdapterSize === 'SUPERVISED_FINE_TUNING') {\n        const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n        }\n    }\n    else if (discriminatorAdapterSize === 'PREFERENCE_TUNING') {\n        const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n        }\n    }\n    if (getValueByPath(fromObject, ['batchSize']) !== undefined) {\n        throw new Error('batchSize parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['learningRate']) !== undefined) {\n        throw new Error('learningRate parameter is not supported in Vertex AI.');\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromBeta = getValueByPath(fromObject, ['beta']);\n    if (parentObject !== undefined && fromBeta != null) {\n        setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'beta'], fromBeta);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToMldev(fromTrainingDataset);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tunedModels']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tuningJobs']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['name']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, ['name']);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, ['endpoint'], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['vertexDatasetResource']) !== undefined) {\n        throw new Error('vertexDatasetResource parameter is not supported in Gemini API.');\n    }\n    const fromExamples = getValueByPath(fromObject, ['examples']);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['examples', 'examples'], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorGcsUri = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorGcsUri === undefined) {\n        discriminatorGcsUri = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorGcsUri === 'SUPERVISED_FINE_TUNING') {\n        const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromGcsUri);\n        }\n    }\n    else if (discriminatorGcsUri === 'PREFERENCE_TUNING') {\n        const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'trainingDatasetUri'], fromGcsUri);\n        }\n    }\n    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorVertexDatasetResource === undefined) {\n        discriminatorVertexDatasetResource = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorVertexDatasetResource === 'SUPERVISED_FINE_TUNING') {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            'vertexDatasetResource',\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n        }\n    }\n    else if (discriminatorVertexDatasetResource === 'PREFERENCE_TUNING') {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            'vertexDatasetResource',\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n        }\n    }\n    if (getValueByPath(fromObject, ['examples']) !== undefined) {\n        throw new Error('examples parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'startTime',\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'completeTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], tunedModelFromMldev(fromTunedModel));\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['tunedModel']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], fromTunedModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        'supervisedTuningSpec',\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, ['supervisedTuningSpec'], fromSupervisedTuningSpec);\n    }\n    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [\n        'preferenceOptimizationSpec',\n    ]);\n    if (fromPreferenceOptimizationSpec != null) {\n        setValueByPath(toObject, ['preferenceOptimizationSpec'], fromPreferenceOptimizationSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        'tuningDataStats',\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, ['tuningDataStats'], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        'encryptionSpec',\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, ['encryptionSpec'], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        'partnerModelTuningSpec',\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, ['partnerModelTuningSpec'], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        'customBaseModel',\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, ['customBaseModel'], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, ['experiment']);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, ['experiment'], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, ['outputUri']);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, ['outputUri'], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, ['pipelineJob']);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, ['pipelineJob'], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        'serviceAccount',\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, ['serviceAccount'], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        'veoTuningSpec',\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, ['veoTuningSpec'], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['validationDatasetUri'], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        'vertexDatasetResource',\n    ]);\n    if (fromVertexDatasetResource != null) {\n        setValueByPath(toObject, ['validationDatasetUri'], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Tunings extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.get = async (params) => {\n            return await this.getInternal(params);\n        };\n        /**\n         * Lists tuning jobs.\n         *\n         * @param config - The configuration for the list request.\n         * @return - A list of tuning jobs.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.tune = async (params) => {\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith('projects/')) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel,\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel: preTunedModel });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                }\n                else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            }\n            else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = '';\n                if (operation['metadata'] !== undefined &&\n                    operation['metadata']['tunedModel'] !== undefined) {\n                    tunedModelName = operation['metadata']['tunedModel'];\n                }\n                else if (operation['name'] !== undefined &&\n                    operation['name'].includes('/operations/')) {\n                    tunedModelName = operation['name'].split('/operations/')[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED,\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n        else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params, params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = 'x-goog-upload-status';\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a, _b, _c;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = 'upload';\n    fileSize = file.size;\n    while (offset < fileSize) {\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += ', finalize';\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while (retryCount < MAX_RETRY_COUNT) {\n            response = await apiClient.request({\n                path: '',\n                body: chunk,\n                httpMethod: 'POST',\n                httpOptions: {\n                    apiVersion: '',\n                    baseUrl: uploadUrl,\n                    headers: {\n                        'X-Goog-Upload-Command': uploadCommand,\n                        'X-Goog-Upload-Offset': String(offset),\n                        'Content-Length': String(chunkSize),\n                    },\n                },\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'active') {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error('All content has been uploaded, but the upload status is not finalized.');\n        }\n    }\n    const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n    if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n        throw new Error('Failed to upload file: Upload status is not finalized.');\n    }\n    return responseJson['file'];\n}\nasync function getBlobStat(file) {\n    const fileStat = { size: file.size, type: file.type };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeUploader {\n    async stat(file) {\n        const fileStat = { size: 0, type: undefined };\n        if (typeof file === 'string') {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        }\n        else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === 'string') {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        }\n        else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */\n    inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf('.') + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            'aac': 'audio/aac',\n            'abw': 'application/x-abiword',\n            'arc': 'application/x-freearc',\n            'avi': 'video/x-msvideo',\n            'azw': 'application/vnd.amazon.ebook',\n            'bin': 'application/octet-stream',\n            'bmp': 'image/bmp',\n            'bz': 'application/x-bzip',\n            'bz2': 'application/x-bzip2',\n            'csh': 'application/x-csh',\n            'css': 'text/css',\n            'csv': 'text/csv',\n            'doc': 'application/msword',\n            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'eot': 'application/vnd.ms-fontobject',\n            'epub': 'application/epub+zip',\n            'gz': 'application/gzip',\n            'gif': 'image/gif',\n            'htm': 'text/html',\n            'html': 'text/html',\n            'ico': 'image/vnd.microsoft.icon',\n            'ics': 'text/calendar',\n            'jar': 'application/java-archive',\n            'jpeg': 'image/jpeg',\n            'jpg': 'image/jpeg',\n            'js': 'text/javascript',\n            'json': 'application/json',\n            'jsonld': 'application/ld+json',\n            'kml': 'application/vnd.google-earth.kml+xml',\n            'kmz': 'application/vnd.google-earth.kmz+xml',\n            'mjs': 'text/javascript',\n            'mp3': 'audio/mpeg',\n            'mp4': 'video/mp4',\n            'mpeg': 'video/mpeg',\n            'mpkg': 'application/vnd.apple.installer+xml',\n            'odt': 'application/vnd.oasis.opendocument.text',\n            'oga': 'audio/ogg',\n            'ogv': 'video/ogg',\n            'ogx': 'application/ogg',\n            'opus': 'audio/opus',\n            'otf': 'font/otf',\n            'png': 'image/png',\n            'pdf': 'application/pdf',\n            'php': 'application/x-httpd-php',\n            'ppt': 'application/vnd.ms-powerpoint',\n            'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'rar': 'application/vnd.rar',\n            'rtf': 'application/rtf',\n            'sh': 'application/x-sh',\n            'svg': 'image/svg+xml',\n            'swf': 'application/x-shockwave-flash',\n            'tar': 'application/x-tar',\n            'tif': 'image/tiff',\n            'tiff': 'image/tiff',\n            'ts': 'video/mp2t',\n            'ttf': 'font/ttf',\n            'txt': 'text/plain',\n            'vsd': 'application/vnd.visio',\n            'wav': 'audio/wav',\n            'weba': 'audio/webm',\n            'webm': 'video/webm',\n            'webp': 'image/webp',\n            'woff': 'font/woff',\n            'woff2': 'font/woff2',\n            'xhtml': 'application/xhtml+xml',\n            'xls': 'application/vnd.ms-excel',\n            'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xml': 'application/xml',\n            'xul': 'application/vnd.mozilla.xul+xml',\n            'zip': 'application/zip',\n            '3gp': 'video/3gpp',\n            '3g2': 'video/3gpp2',\n            '7z': 'application/x-7z-compressed',\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a, _b, _c;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = 'upload';\n        let fileHandle;\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.open(file, 'r');\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while (offset < fileSize) {\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += ', finalize';\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([buffer]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while (retryCount < MAX_RETRY_COUNT) {\n                    response = await apiClient.request({\n                        path: '',\n                        body: chunk,\n                        httpMethod: 'POST',\n                        httpOptions: {\n                            apiVersion: '',\n                            baseUrl: uploadUrl,\n                            headers: {\n                                'X-Goog-Upload-Command': uploadCommand,\n                                'X-Goog-Upload-Offset': String(offset),\n                                'Content-Length': String(bytesRead),\n                            },\n                        },\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'active') {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error('All content has been uploaded, but the upload status is not finalized.');\n                }\n            }\n            const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n            if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n                throw new Error('Failed to upload file: Upload status is not finalized.');\n            }\n            return responseJson['file'];\n        }\n        finally {\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst LANGUAGE_LABEL_PREFIX = 'gl-node/';\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */\nclass GoogleGenAI {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error('Project/location and API key are mutually exclusive in the client initializer.');\n        }\n        this.vertexai =\n            (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv('GOOGLE_GENAI_USE_VERTEXAI')) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv('GOOGLE_CLOUD_PROJECT');\n        const envLocation = getEnv('GOOGLE_CLOUD_LOCATION');\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug('The user provided Google Cloud credentials will take precedence' +\n                    ' over the API key from the environment variable.');\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug('The user provided Vertex AI API key will take precedence over' +\n                    ' the project/location from the environment variables.');\n                this.project = undefined;\n                this.location = undefined;\n            }\n            else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug('The user provided project/location will take precedence over' +\n                    ' the API key from the environment variables.');\n                this.apiKey = undefined;\n            }\n            else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug('The project/location from the environment variables will take' +\n                    ' precedence over the API key from the environment variables.');\n                this.apiKey = undefined;\n            }\n            if (!this.location && !this.apiKey) {\n                this.location = 'global';\n            }\n        }\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv('GOOGLE_VERTEX_BASE_URL'), getEnv('GOOGLE_GEMINI_BASE_URL'));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            }\n            else {\n                options.httpOptions = { baseUrl: baseUrl };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions,\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: options.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader(),\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === 'true';\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv('GOOGLE_API_KEY');\n    const envGeminiApiKey = getEnv('GEMINI_API_KEY');\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn('Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.');\n    }\n    return envGoogleApiKey || envGeminiApiKey || undefined;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDVjtBQUNMO0FBQ007QUFDRDtBQUNTO0FBQ25COztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQTZDO0FBQ3BFO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCLFdBQVc7QUFDbEY7QUFDQTtBQUNBLGdGQUFnRixJQUFJO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxjQUFjLGNBQWMsR0FBRyxjQUFjLEVBQUU7QUFDdkQsUUFBUTtBQUNSO0FBQ0EsV0FBVyxjQUFjLFlBQVksZUFBZSxHQUFHLFlBQVksZUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3Q0FBd0MseUJBQXlCLE9BQU87QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBd0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsVUFBVSxTQUFTO0FBQzdEO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QixhQUFhLHdCQUF3QixHQUFHLGlCQUFpQjtBQUMzRztBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QixhQUFhLHdCQUF3QixxQkFBcUIsaUJBQWlCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtDQUErQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHLFNBQVMsZUFBZSxHQUFHLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVMsYUFBYSxHQUFHLGVBQWUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGVBQWU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQixHQUFHLGFBQWE7QUFDbkU7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRCwrQkFBK0Isb0JBQW9CLGFBQWEscUJBQXFCLEdBQUcsYUFBYTtBQUNyRztBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQixhQUFhLHFCQUFxQixHQUFHLGVBQWUsR0FBRyxhQUFhO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlLEdBQUcsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRFQUE0RSxJQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQSw2RUFBNkUsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdLQUFnSztBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTLGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUEwRDtBQUM3RTtBQUNBLHNCQUFzQiw2REFBNkQ7QUFDbkY7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsZUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sUUFBUSxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLFFBQVEsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWSxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUyxlQUFlO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME1BQTBNLGNBQWM7QUFDeE4sOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxnR0FBZ0c7QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUyxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVyw4RkFBOEY7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkIsYUFBYSw0QkFBNEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsa0JBQWtCLG9CQUFvQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBFQUEwRSxrQkFBa0Isb0JBQW9CO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxPQUFPLElBQUksMEJBQTBCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUscUJBQXFCLElBQUksRUFBRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1SkFBdUosZUFBZSwyQ0FBMkMsY0FBYyxHQUFHLGdCQUFnQixzQ0FBc0MsSUFBSTtBQUNyVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csSUFBSSxvQkFBb0IsbUJBQW1CLGNBQWMsbUJBQW1CO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcseUNBQXlDO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQixtQ0FBbUMsV0FBVywyQ0FBMkMsT0FBTztBQUN4STtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCLDhCQUE4QixXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxtQ0FBbUMsd0JBQXdCLEdBQUc7QUFDdE07QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCLG1DQUFtQyxXQUFXLHFCQUFxQixPQUFPLEdBQUcsUUFBUSxHQUFHLE9BQU87QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxhQUFhLFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLG9CQUFvQjtBQUN0RztBQUNBO0FBQ0EsaUNBQWlDLG9EQUFvRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx3QkFBd0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQix5QkFBeUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdDQUFnQyxxQkFBcUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsOEVBQThFO0FBQzlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFNQUFxTSxnQkFBZ0IsaUJBQWlCLHVCQUF1QjtBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsdUZBQXVGO0FBQ2hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHVGQUF1RjtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJLEdBQUcsR0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHlCQUF5QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBaUI7QUFDaEQsNkJBQTZCLGlEQUFRO0FBQ3JDO0FBQ0Esc0JBQXNCLDhEQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBUztBQUNuQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsK0RBQStELG9CQUFvQixJQUFJLE1BQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQWdCLGFBQWEsdUJBQXVCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhLDhCQUE4QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1Q0FBdUMsNkNBQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLHNEQUFzRCxXQUFXLDRCQUE0QixPQUFPLHlCQUF5QixVQUFVO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Qsd0VBQXdFO0FBQ3hFLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxRQUFRLG1DQUFtQztBQUMzQztBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQztBQUNsRSxvQ0FBb0Msa0NBQWtDLEtBQUs7QUFDM0UsZ0NBQWdDLG1CQUFtQjtBQUNuRCw4QkFBOEI7QUFDOUI7QUFDQSxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QiwrQkFBK0IseUJBQXlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzckU7QUFDdHJFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vMDM5LWdlbWluaS1hcGktZGVtby8uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dlbmFpL2Rpc3Qvbm9kZS9pbmRleC5tanM/YWI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHb29nbGVBdXRoIH0gZnJvbSAnZ29vZ2xlLWF1dGgtbGlicmFyeSc7XG5pbXBvcnQgeyBjcmVhdGVXcml0ZVN0cmVhbSB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzL3Byb21pc2VzJztcbmltcG9ydCB7IHdyaXRlRmlsZSB9IGZyb20gJ2ZzL3Byb21pc2VzJztcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHsgZmluaXNoZWQgfSBmcm9tICdub2RlOnN0cmVhbS9wcm9taXNlcyc7XG5pbXBvcnQgKiBhcyBOb2RlV3MgZnJvbSAnd3MnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5sZXQgX2RlZmF1bHRCYXNlR2VtaW5pVXJsID0gdW5kZWZpbmVkO1xubGV0IF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IHVuZGVmaW5lZDtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6aW5nIHRoZSBTREsuIElmIHRoZVxuICogYmFzZSBVUkxzIGFyZSBzZXQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBTREssIHRoZSBiYXNlIFVSTHMgd2lsbCBub3QgYmVcbiAqIHVwZGF0ZWQuIEJhc2UgVVJMcyBwcm92aWRlZCBpbiB0aGUgSHR0cE9wdGlvbnMgd2lsbCBhbHNvIHRha2UgcHJlY2VkZW5jZSBvdmVyXG4gKiBVUkxzIHNldCBoZXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSSwgc2V0RGVmYXVsdEJhc2VVcmxzfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIC8vIE92ZXJyaWRlIHRoZSBiYXNlIFVSTCBmb3IgdGhlIEdlbWluaSBBUEkuXG4gKiBzZXREZWZhdWx0QmFzZVVybHMoe2dlbWluaVVybDonaHR0cHM6Ly9nZW1pbmkuZ29vZ2xlLmNvbSd9KTtcbiAqXG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBWZXJ0ZXggQUkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHt2ZXJ0ZXhVcmw6ICdodHRwczovL3ZlcnRleGFpLmdvb2dsZWFwaXMuY29tJ30pO1xuICpcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0QmFzZVVybHMoYmFzZVVybFBhcmFtcykge1xuICAgIF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IGJhc2VVcmxQYXJhbXMuZ2VtaW5pVXJsO1xuICAgIF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IGJhc2VVcmxQYXJhbXMudmVydGV4VXJsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJhc2UgVVJMcyBmb3IgdGhlIEdlbWluaSBBUEkgYW5kIFZlcnRleCBBSSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRCYXNlVXJscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW1pbmlVcmw6IF9kZWZhdWx0QmFzZUdlbWluaVVybCxcbiAgICAgICAgdmVydGV4VXJsOiBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHByaW9yaXR5OlxuICogICAxLiBCYXNlIFVSTHMgc2V0IHZpYSBIdHRwT3B0aW9ucy5cbiAqICAgMi4gQmFzZSBVUkxzIHNldCB2aWEgdGhlIGxhdGVzdCBjYWxsIHRvIHNldERlZmF1bHRCYXNlVXJscy5cbiAqICAgMy4gQmFzZSBVUkxzIHNldCB2aWEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5mdW5jdGlvbiBnZXRCYXNlVXJsKGh0dHBPcHRpb25zLCB2ZXJ0ZXhhaSwgdmVydGV4QmFzZVVybEZyb21FbnYsIGdlbWluaUJhc2VVcmxGcm9tRW52KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIShodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMuYmFzZVVybCkpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhc2VVcmxzID0gZ2V0RGVmYXVsdEJhc2VVcmxzKCk7XG4gICAgICAgIGlmICh2ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IGRlZmF1bHRCYXNlVXJscy52ZXJ0ZXhVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZlcnRleEJhc2VVcmxGcm9tRW52O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IGRlZmF1bHRCYXNlVXJscy5nZW1pbmlVcmwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGdlbWluaUJhc2VVcmxGcm9tRW52O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodHRwT3B0aW9ucy5iYXNlVXJsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXNlTW9kdWxlIHtcbn1cbmZ1bmN0aW9uIGZvcm1hdE1hcCh0ZW1wbGF0ZVN0cmluZywgdmFsdWVNYXApIHtcbiAgICAvLyBVc2UgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmluZCBhbGwgcGxhY2Vob2xkZXJzIGluIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgICBjb25zdCByZWdleCA9IC9cXHsoW159XSspXFx9L2c7XG4gICAgLy8gUmVwbGFjZSBlYWNoIHBsYWNlaG9sZGVyIHdpdGggaXRzIGNvcnJlc3BvbmRpbmcgdmFsdWUgZnJvbSB0aGUgdmFsdWVNYXBcbiAgICByZXR1cm4gdGVtcGxhdGVTdHJpbmcucmVwbGFjZShyZWdleCwgKG1hdGNoLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZU1hcCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZU1hcFtrZXldO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcgaWYgaXQncyBub3QgYSBzdHJpbmcgYWxyZWFkeVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgPyBTdHJpbmcodmFsdWUpIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbWlzc2luZyBrZXlzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAnJHtrZXl9JyBub3QgZm91bmQgaW4gdmFsdWVNYXAuYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXlOYW1lXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHZhbHVlLmxlbmd0aCB9LCAoKSA9PiAoe30pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgbXVzdCBiZSBhIGxpc3QgZ2l2ZW4gYW4gYXJyYXkgcGF0aCAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleU5hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXlEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGFycmF5RGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGVudHJ5LCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWVbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgYXJyYXlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChkLCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleS5lbmRzV2l0aCgnWzBdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgaWYgKCEoa2V5TmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBbe31dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGFycmF5RGF0YVswXSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFba2V5XSB8fCB0eXBlb2YgZGF0YVtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0YVtrZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICB9XG4gICAgY29uc3Qga2V5VG9TZXQgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZXhpc3RpbmdEYXRhID0gZGF0YVtrZXlUb1NldF07XG4gICAgaWYgKGV4aXN0aW5nRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBleGlzdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nRGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGV4aXN0aW5nRGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXhpc3RpbmdEYXRhLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGtleS4gS2V5OiAke2tleVRvU2V0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoa2V5VG9TZXQgPT09ICdfc2VsZicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQXNSZWNvcmQgPSB2YWx1ZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdmFsdWVBc1JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2tleVRvU2V0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWVCeVBhdGgoZGF0YSwga2V5cywgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdfc2VsZicpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlEYXRhLm1hcCgoZCkgPT4gZ2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSksIGRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogTW92ZXMgdmFsdWVzIGZyb20gc291cmNlIHBhdGhzIHRvIGRlc3RpbmF0aW9uIHBhdGhzLlxuICpcbiAqIEV4YW1wbGVzOlxuICogICBtb3ZlVmFsdWVCeVBhdGgoXG4gKiAgICAgeydyZXF1ZXN0cyc6IFt7J2NvbnRlbnQnOiB2MX0sIHsnY29udGVudCc6IHYyfV19LFxuICogICAgIHsncmVxdWVzdHNbXS4qJzogJ3JlcXVlc3RzW10ucmVxdWVzdC4qJ31cbiAqICAgKVxuICogICAgIC0+IHsncmVxdWVzdHMnOiBbeydyZXF1ZXN0Jzogeydjb250ZW50JzogdjF9fSwgeydyZXF1ZXN0Jzogeydjb250ZW50JzogdjJ9fV19XG4gKi9cbmZ1bmN0aW9uIG1vdmVWYWx1ZUJ5UGF0aChkYXRhLCBwYXRocykge1xuICAgIGZvciAoY29uc3QgW3NvdXJjZVBhdGgsIGRlc3RQYXRoXSBvZiBPYmplY3QuZW50cmllcyhwYXRocykpIHtcbiAgICAgICAgY29uc3Qgc291cmNlS2V5cyA9IHNvdXJjZVBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgZGVzdEtleXMgPSBkZXN0UGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAvLyBEZXRlcm1pbmUga2V5cyB0byBleGNsdWRlIGZyb20gd2lsZGNhcmQgdG8gYXZvaWQgY3ljbGljIHJlZmVyZW5jZXNcbiAgICAgICAgY29uc3QgZXhjbHVkZUtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCB3aWxkY2FyZElkeCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VLZXlzW2ldID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICB3aWxkY2FyZElkeCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbGRjYXJkSWR4ICE9PSAtMSAmJiBkZXN0S2V5cy5sZW5ndGggPiB3aWxkY2FyZElkeCkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgaW50ZXJtZWRpYXRlIGtleSBiZXR3ZWVuIHNvdXJjZSBhbmQgZGVzdCBwYXRoc1xuICAgICAgICAgICAgLy8gRXhhbXBsZTogc291cmNlPVsncmVxdWVzdHNbXScsICcqJ10sIGRlc3Q9WydyZXF1ZXN0c1tdJywgJ3JlcXVlc3QnLCAnKiddXG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGV4Y2x1ZGUgJ3JlcXVlc3QnXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gd2lsZGNhcmRJZHg7IGkgPCBkZXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGRlc3RLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICcqJyAmJiAha2V5LmVuZHNXaXRoKCdbXScpICYmICFrZXkuZW5kc1dpdGgoJ1swXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGRhdGEsIHNvdXJjZUtleXMsIGRlc3RLZXlzLCAwLCBleGNsdWRlS2V5cyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBtb3ZlcyB2YWx1ZXMgZnJvbSBzb3VyY2UgcGF0aCB0byBkZXN0aW5hdGlvbiBwYXRoLlxuICovXG5mdW5jdGlvbiBfbW92ZVZhbHVlUmVjdXJzaXZlKGRhdGEsIHNvdXJjZUtleXMsIGRlc3RLZXlzLCBrZXlJZHgsIGV4Y2x1ZGVLZXlzKSB7XG4gICAgaWYgKGtleUlkeCA+PSBzb3VyY2VLZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHNvdXJjZUtleXNba2V5SWR4XTtcbiAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgaWYgKGtleU5hbWUgaW4gZGF0YVJlY29yZCAmJiBBcnJheS5pc0FycmF5KGRhdGFSZWNvcmRba2V5TmFtZV0pKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YVJlY29yZFtrZXlOYW1lXSkge1xuICAgICAgICAgICAgICAgIF9tb3ZlVmFsdWVSZWN1cnNpdmUoaXRlbSwgc291cmNlS2V5cywgZGVzdEtleXMsIGtleUlkeCArIDEsIGV4Y2x1ZGVLZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09ICcqJykge1xuICAgICAgICAvLyB3aWxkY2FyZCAtIG1vdmUgYWxsIGZpZWxkc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFSZWNvcmQgPSBkYXRhO1xuICAgICAgICAgICAgY29uc3Qga2V5c1RvTW92ZSA9IE9iamVjdC5rZXlzKGRhdGFSZWNvcmQpLmZpbHRlcigoaykgPT4gIWsuc3RhcnRzV2l0aCgnXycpICYmICFleGNsdWRlS2V5cy5oYXMoaykpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzVG9Nb3ZlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5c1RvTW92ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1RvTW92ZVtrXSA9IGRhdGFSZWNvcmRba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdmFsdWVzIGF0IGRlc3RpbmF0aW9uXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXNUb01vdmUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGVzdEtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRrIG9mIGRlc3RLZXlzLnNsaWNlKGtleUlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRrID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Rlc3RLZXlzLnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEZXN0S2V5cy5wdXNoKGRrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChkYXRhUmVjb3JkLCBuZXdEZXN0S2V5cywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5c1RvTW92ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhUmVjb3JkW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBOYXZpZ2F0ZSB0byBuZXh0IGxldmVsXG4gICAgICAgIGNvbnN0IGRhdGFSZWNvcmQgPSBkYXRhO1xuICAgICAgICBpZiAoa2V5IGluIGRhdGFSZWNvcmQpIHtcbiAgICAgICAgICAgIF9tb3ZlVmFsdWVSZWN1cnNpdmUoZGF0YVJlY29yZFtrZXldLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywga2V5SWR4ICsgMSwgZXhjbHVkZUtleXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB0Qnl0ZXMkMShmcm9tQnl0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGZyb21CeXRlcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tSW1hZ2VCeXRlcyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIC8vIFRPRE8oYi8zODkxMzM5MTQpOiBSZW1vdmUgZHVtbXkgYnl0ZXMgY29udmVydGVyLlxuICAgIHJldHVybiBmcm9tQnl0ZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc291cmNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb3VyY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tUmVzb3VyY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdyZXNvdXJjZU5hbWUnXSwgZnJvbVJlc291cmNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZWRTYW1wbGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb3MnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbU1sZGV2JDEoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbVZlcnRleCQxKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RlZFZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzJDEoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmNvZGluZyddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMkMShmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKiBPdXRjb21lIG9mIHRoZSBjb2RlIGV4ZWN1dGlvbi4gKi9cbnZhciBPdXRjb21lO1xuKGZ1bmN0aW9uIChPdXRjb21lKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgc3RhdHVzLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9VTlNQRUNJRklFRFwiXSA9IFwiT1VUQ09NRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfT0tcIl0gPSBcIk9VVENPTUVfT0tcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiBmaW5pc2hlZCBidXQgd2l0aCBhIGZhaWx1cmUuIGBzdGRlcnJgIHNob3VsZCBjb250YWluIHRoZSByZWFzb24uXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfRkFJTEVEXCJdID0gXCJPVVRDT01FX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIHJhbiBmb3IgdG9vIGxvbmcsIGFuZCB3YXMgY2FuY2VsbGVkLiBUaGVyZSBtYXkgb3IgbWF5IG5vdCBiZSBhIHBhcnRpYWwgb3V0cHV0IHByZXNlbnQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIl0gPSBcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIjtcbn0pKE91dGNvbWUgfHwgKE91dGNvbWUgPSB7fSkpO1xuLyoqIFByb2dyYW1taW5nIGxhbmd1YWdlIG9mIHRoZSBgY29kZWAuICovXG52YXIgTGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKExhbmd1YWdlKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgbGFuZ3VhZ2UuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIExhbmd1YWdlW1wiTEFOR1VBR0VfVU5TUEVDSUZJRURcIl0gPSBcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUHl0aG9uID49IDMuMTAsIHdpdGggbnVtcHkgYW5kIHNpbXB5IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIlBZVEhPTlwiXSA9IFwiUFlUSE9OXCI7XG59KShMYW5ndWFnZSB8fCAoTGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIFNwZWNpZmllcyBob3cgdGhlIHJlc3BvbnNlIHNob3VsZCBiZSBzY2hlZHVsZWQgaW4gdGhlIGNvbnZlcnNhdGlvbi4gKi9cbnZhciBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZztcbihmdW5jdGlvbiAoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIlNDSEVEVUxJTkdfVU5TUEVDSUZJRURcIl0gPSBcIlNDSEVEVUxJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBPbmx5IGFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgZG8gbm90IGludGVycnVwdCBvciB0cmlnZ2VyIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJTSUxFTlRcIl0gPSBcIlNJTEVOVFwiO1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgYW5kIHByb21wdCB0byBnZW5lcmF0ZSBvdXRwdXQgd2l0aG91dCBpbnRlcnJ1cHRpbmcgb25nb2luZyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiV0hFTl9JRExFXCJdID0gXCJXSEVOX0lETEVcIjtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGludGVycnVwdCBvbmdvaW5nIGdlbmVyYXRpb24gYW5kIHByb21wdCB0byBnZW5lcmF0ZSBvdXRwdXQuXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJJTlRFUlJVUFRcIl0gPSBcIklOVEVSUlVQVFwiO1xufSkoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcgfHwgKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nID0ge30pKTtcbi8qKiBUaGUgdHlwZSBvZiB0aGUgZGF0YS4gKi9cbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgLyoqXG4gICAgICogTm90IHNwZWNpZmllZCwgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIFR5cGVbXCJUWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBzdHJpbmcgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJTVFJJTkdcIl0gPSBcIlNUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgbnVtYmVyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiTlVNQkVSXCJdID0gXCJOVU1CRVJcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGludGVnZXIgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJJTlRFR0VSXCJdID0gXCJJTlRFR0VSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBib29sZWFuIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYXJyYXkgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJBUlJBWVwiXSA9IFwiQVJSQVlcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG9iamVjdCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk9CSkVDVFwiXSA9IFwiT0JKRUNUXCI7XG4gICAgLyoqXG4gICAgICogTnVsbCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTExcIl0gPSBcIk5VTExcIjtcbn0pKFR5cGUgfHwgKFR5cGUgPSB7fSkpO1xuLyoqIFRoZSBtb2RlIG9mIHRoZSBwcmVkaWN0b3IgdG8gYmUgdXNlZCBpbiBkeW5hbWljIHJldHJpZXZhbC4gKi9cbnZhciBNb2RlO1xuKGZ1bmN0aW9uIChNb2RlKSB7XG4gICAgLyoqXG4gICAgICogQWx3YXlzIHRyaWdnZXIgcmV0cmlldmFsLlxuICAgICAqL1xuICAgIE1vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUnVuIHJldHJpZXZhbCBvbmx5IHdoZW4gc3lzdGVtIGRlY2lkZXMgaXQgaXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIE1vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoTW9kZSB8fCAoTW9kZSA9IHt9KSk7XG4vKiogVHlwZSBvZiBhdXRoIHNjaGVtZS4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBBdXRoVHlwZTtcbihmdW5jdGlvbiAoQXV0aFR5cGUpIHtcbiAgICBBdXRoVHlwZVtcIkFVVEhfVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiQVVUSF9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTm8gQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk5PX0FVVEhcIl0gPSBcIk5PX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBBUEkgS2V5IEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJBUElfS0VZX0FVVEhcIl0gPSBcIkFQSV9LRVlfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEhUVFAgQmFzaWMgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkhUVFBfQkFTSUNfQVVUSFwiXSA9IFwiSFRUUF9CQVNJQ19BVVRIXCI7XG4gICAgLyoqXG4gICAgICogR29vZ2xlIFNlcnZpY2UgQWNjb3VudCBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9BVVRIXCJdID0gXCJHT09HTEVfU0VSVklDRV9BQ0NPVU5UX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBPQXV0aCBhdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiT0FVVEhcIl0gPSBcIk9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogT3BlbklEIENvbm5lY3QgKE9JREMpIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJPSURDX0FVVEhcIl0gPSBcIk9JRENfQVVUSFwiO1xufSkoQXV0aFR5cGUgfHwgKEF1dGhUeXBlID0ge30pKTtcbi8qKiBUaGUgQVBJIHNwZWMgdGhhdCB0aGUgZXh0ZXJuYWwgQVBJIGltcGxlbWVudHMuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQXBpU3BlYztcbihmdW5jdGlvbiAoQXBpU3BlYykge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIEFQSSBzcGVjLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiQVBJX1NQRUNfVU5TUEVDSUZJRURcIl0gPSBcIkFQSV9TUEVDX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIHNlYXJjaCBBUEkgc3BlYy5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiU0lNUExFX1NFQVJDSFwiXSA9IFwiU0lNUExFX1NFQVJDSFwiO1xuICAgIC8qKlxuICAgICAqIEVsYXN0aWMgc2VhcmNoIEFQSSBzcGVjLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJFTEFTVElDX1NFQVJDSFwiXSA9IFwiRUxBU1RJQ19TRUFSQ0hcIjtcbn0pKEFwaVNwZWMgfHwgKEFwaVNwZWMgPSB7fSkpO1xuLyoqIEhhcm0gY2F0ZWdvcnkuICovXG52YXIgSGFybUNhdGVnb3J5O1xuKGZ1bmN0aW9uIChIYXJtQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaGFyYXNzbWVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhdGUgc3BlZWNoLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBzZXh1YWxseSBleHBsaWNpdCBjb250ZW50LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIl0gPSBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBkYW5nZXJvdXMgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZDogRWxlY3Rpb24gZmlsdGVyIGlzIG5vdCBsb25nZXIgc3VwcG9ydGVkLiBUaGUgaGFybSBjYXRlZ29yeSBpcyBjaXZpYyBpbnRlZ3JpdHkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIl0gPSBcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgaGF0ZS4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBVEVcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFURVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGRhbmdlcm91cyBjb250ZW50LiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfREFOR0VST1VTX0NPTlRFTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfREFOR0VST1VTX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBoYXJhc3NtZW50LiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFSQVNTTUVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVJBU1NNRU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2Ugc2V4dWFsbHkgZXhwbGljaXQgY29udGVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX1NFWFVBTExZX0VYUExJQ0lUXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX1NFWFVBTExZX0VYUExJQ0lUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZm9yIGphaWxicmVhayBwcm9tcHRzLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSkFJTEJSRUFLXCJdID0gXCJIQVJNX0NBVEVHT1JZX0pBSUxCUkVBS1wiO1xufSkoSGFybUNhdGVnb3J5IHx8IChIYXJtQ2F0ZWdvcnkgPSB7fSkpO1xuLyoqIFNwZWNpZnkgaWYgdGhlIHRocmVzaG9sZCBpcyB1c2VkIGZvciBwcm9iYWJpbGl0eSBvciBzZXZlcml0eSBzY29yZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRocmVzaG9sZCBpcyB1c2VkIGZvciBwcm9iYWJpbGl0eSBzY29yZS4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBIYXJtQmxvY2tNZXRob2Q7XG4oZnVuY3Rpb24gKEhhcm1CbG9ja01ldGhvZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJIQVJNX0JMT0NLX01FVEhPRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgdXNlcyBib3RoIHByb2JhYmlsaXR5IGFuZCBzZXZlcml0eSBzY29yZXMuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiU0VWRVJJVFlcIl0gPSBcIlNFVkVSSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIHVzZXMgdGhlIHByb2JhYmlsaXR5IHNjb3JlLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIlBST0JBQklMSVRZXCJdID0gXCJQUk9CQUJJTElUWVwiO1xufSkoSGFybUJsb2NrTWV0aG9kIHx8IChIYXJtQmxvY2tNZXRob2QgPSB7fSkpO1xuLyoqIFRoZSBoYXJtIGJsb2NrIHRocmVzaG9sZC4gKi9cbnZhciBIYXJtQmxvY2tUaHJlc2hvbGQ7XG4oZnVuY3Rpb24gKEhhcm1CbG9ja1RocmVzaG9sZCkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGhhcm0gYmxvY2sgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkhBUk1fQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGxvdyB0aHJlc2hvbGQgYW5kIGFib3ZlIChpLmUuIGJsb2NrIG1vcmUpLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBtZWRpdW0gdGhyZXNob2xkIGFuZCBhYm92ZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgb25seSBoaWdoIHRocmVzaG9sZCAoaS5lLiBibG9jayBsZXNzKS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG5vbmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIFR1cm4gb2ZmIHRoZSBzYWZldHkgZmlsdGVyLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShIYXJtQmxvY2tUaHJlc2hvbGQgfHwgKEhhcm1CbG9ja1RocmVzaG9sZCA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLlxuXG5JZiBlbXB0eSwgdGhlIG1vZGVsIGhhcyBub3Qgc3RvcHBlZCBnZW5lcmF0aW5nIHRoZSB0b2tlbnMuICovXG52YXIgRmluaXNoUmVhc29uO1xuKGZ1bmN0aW9uIChGaW5pc2hSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmluaXNoIHJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIGEgbmF0dXJhbCBzdG9wcGluZyBwb2ludCBvciBhIGNvbmZpZ3VyZWQgc3RvcCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJTVE9QXCJdID0gXCJTVE9QXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIHRoZSBjb25maWd1cmVkIG1heGltdW0gb3V0cHV0IHRva2Vucy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQVhfVE9LRU5TXCJdID0gXCJNQVhfVE9LRU5TXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgcG90ZW50aWFsbHkgY29udGFpbnMgc2FmZXR5IHZpb2xhdGlvbnMuIE5PVEU6IFdoZW4gc3RyZWFtaW5nLCBbY29udGVudF1bXSBpcyBlbXB0eSBpZiBjb250ZW50IGZpbHRlcnMgYmxvY2tzIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgcG90ZW50aWFsIHJlY2l0YXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUkVDSVRBVElPTlwiXSA9IFwiUkVDSVRBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB0b2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBvZiB1c2luZyBhbiB1bnN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJMQU5HVUFHRVwiXSA9IFwiTEFOR1VBR0VcIjtcbiAgICAvKipcbiAgICAgKiBBbGwgb3RoZXIgcmVhc29ucyB0aGF0IHN0b3BwZWQgdGhlIHRva2VuIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgY29udGFpbnMgZm9yYmlkZGVuIHRlcm1zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGZvciBwb3RlbnRpYWxseSBjb250YWluaW5nIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIFNlbnNpdGl2ZSBQZXJzb25hbGx5IElkZW50aWZpYWJsZSBJbmZvcm1hdGlvbiAoU1BJSSkuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1BJSVwiXSA9IFwiU1BJSVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiXSA9IFwiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBnZW5lcmF0ZWQgaW1hZ2VzIGhhdmUgc2FmZXR5IHZpb2xhdGlvbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbCBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJVTkVYUEVDVEVEX1RPT0xfQ0FMTFwiXSA9IFwiVU5FWFBFQ1RFRF9UT09MX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZSBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJJTUFHRV9QUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIklNQUdFX1BST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCB3YXMgZXhwZWN0ZWQgdG8gZ2VuZXJhdGUgYW4gaW1hZ2UsIGJ1dCBub25lIHdhcyBnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTk9fSU1BR0VcIl0gPSBcIk5PX0lNQUdFXCI7XG59KShGaW5pc2hSZWFzb24gfHwgKEZpbmlzaFJlYXNvbiA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEhhcm0gcHJvYmFiaWxpdHkgbGV2ZWxzIGluIHRoZSBjb250ZW50LiAqL1xudmFyIEhhcm1Qcm9iYWJpbGl0eTtcbihmdW5jdGlvbiAoSGFybVByb2JhYmlsaXR5KSB7XG4gICAgLyoqXG4gICAgICogSGFybSBwcm9iYWJpbGl0eSB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJIQVJNX1BST0JBQklMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX1BST0JBQklMSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTmVnbGlnaWJsZSBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk5FR0xJR0lCTEVcIl0gPSBcIk5FR0xJR0lCTEVcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJMT1dcIl0gPSBcIkxPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGl1bSBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk1FRElVTVwiXSA9IFwiTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkhJR0hcIl0gPSBcIkhJR0hcIjtcbn0pKEhhcm1Qcm9iYWJpbGl0eSB8fCAoSGFybVByb2JhYmlsaXR5ID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBzZXZlcml0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgSGFybVNldmVyaXR5O1xuKGZ1bmN0aW9uIChIYXJtU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBIYXJtIHNldmVyaXR5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBOZWdsaWdpYmxlIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCJdID0gXCJIQVJNX1NFVkVSSVRZX05FR0xJR0lCTEVcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX0xPV1wiXSA9IFwiSEFSTV9TRVZFUklUWV9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpdW0gbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX01FRElVTVwiXSA9IFwiSEFSTV9TRVZFUklUWV9NRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9ISUdIXCJdID0gXCJIQVJNX1NFVkVSSVRZX0hJR0hcIjtcbn0pKEhhcm1TZXZlcml0eSB8fCAoSGFybVNldmVyaXR5ID0ge30pKTtcbi8qKiBTdGF0dXMgb2YgdGhlIHVybCByZXRyaWV2YWwuICovXG52YXIgVXJsUmV0cmlldmFsU3RhdHVzO1xuKGZ1bmN0aW9uIChVcmxSZXRyaWV2YWxTdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNQRUNJRklFRFwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfU1VDQ0VTU1wiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfU1VDQ0VTU1wiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGR1ZSB0byBlcnJvci5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19FUlJPUlwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfRVJST1JcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBiZWNhdXNlIHRoZSBjb250ZW50IGlzIGJlaGluZCBwYXl3YWxsLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgaXMgdW5zYWZlLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TQUZFXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNBRkVcIjtcbn0pKFVybFJldHJpZXZhbFN0YXR1cyB8fCAoVXJsUmV0cmlldmFsU3RhdHVzID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gVGhlIHJlYXNvbiB3aHkgdGhlIHByb21wdCB3YXMgYmxvY2tlZC4gKi9cbnZhciBCbG9ja2VkUmVhc29uO1xuKGZ1bmN0aW9uIChCbG9ja2VkUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NrZWQgcmVhc29uIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGZvciBzYWZldHkgcmVhc29ucy5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGZvciBvdGhlciByZWFzb25zLiBGb3IgZXhhbXBsZSwgaXQgbWF5IGJlIGR1ZSB0byB0aGUgcHJvbXB0J3MgbGFuZ3VhZ2UsIG9yIGJlY2F1c2UgaXQgY29udGFpbnMgb3RoZXIgaGFybWZ1bCBjb250ZW50LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJlY2F1c2UgaXQgY29udGFpbnMgYSB0ZXJtIGZyb20gdGhlIHRlcm1pbm9sb2d5IGJsb2NrbGlzdC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tMSVNUXCJdID0gXCJCTE9DS0xJU1RcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJlY2F1c2UgaXQgY29udGFpbnMgcHJvaGliaXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYmVjYXVzZSBpdCBjb250YWlucyBjb250ZW50IHRoYXQgaXMgdW5zYWZlIGZvciBpbWFnZSBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJJTUFHRV9TQUZFVFlcIl0gPSBcIklNQUdFX1NBRkVUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYnkgTW9kZWwgQXJtb3IuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIk1PREVMX0FSTU9SXCJdID0gXCJNT0RFTF9BUk1PUlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYXMgYSBqYWlsYnJlYWsgYXR0ZW1wdC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiSkFJTEJSRUFLXCJdID0gXCJKQUlMQlJFQUtcIjtcbn0pKEJsb2NrZWRSZWFzb24gfHwgKEJsb2NrZWRSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUcmFmZmljIHR5cGUuIFRoaXMgc2hvd3Mgd2hldGhlciBhIHJlcXVlc3QgY29uc3VtZXMgUGF5LUFzLVlvdS1HbyBvciBQcm92aXNpb25lZCBUaHJvdWdocHV0IHF1b3RhLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFRyYWZmaWNUeXBlO1xuKGZ1bmN0aW9uIChUcmFmZmljVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHJlcXVlc3QgdHJhZmZpYyB0eXBlLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUeXBlIGZvciBQYXktQXMtWW91LUdvIHRyYWZmaWMuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJPTl9ERU1BTkRcIl0gPSBcIk9OX0RFTUFORFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKFRyYWZmaWNUeXBlIHx8IChUcmFmZmljVHlwZSA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNb2RhbGl0eTtcbihmdW5jdGlvbiAoTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gdGV4dFxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBpbWFnZXMuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gYXVkaW8uXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbn0pKE1vZGFsaXR5IHx8IChNb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xudmFyIE1lZGlhUmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0XG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdyAoNjQgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0gKDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2ggKHpvb21lZCByZWZyYW1pbmcgd2l0aCAyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoTWVkaWFSZXNvbHV0aW9uIHx8IChNZWRpYVJlc29sdXRpb24gPSB7fSkpO1xuLyoqIFR1bmluZyBtb2RlLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFR1bmluZ01vZGU7XG4oZnVuY3Rpb24gKFR1bmluZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgbW9kZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRnVsbCBmaW5lLXR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9GVUxMXCJdID0gXCJUVU5JTkdfTU9ERV9GVUxMXCI7XG4gICAgLyoqXG4gICAgICogUEVGVCBhZGFwdGVyIHR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIl0gPSBcIlRVTklOR19NT0RFX1BFRlRfQURBUFRFUlwiO1xufSkoVHVuaW5nTW9kZSB8fCAoVHVuaW5nTW9kZSA9IHt9KSk7XG4vKiogQWRhcHRlciBzaXplIGZvciB0dW5pbmcuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQWRhcHRlclNpemU7XG4oZnVuY3Rpb24gKEFkYXB0ZXJTaXplKSB7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1VOU1BFQ0lGSUVEXCJdID0gXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMS5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9PTkVcIl0gPSBcIkFEQVBURVJfU0laRV9PTkVcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9UV09cIl0gPSBcIkFEQVBURVJfU0laRV9UV09cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgNC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9GT1VSXCJdID0gXCJBREFQVEVSX1NJWkVfRk9VUlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA4LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0VJR0hUXCJdID0gXCJBREFQVEVSX1NJWkVfRUlHSFRcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMTYuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiXSA9IFwiQURBUFRFUl9TSVpFX1NJWFRFRU5cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMzIuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RISVJUWV9UV09cIjtcbn0pKEFkYXB0ZXJTaXplIHx8IChBZGFwdGVyU2l6ZSA9IHt9KSk7XG4vKiogSm9iIHN0YXRlLiAqL1xudmFyIEpvYlN0YXRlO1xuKGZ1bmN0aW9uIChKb2JTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2Igc3RhdGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIkpPQl9TVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4ganVzdCBjcmVhdGVkIG9yIHJlc3VtZWQgYW5kIHByb2Nlc3NpbmcgaGFzIG5vdCB5ZXQgYmVndW4uXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUVVFVUVEXCJdID0gXCJKT0JfU1RBVEVfUVVFVUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgaXMgcHJlcGFyaW5nIHRvIHJ1biB0aGUgam9iLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BFTkRJTkdcIl0gPSBcIkpPQl9TVEFURV9QRU5ESU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9SVU5OSU5HXCJdID0gXCJKT0JfU1RBVEVfUlVOTklOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9TVUNDRUVERURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGZhaWxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9GQUlMRURcIl0gPSBcIkpPQl9TVEFURV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIGNhbmNlbGxlZC4gRnJvbSB0aGlzIHN0YXRlIHRoZSBqb2IgbWF5IG9ubHkgZ28gdG8gZWl0aGVyIGBKT0JfU1RBVEVfU1VDQ0VFREVEYCwgYEpPQl9TVEFURV9GQUlMRURgIG9yIGBKT0JfU1RBVEVfQ0FOQ0VMTEVEYC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMSU5HXCJdID0gXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0NBTkNFTExFRFwiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gc3RvcHBlZCwgYW5kIGNhbiBiZSByZXN1bWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBVVNFRFwiXSA9IFwiSk9CX1NUQVRFX1BBVVNFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGV4cGlyZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRVhQSVJFRFwiXSA9IFwiSk9CX1NUQVRFX0VYUElSRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIHVwZGF0ZWQuIE9ubHkgam9icyBpbiB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZSBjYW4gYmUgdXBkYXRlZC4gQWZ0ZXIgdXBkYXRpbmcsIHRoZSBqb2IgZ29lcyBiYWNrIHRvIHRoZSBgSk9CX1NUQVRFX1JVTk5JTkdgIHN0YXRlLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VQREFUSU5HXCJdID0gXCJKT0JfU1RBVEVfVVBEQVRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIHBhcnRpYWxseSBzdWNjZWVkZWQsIHNvbWUgcmVzdWx0cyBtYXkgYmUgbWlzc2luZyBkdWUgdG8gZXJyb3JzLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBUlRJQUxMWV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCI7XG59KShKb2JTdGF0ZSB8fCAoSm9iU3RhdGUgPSB7fSkpO1xuLyoqIFRoZSB0dW5pbmcgdGFzay4gRWl0aGVyIEkyViBvciBUMlYuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgVHVuaW5nVGFzaztcbihmdW5jdGlvbiAoVHVuaW5nVGFzaykge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19VTlNQRUNJRklFRFwiXSA9IFwiVFVOSU5HX1RBU0tfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgdGFzayBmb3IgaW1hZ2UgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX0kyVlwiXSA9IFwiVFVOSU5HX1RBU0tfSTJWXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIHRleHQgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX1QyVlwiXSA9IFwiVFVOSU5HX1RBU0tfVDJWXCI7XG59KShUdW5pbmdUYXNrIHx8IChUdW5pbmdUYXNrID0ge30pKTtcbi8qKiBPcHRpb25zIGZvciBmZWF0dXJlIHNlbGVjdGlvbiBwcmVmZXJlbmNlLiAqL1xudmFyIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlO1xuKGZ1bmN0aW9uIChGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSkge1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiRkVBVFVSRV9TRUxFQ1RJT05fUFJFRkVSRU5DRV9VTlNQRUNJRklFRFwiXSA9IFwiRkVBVFVSRV9TRUxFQ1RJT05fUFJFRkVSRU5DRV9VTlNQRUNJRklFRFwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiUFJJT1JJVElaRV9RVUFMSVRZXCJdID0gXCJQUklPUklUSVpFX1FVQUxJVFlcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkJBTEFOQ0VEXCJdID0gXCJCQUxBTkNFRFwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiUFJJT1JJVElaRV9DT1NUXCJdID0gXCJQUklPUklUSVpFX0NPU1RcIjtcbn0pKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIHx8IChGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XG4vKiogRGVmaW5lcyB0aGUgZnVuY3Rpb24gYmVoYXZpb3IuIERlZmF1bHRzIHRvIGBCTE9DS0lOR2AuICovXG52YXIgQmVoYXZpb3I7XG4oZnVuY3Rpb24gKEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJVTlNQRUNJRklFRFwiXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCB3YWl0IHRvIHJlY2VpdmUgdGhlIGZ1bmN0aW9uIHJlc3BvbnNlIGJlZm9yZSBjb250aW51aW5nIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJCTE9DS0lOR1wiXSA9IFwiQkxPQ0tJTkdcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCBub3Qgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZS4gSW5zdGVhZCwgaXQgd2lsbCBhdHRlbXB0IHRvIGhhbmRsZSBmdW5jdGlvbiByZXNwb25zZXMgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlIHdoaWxlIG1haW50YWluaW5nIHRoZSBjb252ZXJzYXRpb24gYmV0d2VlbiB0aGUgdXNlciBhbmQgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiTk9OX0JMT0NLSU5HXCJdID0gXCJOT05fQkxPQ0tJTkdcIjtcbn0pKEJlaGF2aW9yIHx8IChCZWhhdmlvciA9IHt9KSk7XG4vKiogQ29uZmlnIGZvciB0aGUgZHluYW1pYyByZXRyaWV2YWwgY29uZmlnIG1vZGUuICovXG52YXIgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGU7XG4oZnVuY3Rpb24gKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogQWx3YXlzIHRyaWdnZXIgcmV0cmlldmFsLlxuICAgICAqL1xuICAgIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFJ1biByZXRyaWV2YWwgb25seSB3aGVuIHN5c3RlbSBkZWNpZGVzIGl0IGlzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG59KShEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSB8fCAoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgPSB7fSkpO1xuLyoqIFRoZSBlbnZpcm9ubWVudCBiZWluZyBvcGVyYXRlZC4gKi9cbnZhciBFbnZpcm9ubWVudDtcbihmdW5jdGlvbiAoRW52aXJvbm1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byBicm93c2VyLlxuICAgICAqL1xuICAgIEVudmlyb25tZW50W1wiRU5WSVJPTk1FTlRfVU5TUEVDSUZJRURcIl0gPSBcIkVOVklST05NRU5UX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0ZXMgaW4gYSB3ZWIgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudFtcIkVOVklST05NRU5UX0JST1dTRVJcIl0gPSBcIkVOVklST05NRU5UX0JST1dTRVJcIjtcbn0pKEVudmlyb25tZW50IHx8IChFbnZpcm9ubWVudCA9IHt9KSk7XG4vKiogQ29uZmlnIGZvciB0aGUgZnVuY3Rpb24gY2FsbGluZyBjb25maWcgbW9kZS4gKi9cbnZhciBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGxpbmcgY29uZmlnIG1vZGUgaXMgdW5zcGVjaWZpZWQuIFNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgbW9kZWwgYmVoYXZpb3IsIG1vZGVsIGRlY2lkZXMgdG8gcHJlZGljdCBlaXRoZXIgZnVuY3Rpb24gY2FsbHMgb3IgbmF0dXJhbCBsYW5ndWFnZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiQVVUT1wiXSA9IFwiQVVUT1wiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIGlzIGNvbnN0cmFpbmVkIHRvIGFsd2F5cyBwcmVkaWN0aW5nIGZ1bmN0aW9uIGNhbGxzIG9ubHkuIElmIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiIGFyZSBzZXQsIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBsaW1pdGVkIHRvIGFueSBvbmUgb2YgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIsIGVsc2UgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFOWVwiXSA9IFwiQU5ZXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgd2lsbCBub3QgcHJlZGljdCBhbnkgZnVuY3Rpb24gY2FsbHMuIE1vZGVsIGJlaGF2aW9yIGlzIHNhbWUgYXMgd2hlbiBub3QgcGFzc2luZyBhbnkgZnVuY3Rpb24gZGVjbGFyYXRpb25zLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJOT05FXCJdID0gXCJOT05FXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgZGVjaWRlcyB0byBwcmVkaWN0IGVpdGhlciBhIGZ1bmN0aW9uIGNhbGwgb3IgYSBuYXR1cmFsIGxhbmd1YWdlIHJlc3BvbnNlLCBidXQgd2lsbCB2YWxpZGF0ZSBmdW5jdGlvbiBjYWxscyB3aXRoIGNvbnN0cmFpbmVkIGRlY29kaW5nLiBJZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiBhcmUgc2V0LCB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGwgd2lsbCBiZSBsaW1pdGVkIHRvIGFueSBvbmUgb2YgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIsIGVsc2UgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxsIHdpbGwgYmUgYW55IG9uZSBvZiB0aGUgcHJvdmlkZWQgXCJmdW5jdGlvbl9kZWNsYXJhdGlvbnNcIi5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiVkFMSURBVEVEXCJdID0gXCJWQUxJREFURURcIjtcbn0pKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUgfHwgKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgc2FmZXR5IGZpbHRlciBsZXZlbCBmb3Igb2JqZWN0aW9uYWJsZSBjb250ZW50LiAqL1xudmFyIFNhZmV0eUZpbHRlckxldmVsO1xuKGZ1bmN0aW9uIChTYWZldHlGaWx0ZXJMZXZlbCkge1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfT05MWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0hJR0hcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX05PTkVcIl0gPSBcIkJMT0NLX05PTkVcIjtcbn0pKFNhZmV0eUZpbHRlckxldmVsIHx8IChTYWZldHlGaWx0ZXJMZXZlbCA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBnZW5lcmF0aW9uIG9mIHBlb3BsZS4gKi9cbnZhciBQZXJzb25HZW5lcmF0aW9uO1xuKGZ1bmN0aW9uIChQZXJzb25HZW5lcmF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQmxvY2sgZ2VuZXJhdGlvbiBvZiBpbWFnZXMgb2YgcGVvcGxlLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJET05UX0FMTE9XXCJdID0gXCJET05UX0FMTE9XXCI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgaW1hZ2VzIG9mIGFkdWx0cywgYnV0IG5vdCBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiQUxMT1dfQURVTFRcIl0gPSBcIkFMTE9XX0FEVUxUXCI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgaW1hZ2VzIHRoYXQgaW5jbHVkZSBhZHVsdHMgYW5kIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJBTExPV19BTExcIl0gPSBcIkFMTE9XX0FMTFwiO1xufSkoUGVyc29uR2VuZXJhdGlvbiB8fCAoUGVyc29uR2VuZXJhdGlvbiA9IHt9KSk7XG4vKiogRW51bSB0aGF0IHNwZWNpZmllcyB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIHRleHQgaW4gdGhlIHByb21wdC4gKi9cbnZhciBJbWFnZVByb21wdExhbmd1YWdlO1xuKGZ1bmN0aW9uIChJbWFnZVByb21wdExhbmd1YWdlKSB7XG4gICAgLyoqXG4gICAgICogQXV0by1kZXRlY3QgdGhlIGxhbmd1YWdlLlxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJhdXRvXCJdID0gXCJhdXRvXCI7XG4gICAgLyoqXG4gICAgICogRW5nbGlzaFxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJlblwiXSA9IFwiZW5cIjtcbiAgICAvKipcbiAgICAgKiBKYXBhbmVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJqYVwiXSA9IFwiamFcIjtcbiAgICAvKipcbiAgICAgKiBLb3JlYW5cbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wia29cIl0gPSBcImtvXCI7XG4gICAgLyoqXG4gICAgICogSGluZGlcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiaGlcIl0gPSBcImhpXCI7XG4gICAgLyoqXG4gICAgICogQ2hpbmVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJ6aFwiXSA9IFwiemhcIjtcbiAgICAvKipcbiAgICAgKiBQb3J0dWd1ZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcInB0XCJdID0gXCJwdFwiO1xuICAgIC8qKlxuICAgICAqIFNwYW5pc2hcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiZXNcIl0gPSBcImVzXCI7XG59KShJbWFnZVByb21wdExhbmd1YWdlIHx8IChJbWFnZVByb21wdExhbmd1YWdlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgbWFzayBtb2RlIG9mIGEgbWFzayByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgTWFza1JlZmVyZW5jZU1vZGU7XG4oZnVuY3Rpb24gKE1hc2tSZWZlcmVuY2VNb2RlKSB7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfREVGQVVMVFwiXSA9IFwiTUFTS19NT0RFX0RFRkFVTFRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCJdID0gXCJNQVNLX01PREVfVVNFUl9QUk9WSURFRFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIl0gPSBcIk1BU0tfTU9ERV9CQUNLR1JPVU5EXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfRk9SRUdST1VORFwiXSA9IFwiTUFTS19NT0RFX0ZPUkVHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9TRU1BTlRJQ1wiXSA9IFwiTUFTS19NT0RFX1NFTUFOVElDXCI7XG59KShNYXNrUmVmZXJlbmNlTW9kZSB8fCAoTWFza1JlZmVyZW5jZU1vZGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBjb250cm9sIHR5cGUgb2YgYSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBDb250cm9sUmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoQ29udHJvbFJlZmVyZW5jZVR5cGUpIHtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9ERUZBVUxUXCJdID0gXCJDT05UUk9MX1RZUEVfREVGQVVMVFwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0NBTk5ZXCJdID0gXCJDT05UUk9MX1RZUEVfQ0FOTllcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9TQ1JJQkJMRVwiXSA9IFwiQ09OVFJPTF9UWVBFX1NDUklCQkxFXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfRkFDRV9NRVNIXCJdID0gXCJDT05UUk9MX1RZUEVfRkFDRV9NRVNIXCI7XG59KShDb250cm9sUmVmZXJlbmNlVHlwZSB8fCAoQ29udHJvbFJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBzdWJqZWN0IHR5cGUgb2YgYSBzdWJqZWN0IHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBTdWJqZWN0UmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoU3ViamVjdFJlZmVyZW5jZVR5cGUpIHtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCJdID0gXCJTVUJKRUNUX1RZUEVfREVGQVVMVFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BFUlNPTlwiXSA9IFwiU1VCSkVDVF9UWVBFX1BFUlNPTlwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0FOSU1BTFwiXSA9IFwiU1VCSkVDVF9UWVBFX0FOSU1BTFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIl0gPSBcIlNVQkpFQ1RfVFlQRV9QUk9EVUNUXCI7XG59KShTdWJqZWN0UmVmZXJlbmNlVHlwZSB8fCAoU3ViamVjdFJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBlZGl0aW5nIG1vZGUuICovXG52YXIgRWRpdE1vZGU7XG4oZnVuY3Rpb24gKEVkaXRNb2RlKSB7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfREVGQVVMVFwiXSA9IFwiRURJVF9NT0RFX0RFRkFVTFRcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9JTlBBSU5UX1JFTU9WQUxcIl0gPSBcIkVESVRfTU9ERV9JTlBBSU5UX1JFTU9WQUxcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9JTlBBSU5UX0lOU0VSVElPTlwiXSA9IFwiRURJVF9NT0RFX0lOUEFJTlRfSU5TRVJUSU9OXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfT1VUUEFJTlRcIl0gPSBcIkVESVRfTU9ERV9PVVRQQUlOVFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0NPTlRST0xMRURfRURJVElOR1wiXSA9IFwiRURJVF9NT0RFX0NPTlRST0xMRURfRURJVElOR1wiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX1NUWUxFXCJdID0gXCJFRElUX01PREVfU1RZTEVcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9CR1NXQVBcIl0gPSBcIkVESVRfTU9ERV9CR1NXQVBcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9QUk9EVUNUX0lNQUdFXCJdID0gXCJFRElUX01PREVfUFJPRFVDVF9JTUFHRVwiO1xufSkoRWRpdE1vZGUgfHwgKEVkaXRNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgc2VnbWVudGF0aW9uIG1vZGUuICovXG52YXIgU2VnbWVudE1vZGU7XG4oZnVuY3Rpb24gKFNlZ21lbnRNb2RlKSB7XG4gICAgU2VnbWVudE1vZGVbXCJGT1JFR1JPVU5EXCJdID0gXCJGT1JFR1JPVU5EXCI7XG4gICAgU2VnbWVudE1vZGVbXCJCQUNLR1JPVU5EXCJdID0gXCJCQUNLR1JPVU5EXCI7XG4gICAgU2VnbWVudE1vZGVbXCJQUk9NUFRcIl0gPSBcIlBST01QVFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiU0VNQU5USUNcIl0gPSBcIlNFTUFOVElDXCI7XG4gICAgU2VnbWVudE1vZGVbXCJJTlRFUkFDVElWRVwiXSA9IFwiSU5URVJBQ1RJVkVcIjtcbn0pKFNlZ21lbnRNb2RlIHx8IChTZWdtZW50TW9kZSA9IHt9KSk7XG4vKiogRW51bSBmb3IgdGhlIHJlZmVyZW5jZSB0eXBlIG9mIGEgdmlkZW8gZ2VuZXJhdGlvbiByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIGltYWdlIHRoYXQgcHJvdmlkZXMgYXNzZXRzIHRvIHRoZSBnZW5lcmF0ZWQgdmlkZW8sXG4gICAgICAgIHN1Y2ggYXMgdGhlIHNjZW5lLCBhbiBvYmplY3QsIGEgY2hhcmFjdGVyLCBldGMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZVtcIkFTU0VUXCJdID0gXCJBU1NFVFwiO1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIGltYWdlIHRoYXQgcHJvdmlkZXMgYWVzdGhldGljcyBpbmNsdWRpbmcgY29sb3JzLFxuICAgICAgICBsaWdodGluZywgdGV4dHVyZSwgZXRjLiwgdG8gYmUgdXNlZCBhcyB0aGUgc3R5bGUgb2YgdGhlIGdlbmVyYXRlZCB2aWRlbyxcbiAgICAgICAgc3VjaCBhcyAnYW5pbWUnLCAncGhvdG9ncmFwaHknLCAnb3JpZ2FtaScsIGV0Yy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlW1wiU1RZTEVcIl0gPSBcIlNUWUxFXCI7XG59KShWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlIHx8IChWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIGZvciB0aGUgbWFzayBtb2RlIG9mIGEgdmlkZW8gZ2VuZXJhdGlvbiBtYXNrLiAqL1xudmFyIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlO1xuKGZ1bmN0aW9uIChWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGNvbnRhaW5zIGEgbWFza2VkIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aGljaCBpc1xuICAgICAgICBhcHBsaWVkIG9uIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgaW5wdXQgdmlkZW8uIFRoZSBvYmplY3QgZGVzY3JpYmVkIGluXG4gICAgICAgIHRoZSBwcm9tcHQgaXMgaW5zZXJ0ZWQgaW50byB0aGlzIHJlZ2lvbiBhbmQgd2lsbCBhcHBlYXIgaW4gc3Vic2VxdWVudFxuICAgICAgICBmcmFtZXMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGFuIG9iamVjdCBpbiB0aGVcbiAgICAgICAgZmlyc3QgdmlkZW8gZnJhbWUgdG8gdHJhY2suIFRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGUgdmlkZW8uXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJSRU1PVkVcIl0gPSBcIlJFTU9WRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGEgcmVnaW9uIGluIHRoZVxuICAgICAgICB2aWRlby4gT2JqZWN0cyBpbiB0aGlzIHJlZ2lvbiB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJSRU1PVkVfU1RBVElDXCJdID0gXCJSRU1PVkVfU1RBVElDXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgY29udGFpbnMgYSBtYXNrZWQgcmVjdGFuZ3VsYXIgcmVnaW9uIHdoZXJlXG4gICAgICAgIHRoZSBpbnB1dCB2aWRlbyB3aWxsIGdvLiBUaGUgcmVtYWluaW5nIGFyZWEgd2lsbCBiZSBnZW5lcmF0ZWQuIFZpZGVvXG4gICAgICAgIG1hc2tzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiT1VUUEFJTlRcIl0gPSBcIk9VVFBBSU5UXCI7XG59KShWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSB8fCAoVmlkZW9HZW5lcmF0aW9uTWFza01vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgY29tcHJlc3Npb24gcXVhbGl0eSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvcy4gKi9cbnZhciBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBjb21wcmVzc2VkLCBzbWFsbGVyIGZpbGUgc2l6ZS5cbiAgICAgKi9cbiAgICBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eVtcIk9QVElNSVpFRFwiXSA9IFwiT1BUSU1JWkVEXCI7XG4gICAgLyoqXG4gICAgICogTG9zc2xlc3MgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBsYXJnZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiTE9TU0xFU1NcIl0gPSBcIkxPU1NMRVNTXCI7XG59KShWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSB8fCAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSB0dW5pbmcgbWV0aG9kLiAqL1xudmFyIFR1bmluZ01ldGhvZDtcbihmdW5jdGlvbiAoVHVuaW5nTWV0aG9kKSB7XG4gICAgLyoqXG4gICAgICogU3VwZXJ2aXNlZCBmaW5lIHR1bmluZy5cbiAgICAgKi9cbiAgICBUdW5pbmdNZXRob2RbXCJTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HXCJdID0gXCJTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HXCI7XG4gICAgLyoqXG4gICAgICogUHJlZmVyZW5jZSBvcHRpbWl6YXRpb24gdHVuaW5nLlxuICAgICAqL1xuICAgIFR1bmluZ01ldGhvZFtcIlBSRUZFUkVOQ0VfVFVOSU5HXCJdID0gXCJQUkVGRVJFTkNFX1RVTklOR1wiO1xufSkoVHVuaW5nTWV0aG9kIHx8IChUdW5pbmdNZXRob2QgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRmlsZS4gKi9cbnZhciBGaWxlU3RhdGU7XG4oZnVuY3Rpb24gKEZpbGVTdGF0ZSkge1xuICAgIEZpbGVTdGF0ZVtcIlNUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTdGF0ZVtcIlBST0NFU1NJTkdcIl0gPSBcIlBST0NFU1NJTkdcIjtcbiAgICBGaWxlU3RhdGVbXCJBQ1RJVkVcIl0gPSBcIkFDVElWRVwiO1xuICAgIEZpbGVTdGF0ZVtcIkZBSUxFRFwiXSA9IFwiRkFJTEVEXCI7XG59KShGaWxlU3RhdGUgfHwgKEZpbGVTdGF0ZSA9IHt9KSk7XG4vKiogU291cmNlIG9mIHRoZSBGaWxlLiAqL1xudmFyIEZpbGVTb3VyY2U7XG4oZnVuY3Rpb24gKEZpbGVTb3VyY2UpIHtcbiAgICBGaWxlU291cmNlW1wiU09VUkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJTT1VSQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU291cmNlW1wiVVBMT0FERURcIl0gPSBcIlVQTE9BREVEXCI7XG4gICAgRmlsZVNvdXJjZVtcIkdFTkVSQVRFRFwiXSA9IFwiR0VORVJBVEVEXCI7XG59KShGaWxlU291cmNlIHx8IChGaWxlU291cmNlID0ge30pKTtcbi8qKiBUaGUgcmVhc29uIHdoeSB0aGUgdHVybiBpcyBjb21wbGV0ZS4gKi9cbnZhciBUdXJuQ29tcGxldGVSZWFzb247XG4oZnVuY3Rpb24gKFR1cm5Db21wbGV0ZVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJUVVJOX0NPTVBMRVRFX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiVFVSTl9DT01QTEVURV9SRUFTT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIl0gPSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHJlc3BvbnNlIGlzIHJlamVjdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJSRVNQT05TRV9SRUpFQ1RFRFwiXSA9IFwiUkVTUE9OU0VfUkVKRUNURURcIjtcbiAgICAvKipcbiAgICAgKiBOZWVkcyBtb3JlIGlucHV0IGZyb20gdGhlIHVzZXIuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiTkVFRF9NT1JFX0lOUFVUXCJdID0gXCJORUVEX01PUkVfSU5QVVRcIjtcbn0pKFR1cm5Db21wbGV0ZVJlYXNvbiB8fCAoVHVybkNvbXBsZXRlUmVhc29uID0ge30pKTtcbi8qKiBTZXJ2ZXIgY29udGVudCBtb2RhbGl0aWVzLiAqL1xudmFyIE1lZGlhTW9kYWxpdHk7XG4oZnVuY3Rpb24gKE1lZGlhTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIlRFWFRcIl0gPSBcIlRFWFRcIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZXMuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIFZpZGVvLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJWSURFT1wiXSA9IFwiVklERU9cIjtcbiAgICAvKipcbiAgICAgKiBBdWRpby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiQVVESU9cIl0gPSBcIkFVRElPXCI7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnQsIGUuZy4gUERGLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJET0NVTUVOVFwiXSA9IFwiRE9DVU1FTlRcIjtcbn0pKE1lZGlhTW9kYWxpdHkgfHwgKE1lZGlhTW9kYWxpdHkgPSB7fSkpO1xuLyoqIFN0YXJ0IG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBTdGFydFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChTdGFydFNlbnNpdGl2aXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgU1RBUlRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBvZiBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBsZXNzIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoU3RhcnRTZW5zaXRpdml0eSB8fCAoU3RhcnRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogRW5kIG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBFbmRTZW5zaXRpdml0eTtcbihmdW5jdGlvbiAoRW5kU2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBFTkRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIG1vcmUgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShFbmRTZW5zaXRpdml0eSB8fCAoRW5kU2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIFRoZSBkaWZmZXJlbnQgd2F5cyBvZiBoYW5kbGluZyB1c2VyIGFjdGl2aXR5LiAqL1xudmFyIEFjdGl2aXR5SGFuZGxpbmc7XG4oZnVuY3Rpb24gKEFjdGl2aXR5SGFuZGxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNgLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiXSA9IFwiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdGFydCBvZiBhY3Rpdml0eSB3aWxsIGludGVycnVwdCB0aGUgbW9kZWwncyByZXNwb25zZSAoYWxzbyBjYWxsZWQgXCJiYXJnZSBpblwiKS4gVGhlIG1vZGVsJ3MgY3VycmVudCByZXNwb25zZSB3aWxsIGJlIGN1dC1vZmYgaW4gdGhlIG1vbWVudCBvZiB0aGUgaW50ZXJydXB0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCJdID0gXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsJ3MgcmVzcG9uc2Ugd2lsbCBub3QgYmUgaW50ZXJydXB0ZWQuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIk5PX0lOVEVSUlVQVElPTlwiXSA9IFwiTk9fSU5URVJSVVBUSU9OXCI7XG59KShBY3Rpdml0eUhhbmRsaW5nIHx8IChBY3Rpdml0eUhhbmRsaW5nID0ge30pKTtcbi8qKiBPcHRpb25zIGFib3V0IHdoaWNoIGlucHV0IGlzIGluY2x1ZGVkIGluIHRoZSB1c2VyJ3MgdHVybi4gKi9cbnZhciBUdXJuQ292ZXJhZ2U7XG4oZnVuY3Rpb24gKFR1cm5Db3ZlcmFnZSkge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZYC5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gb25seSBpbmNsdWRlcyBhY3Rpdml0eSBzaW5jZSB0aGUgbGFzdCB0dXJuLCBleGNsdWRpbmcgaW5hY3Rpdml0eSAoZS5nLiBzaWxlbmNlIG9uIHRoZSBhdWRpbyBzdHJlYW0pLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWVwiXSA9IFwiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gaW5jbHVkZXMgYWxsIHJlYWx0aW1lIGlucHV0IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGluY2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIl0gPSBcIlRVUk5fSU5DTFVERVNfQUxMX0lOUFVUXCI7XG59KShUdXJuQ292ZXJhZ2UgfHwgKFR1cm5Db3ZlcmFnZSA9IHt9KSk7XG4vKiogU2NhbGUgb2YgdGhlIGdlbmVyYXRlZCBtdXNpYy4gKi9cbnZhciBTY2FsZTtcbihmdW5jdGlvbiAoU2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBTY2FsZVtcIlNDQUxFX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0FMRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEMgbWFqb3Igb3IgQSBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkNfTUFKT1JfQV9NSU5PUlwiXSA9IFwiQ19NQUpPUl9BX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRGIgbWFqb3Igb3IgQmIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCJdID0gXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRCBtYWpvciBvciBCIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRF9NQUpPUl9CX01JTk9SXCJdID0gXCJEX01BSk9SX0JfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFYiBtYWpvciBvciBDIG1pbm9yXG4gICAgICovXG4gICAgU2NhbGVbXCJFX0ZMQVRfTUFKT1JfQ19NSU5PUlwiXSA9IFwiRV9GTEFUX01BSk9SX0NfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFIG1ham9yIG9yIERiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRV9NQUpPUl9EX0ZMQVRfTUlOT1JcIl0gPSBcIkVfTUFKT1JfRF9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRiBtYWpvciBvciBEIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRl9NQUpPUl9EX01JTk9SXCJdID0gXCJGX01BSk9SX0RfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHYiBtYWpvciBvciBFYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIl0gPSBcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHIG1ham9yIG9yIEUgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJHX01BSk9SX0VfTUlOT1JcIl0gPSBcIkdfTUFKT1JfRV9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEFiIG1ham9yIG9yIEYgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJBX0ZMQVRfTUFKT1JfRl9NSU5PUlwiXSA9IFwiQV9GTEFUX01BSk9SX0ZfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBBIG1ham9yIG9yIEdiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQV9NQUpPUl9HX0ZMQVRfTUlOT1JcIl0gPSBcIkFfTUFKT1JfR19GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQmIgbWFqb3Igb3IgRyBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkJfRkxBVF9NQUpPUl9HX01JTk9SXCJdID0gXCJCX0ZMQVRfTUFKT1JfR19NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEIgbWFqb3Igb3IgQWIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJCX01BSk9SX0FfRkxBVF9NSU5PUlwiXSA9IFwiQl9NQUpPUl9BX0ZMQVRfTUlOT1JcIjtcbn0pKFNjYWxlIHx8IChTY2FsZSA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBNdXNpY0dlbmVyYXRpb25Nb2RlO1xuKGZ1bmN0aW9uIChNdXNpY0dlbmVyYXRpb25Nb2RlKSB7XG4gICAgLyoqXG4gICAgICogUmVseSBvbiB0aGUgc2VydmVyIGRlZmF1bHQgZ2VuZXJhdGlvbiBtb2RlLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJNVVNJQ19HRU5FUkFUSU9OX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1VU0lDX0dFTkVSQVRJT05fTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSB3aXRoIGhpZ2hlciBxdWFsaXR5XG4gICAgICAgIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJRVUFMSVRZXCJdID0gXCJRVUFMSVRZXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIHdpdGggYSBsYXJnZXJcbiAgICAgICAgZGl2ZXJzaXR5IG9mIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJESVZFUlNJVFlcIl0gPSBcIkRJVkVSU0lUWVwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSBtb3JlIGxpa2VseSB0b1xuICAgICAgICBnZW5lcmF0ZSBtdXNpYyB3aXRoIHZvY2Fscy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiVk9DQUxJWkFUSU9OXCJdID0gXCJWT0NBTElaQVRJT05cIjtcbn0pKE11c2ljR2VuZXJhdGlvbk1vZGUgfHwgKE11c2ljR2VuZXJhdGlvbk1vZGUgPSB7fSkpO1xuLyoqIFRoZSBwbGF5YmFjayBjb250cm9sIHNpZ25hbCB0byBhcHBseSB0byB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2w7XG4oZnVuY3Rpb24gKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIl0gPSBcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGFydCBnZW5lcmF0aW5nIHRoZSBtdXNpYy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQTEFZXCJdID0gXCJQTEFZXCI7XG4gICAgLyoqXG4gICAgICogSG9sZCB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gVXNlIFBMQVkgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUEFVU0VcIl0gPSBcIlBBVVNFXCI7XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgZ2VuZXJhdGlvbiBhbmQgcmVzZXQgdGhlIGNvbnRleHQgKHByb21wdHMgcmV0YWluZWQpLlxuICAgICAgICBVc2UgUExBWSB0byByZXN0YXJ0IHRoZSBtdXNpYyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlNUT1BcIl0gPSBcIlNUT1BcIjtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAgICBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHMgYW5kIGNvbmZpZy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJSRVNFVF9DT05URVhUXCJdID0gXCJSRVNFVF9DT05URVhUXCI7XG59KShMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wgfHwgKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCA9IHt9KSk7XG4vKiogUmF3IG1lZGlhIGJ5dGVzIGZvciBmdW5jdGlvbiByZXNwb25zZS5cblxuVGV4dCBzaG91bGQgbm90IGJlIHNlbnQgYXMgcmF3IGJ5dGVzLCB1c2UgdGhlIEZ1bmN0aW9uUmVzcG9uc2UucmVzcG9uc2VcbmZpZWxkLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZUJsb2Ige1xufVxuLyoqIFVSSSBiYXNlZCBkYXRhIGZvciBmdW5jdGlvbiByZXNwb25zZS4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSB7XG59XG4vKiogQSBkYXRhdHlwZSBjb250YWluaW5nIG1lZGlhIHRoYXQgaXMgcGFydCBvZiBhIGBGdW5jdGlvblJlc3BvbnNlYCBtZXNzYWdlLlxuXG5BIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgY29uc2lzdHMgb2YgZGF0YSB3aGljaCBoYXMgYW4gYXNzb2NpYXRlZCBkYXRhdHlwZS4gQVxuYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBjYW4gb25seSBjb250YWluIG9uZSBvZiB0aGUgYWNjZXB0ZWQgdHlwZXMgaW5cbmBGdW5jdGlvblJlc3BvbnNlUGFydC5kYXRhYC5cblxuQSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG11c3QgaGF2ZSBhIGZpeGVkIElBTkEgTUlNRSB0eXBlIGlkZW50aWZ5aW5nIHRoZVxudHlwZSBhbmQgc3VidHlwZSBvZiB0aGUgbWVkaWEgaWYgdGhlIGBpbmxpbmVfZGF0YWAgZmllbGQgaXMgZmlsbGVkIHdpdGggcmF3XG5ieXRlcy4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VQYXJ0IHtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgb2JqZWN0IGZyb20gYSBgYmFzZTY0YCBlbmNvZGVkIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21CYXNlNjQoZGF0YSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG9iamVjdCBmcm9tIGEgYFVSSWAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21VcmkodXJpLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICBmaWxlVXJpOiB1cmksXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKiBBIGZ1bmN0aW9uIHJlc3BvbnNlLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZSB7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgVVJJYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVXJpKHVyaSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgZmlsZVVyaTogdXJpLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgdGV4dGAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbVRleHQodGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvbkNhbGxgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwobmFtZSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZShpZCwgbmFtZSwgcmVzcG9uc2UsIHBhcnRzID0gW10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiBPYmplY3QuYXNzaWduKHsgaWQ6IGlkLCBuYW1lOiBuYW1lLCByZXNwb25zZTogcmVzcG9uc2UgfSwgKHBhcnRzLmxlbmd0aCA+IDAgJiYgeyBwYXJ0cyB9KSksXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBiYXNlNjRgIGVuY29kZWQgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tQmFzZTY0KGRhdGEsIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5saW5lRGF0YToge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgb3V0Y29tZWAgYW5kIGBvdXRwdXRgIG9mIGEgYENvZGVFeGVjdXRpb25SZXN1bHRgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KG91dGNvbWUsIG91dHB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVFeGVjdXRpb25SZXN1bHQ6IHtcbiAgICAgICAgICAgIG91dGNvbWU6IG91dGNvbWUsXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgY29kZWAgYW5kIGBsYW5ndWFnZWAgb2YgYW4gYEV4ZWN1dGFibGVDb2RlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRhYmxlQ29kZToge1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gX2lzUGFydChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoJ2ZpbGVEYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICd0ZXh0JyBpbiBvYmogfHxcbiAgICAgICAgICAgICdmdW5jdGlvbkNhbGwnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2lubGluZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyBpbiBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgcGFydE9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0T3JTdHJpbmcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydE9yU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIGlmIChwYXJ0T3JTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydE9yU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjcmVhdGVQYXJ0RnJvbVRleHQocGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgaW4gUGFydFVuaW9uIG11c3QgYmUgYSBQYXJ0IG9iamVjdCBvciBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0T3JTdHJpbmcgbXVzdCBiZSBhIFBhcnQgb2JqZWN0LCBzdHJpbmcsIG9yIGFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDb250ZW50YCBvYmplY3Qgd2l0aCBhIHVzZXIgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXNlckNvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBwYXJ0czogX3RvUGFydHMocGFydE9yU3RyaW5nKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgbW9kZWwgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxDb250ZW50KHBhcnRPclN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdtb2RlbCcsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKiogQSB3cmFwcGVyIGNsYXNzIGZvciB0aGUgaHR0cCByZXNwb25zZS4gKi9cbmNsYXNzIEh0dHBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLnJlc3BvbnNlSW50ZXJuYWwgPSByZXNwb25zZTtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbnRlcm5hbC5qc29uKCk7XG4gICAgfVxufVxuLyoqIENvbnRlbnQgZmlsdGVyIHJlc3VsdHMgZm9yIGEgcHJvbXB0IHNlbnQgaW4gdGhlIHJlcXVlc3QuIE5vdGU6IFRoaXMgaXMgc2VudCBvbmx5IGluIHRoZSBmaXJzdCBzdHJlYW0gY2h1bmsgYW5kIG9ubHkgaWYgbm8gY2FuZGlkYXRlcyB3ZXJlIGdlbmVyYXRlZCBkdWUgdG8gY29udGVudCB2aW9sYXRpb25zLiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjayB7XG59XG4vKiogVXNhZ2UgbWV0YWRhdGEgYWJvdXQgcmVzcG9uc2UocykuIFRoaXMgZGF0YSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSB7XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgUHJlZGljdGlvblNlcnZpY2UuR2VuZXJhdGVDb250ZW50LiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgdGV4dCBmcm9tIHRoZSBmaXJzdFxuICAgICAqIG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgdGhvdWdodCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgZXhjbHVkaW5nIHRoZSB0aG91Z2h0IHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgdGV4dCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0VGV4dCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub25UZXh0UGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0JyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblRleHRQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRob3VnaHQgPT09ICdib29sZWFuJyAmJiBwYXJ0LnRob3VnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVRleHRQYXJ0VGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRUZXh0ID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlXG4gICAgICogaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBpbmxpbmUgZGF0YSBmcm9tIHRoZVxuICAgICAqIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGVyZSBhcmUgbm9uLWlubGluZSBkYXRhIHBhcnRzIGluIHRoZVxuICAgICAqIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kXG4gICAgICogYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGRhdGEgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWVsZFZhbHVlICE9PSBudWxsIHx8IGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBmdW5jdGlvbiBjYWxscyBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb246IEZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XG4gICAgICogICBuYW1lOiAnY29udHJvbExpZ2h0JyxcbiAgICAgKiAgIHBhcmFtZXRlcnM6IHtcbiAgICAgKiAgIHR5cGU6IFR5cGUuT0JKRUNULFxuICAgICAqICAgZGVzY3JpcHRpb246ICdTZXQgdGhlIGJyaWdodG5lc3MgYW5kIGNvbG9yIHRlbXBlcmF0dXJlIG9mIGEgcm9vbSBsaWdodC4nLFxuICAgICAqICAgcHJvcGVydGllczoge1xuICAgICAqICAgICBicmlnaHRuZXNzOiB7XG4gICAgICogICAgICAgdHlwZTogVHlwZS5OVU1CRVIsXG4gICAgICogICAgICAgZGVzY3JpcHRpb246XG4gICAgICogICAgICAgICAnTGlnaHQgbGV2ZWwgZnJvbSAwIHRvIDEwMC4gWmVybyBpcyBvZmYgYW5kIDEwMCBpcyBmdWxsIGJyaWdodG5lc3MuJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY29sb3JUZW1wZXJhdHVyZToge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuU1RSSU5HLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0NvbG9yIHRlbXBlcmF0dXJlIG9mIHRoZSBsaWdodCBmaXh0dXJlIHdoaWNoIGNhbiBiZSBgZGF5bGlnaHRgLCBgY29vbGAgb3IgYHdhcm1gLicsXG4gICAgICogICAgIH0sXG4gICAgICogICB9LFxuICAgICAqICAgcmVxdWlyZWQ6IFsnYnJpZ2h0bmVzcycsICdjb2xvclRlbXBlcmF0dXJlJ10sXG4gICAgICogIH07XG4gICAgICogIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICAgIGNvbnRlbnRzOiAnRGltIHRoZSBsaWdodHMgc28gdGhlIHJvb20gZmVlbHMgY296eSBhbmQgd2FybS4nLFxuICAgICAqICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICB0b29sczogW3tmdW5jdGlvbkRlY2xhcmF0aW9uczogW2NvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb25dfV0sXG4gICAgICogICAgICAgdG9vbENvbmZpZzoge1xuICAgICAqICAgICAgICAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7XG4gICAgICogICAgICAgICAgIG1vZGU6IEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUuQU5ZLFxuICAgICAqICAgICAgICAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogWydjb250cm9sTGlnaHQnXSxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0pO1xuICAgICAqICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZnVuY3Rpb25DYWxscygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxscyA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkubWFwKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkuZmlsdGVyKChmdW5jdGlvbkNhbGwpID0+IGZ1bmN0aW9uQ2FsbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChmdW5jdGlvbkNhbGxzID09PSBudWxsIHx8IGZ1bmN0aW9uQ2FsbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1bmN0aW9uQ2FsbHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGV4ZWN1dGFibGUgY29kZSBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBleGVjdXRhYmxlIGNvZGUgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuZXhlY3V0YWJsZUNvZGUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleGVjdXRhYmxlQ29kZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGVjdXRhYmxlQ29kZSA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5tYXAoKHBhcnQpID0+IHBhcnQuZXhlY3V0YWJsZUNvZGUpLmZpbHRlcigoZXhlY3V0YWJsZUNvZGUpID0+IGV4ZWN1dGFibGVDb2RlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGV4ZWN1dGFibGVDb2RlID09PSBudWxsIHx8IGV4ZWN1dGFibGVDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRhYmxlQ29kZS5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGVbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuY29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvZGVFeGVjdXRpb25SZXN1bHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZUV4ZWN1dGlvblJlc3VsdCA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpLm1hcCgocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5maWx0ZXIoKGNvZGVFeGVjdXRpb25SZXN1bHQpID0+IGNvZGVFeGVjdXRpb25SZXN1bHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gbnVsbCB8fCBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlRXhlY3V0aW9uUmVzdWx0Lmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfaiA9IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm91dHB1dDtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBlbWJlZF9jb250ZW50IG1ldGhvZC4gKi9cbmNsYXNzIEVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgcmVxdWVzdCB0byBlZGl0IGFuIGltYWdlLiAqL1xuY2xhc3MgRWRpdEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgVXBzY2FsZUltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBTZWdtZW50SW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0TW9kZWxzUmVzcG9uc2Uge1xufVxuY2xhc3MgRGVsZXRlTW9kZWxSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvdW50aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvdW50VG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb21wdXRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSB3aXRoIGdlbmVyYXRlZCB2aWRlb3MuICovXG5jbGFzcyBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlIHtcbn1cbi8qKiBBIHZpZGVvIGdlbmVyYXRpb24gb3BlcmF0aW9uLiAqL1xuY2xhc3MgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBPcGVyYXRpb24gb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgb25lIGJlaW5nIGNhbGxlZCB3aXRoIHRoZSBmaWVsZHMgc2V0IGZyb20gdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZnJvbUFQSVJlc3BvbnNlKHsgYXBpUmVzcG9uc2UsIGlzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgaWYgKGlzVmVydGV4QUkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEob3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKG9wKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgdHVuaW5nIGpvYnMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSB7XG59XG4vKiogRW1wdHkgcmVzcG9uc2UgZm9yIGNhY2hlcy5kZWxldGUgbWV0aG9kLiAqL1xuY2xhc3MgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlIHtcbn1cbmNsYXNzIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgZmlsZXMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdEZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgY3JlYXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgQ3JlYXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgcmVzcG9uc2VgIHBhcmFtZXRlci4gKi9cbmNsYXNzIFNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBDb25maWcgZm9yIGBpbmxpbmVkX2VtYmVkZGluZ19yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBiYXRjaGVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIHJlc3BvbnNlIGluIGEgcmVwbGF5LiAqL1xuY2xhc3MgUmVwbGF5UmVzcG9uc2Uge1xufVxuLyoqIEEgcmF3IHJlZmVyZW5jZSBpbWFnZS5cblxuQSByYXcgcmVmZXJlbmNlIGltYWdlIHJlcHJlc2VudHMgdGhlIGJhc2UgaW1hZ2UgdG8gZWRpdCwgcHJvdmlkZWQgYnkgdGhlIHVzZXIuXG5JdCBjYW4gb3B0aW9uYWxseSBiZSBwcm92aWRlZCBpbiBhZGRpdGlvbiB0byBhIG1hc2sgcmVmZXJlbmNlIGltYWdlIG9yXG5hIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS4gKi9cbmNsYXNzIFJhd1JlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9SQVcnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIG1hc2sgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGlzIGVuY2Fwc3VsYXRlcyBlaXRoZXIgYSBtYXNrIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGFuZCBjb25maWdzIGZvclxudGhlIHVzZXIgcHJvdmlkZWQgbWFzaywgb3Igb25seSBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIG1vZGVsIHRvIGdlbmVyYXRlXG5hIG1hc2suXG5cbkEgbWFzayBpbWFnZSBpcyBhbiBpbWFnZSB3aG9zZSBub24temVybyB2YWx1ZXMgaW5kaWNhdGUgd2hlcmUgdG8gZWRpdCB0aGUgYmFzZVxuaW1hZ2UuIElmIHRoZSB1c2VyIHByb3ZpZGVzIGEgbWFzayBpbWFnZSwgdGhlIG1hc2sgbXVzdCBiZSBpbiB0aGUgc2FtZVxuZGltZW5zaW9ucyBhcyB0aGUgcmF3IGltYWdlLiAqL1xuY2xhc3MgTWFza1JlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9NQVNLJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBtYXNrSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UuXG5cblRoZSBpbWFnZSBvZiB0aGUgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UgaXMgZWl0aGVyIGEgY29udHJvbCBpbWFnZSBwcm92aWRlZFxuYnkgdGhlIHVzZXIsIG9yIGEgcmVndWxhciBpbWFnZSB3aGljaCB0aGUgYmFja2VuZCB3aWxsIHVzZSB0byBnZW5lcmF0ZSBhXG5jb250cm9sIGltYWdlIG9mLiBJbiB0aGUgY2FzZSBvZiB0aGUgbGF0dGVyLCB0aGVcbmVuYWJsZV9jb250cm9sX2ltYWdlX2NvbXB1dGF0aW9uIGZpZWxkIGluIHRoZSBjb25maWcgc2hvdWxkIGJlIHNldCB0byBUcnVlLlxuXG5BIGNvbnRyb2wgaW1hZ2UgaXMgYW4gaW1hZ2UgdGhhdCByZXByZXNlbnRzIGEgc2tldGNoIGltYWdlIG9mIGFyZWFzIGZvciB0aGVcbm1vZGVsIHRvIGZpbGwgaW4gYmFzZWQgb24gdGhlIHByb21wdC4gKi9cbmNsYXNzIENvbnRyb2xSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVFJPTCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgY29udHJvbEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuVGhpcyBlbmNhcHN1bGF0ZXMgYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuYWRkaXRpb25hbGx5IG9wdGlvbmFsIGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgc3R5bGUgcmVmZXJlbmNlIGltYWdlLlxuXG5BIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN0eWxlIHRvXG5iZSBhcHBsaWVkIHRvLiAqL1xuY2xhc3MgU3R5bGVSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1RZTEUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIHN0eWxlSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cblRoaXMgZW5jYXBzdWxhdGVzIGEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuYWRkaXRpb25hbGx5IG9wdGlvbmFsIGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgcmF3IHJlZmVyZW5jZSBpbWFnZSBjYW4gYWxzbyBiZSBwcm92aWRlZCBhcyBhIGRlc3RpbmF0aW9uIGZvciB0aGUgc3ViamVjdCB0b1xuYmUgYXBwbGllZCB0by4gKi9cbmNsYXNzIFN1YmplY3RSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9TVUJKRUNUJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdWJqZWN0SW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UgcmVwcmVzZW50cyBhIHN1YmplY3QgdG8gcmVmZXJlbmNlIChleC4gcGVyc29uLFxucHJvZHVjdCwgYW5pbWFsKSBwcm92aWRlZCBieSB0aGUgdXNlci4gSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW5cbmFkZGl0aW9uIHRvIGEgc3R5bGUgcmVmZXJlbmNlIGltYWdlIChleC4gYmFja2dyb3VuZCwgc3R5bGUgcmVmZXJlbmNlKS4gKi9cbmNsYXNzIENvbnRlbnRSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVEVOVCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIEFQSSBjYWxsLiAqL1xuY2xhc3MgTGl2ZVNlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmQgYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlcnZlckNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlbFR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uVGV4dFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzICR7bm9uVGV4dFBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiB0ZXh0IHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0LnRleHQgPT09ICcnIGlzIGRpZmZlcmVudCBmcm9tIHBhcnQudGV4dCBpcyBudWxsXG4gICAgICAgIHJldHVybiBhbnlUZXh0UGFydEZvdW5kID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBDbGllbnQgZ2VuZXJhdGVkIHJlc3BvbnNlIHRvIGEgYFRvb2xDYWxsYCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG5cbkluZGl2aWR1YWwgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdHMgYXJlIG1hdGNoZWQgdG8gdGhlIHJlc3BlY3RpdmVcbmBGdW5jdGlvbkNhbGxgIG9iamVjdHMgYnkgdGhlIGBpZGAgZmllbGQuXG5cbk5vdGUgdGhhdCBpbiB0aGUgdW5hcnkgYW5kIHNlcnZlci1zdHJlYW1pbmcgR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb25cbmNhbGxpbmcgaGFwcGVucyBieSBleGNoYW5naW5nIHRoZSBgQ29udGVudGAgcGFydHMsIHdoaWxlIGluIHRoZSBiaWRpXG5HZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvbiBjYWxsaW5nIGhhcHBlbnMgb3ZlciB0aGlzIGRlZGljYXRlZCBzZXQgb2Zcbm1lc3NhZ2VzLiAqL1xuY2xhc3MgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSB7XG59XG4vKiogUGFyYW1ldGVycyBmb3Igc2VuZGluZyB0b29sIHJlc3BvbnNlcyB0byB0aGUgbGl2ZSBBUEkuICovXG5jbGFzcyBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogVG9vbCByZXNwb25zZXMgdG8gc2VuZCB0byB0aGUgc2Vzc2lvbi4gKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciB0aGUgTGl2ZU11c2ljQ2xpZW50TWVzc2FnZSBjYWxsLiAqL1xuY2xhc3MgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgYXVkaW8gY2h1bmsgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBubyBhdWRpbyBjaHVua3MgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgYXVkaW9DaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyQ29udGVudCAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzICYmXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSB8fFxuICAgICAgICAgICAgbW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJy8nKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IG1vZGVsLnNwbGl0KCcvJywgMik7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvJHtwYXJ0c1swXX0vbW9kZWxzLyR7cGFydHNbMV19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgcHVibGlzaGVycy9nb29nbGUvbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSB8fCBtb2RlbC5zdGFydHNXaXRoKCd0dW5lZE1vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBtb2RlbHMvJHttb2RlbH1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdENhY2hlc01vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZE1vZGVsID0gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpO1xuICAgIGlmICghdHJhbnNmb3JtZWRNb2RlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgJiYgYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAvLyB2ZXJ0ZXggY2FjaGVzIG9ubHkgc3VwcG9ydCBtb2RlbCBuYW1lIHN0YXJ0IHdpdGggcHJvamVjdHMuXG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgnbW9kZWxzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2FwaUNsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2FwaUNsaWVudC5nZXRMb2NhdGlvbigpfS9wdWJsaXNoZXJzL2dvb2dsZS8ke3RyYW5zZm9ybWVkTW9kZWx9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9icyhibG9icykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2JzKSkge1xuICAgICAgICByZXR1cm4gYmxvYnMubWFwKChibG9iKSA9PiB0QmxvYihibG9iKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3RCbG9iKGJsb2JzKV07XG4gICAgfVxufVxuZnVuY3Rpb24gdEJsb2IoYmxvYikge1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ29iamVjdCcgJiYgYmxvYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgaW5wdXQgYXMgQmxvYi4gVW5zdXBwb3J0ZWQgYmxvYiB0eXBlOiAke3R5cGVvZiBibG9ifWApO1xufVxuZnVuY3Rpb24gdEltYWdlQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdEF1ZGlvQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnYXVkaW8vJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdFBhcnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IG9yaWdpbiB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlb2Ygb3JpZ2lufWApO1xufVxuZnVuY3Rpb24gdFBhcnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRMaXN0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdFBhcnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RQYXJ0KG9yaWdpbildO1xufVxuZnVuY3Rpb24gX2lzQ29udGVudChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncGFydHMnIGluIG9yaWdpbiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KG9yaWdpbi5wYXJ0cykpO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnZnVuY3Rpb25DYWxsJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0Q29udGVudChvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChfaXNDb250ZW50KG9yaWdpbikpIHtcbiAgICAgICAgLy8gX2lzQ29udGVudCBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gICAgICAgIC8vIG9yaWdpbiBpcyBhIENvbnRlbnQuXG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IHRQYXJ0cyhvcmlnaW4pLFxuICAgIH07XG59XG5mdW5jdGlvbiB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIG9yaWdpbikge1xuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4uZmxhdE1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQucGFydHMgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29udGVudC5wYXJ0c1swXS50ZXh0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KG9yaWdpbik7XG4gICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRlbnQucGFydHNbMF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4ubWFwKChpdGVtKSA9PiB0Q29udGVudChpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG59XG5mdW5jdGlvbiB0Q29udGVudHMob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fFxuICAgICAgICBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIG9yaWdpbi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGVudHMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCdzIGEgc2luZ2xlIGNvbnRlbnQgb3IgYSBzaW5nbGUgUGFydFVuaW9uLlxuICAgICAgICBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSBpbiBhIENvbnRlbnQgb2JqZWN0LCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0Q29udGVudChvcmlnaW4pXTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGlzQ29udGVudEFycmF5ID0gX2lzQ29udGVudChvcmlnaW5bMF0pO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgaXNDb250ZW50ID0gX2lzQ29udGVudChpdGVtKTtcbiAgICAgICAgaWYgKGlzQ29udGVudCAhPSBpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXhpbmcgQ29udGVudCBhbmQgUGFydHMgaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIGdyb3VwIHRoZSBwYXJ0cyBpbnRvIGEgdGhlIGFwcHJvcHJpYXRlIENvbnRlbnQgb2JqZWN0cyBhbmQgc3BlY2lmeSB0aGUgcm9sZXMgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBgaXNDb250ZW50YCBjb250YWlucyB0aGUgcmVzdWx0IG9mIF9pc0NvbnRlbnQsIHdoaWNoIGlzIGEgdXRpbGl0eVxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGl0ZW0gaXMgYSBDb250ZW50LlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChpdGVtKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBzcGVjaWZ5IGZ1bmN0aW9uQ2FsbCBvciBmdW5jdGlvblJlc3BvbnNlIHBhcnRzLCBwbGVhc2Ugd3JhcCB0aGVtLCBhbmQgYW55IG90aGVyIHBhcnRzLCBpbiBDb250ZW50IG9iamVjdHMgYXMgYXBwcm9wcmlhdGUsIHNwZWNpZnlpbmcgdGhlIHJvbGUgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ29udGVudEFycmF5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgcm9sZTogJ3VzZXInLCBwYXJ0czogdFBhcnRzKGFjY3VtdWxhdGVkUGFydHMpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLypcblRyYW5zZm9ybSB0aGUgdHlwZSBmaWVsZCBmcm9tIGFuIGFycmF5IG9mIHR5cGVzIHRvIGFuIGFycmF5IG9mIGFueU9mIGZpZWxkcy5cbkV4YW1wbGU6XG4gIHt0eXBlOiBbJ1NUUklORycsICdOVU1CRVInXX1cbndpbGwgYmUgdHJhbnNmb3JtZWQgdG9cbiAge2FueU9mOiBbe3R5cGU6ICdTVFJJTkcnfSwge3R5cGU6ICdOVU1CRVInfV19XG4qL1xuZnVuY3Rpb24gZmxhdHRlblR5cGVBcnJheVRvQW55T2YodHlwZUxpc3QsIHJlc3VsdGluZ1NjaGVtYSkge1xuICAgIGlmICh0eXBlTGlzdC5pbmNsdWRlcygnbnVsbCcpKSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RXaXRob3V0TnVsbCA9IHR5cGVMaXN0LmZpbHRlcigodHlwZSkgPT4gdHlwZSAhPT0gJ251bGwnKTtcbiAgICBpZiAobGlzdFdpdGhvdXROdWxsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMobGlzdFdpdGhvdXROdWxsWzBdLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICA/IGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnYW55T2YnXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgbGlzdFdpdGhvdXROdWxsKSB7XG4gICAgICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10ucHVzaCh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGkudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgICAgICAgICAgPyBpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NKc29uU2NoZW1hKF9qc29uU2NoZW1hKSB7XG4gICAgY29uc3QgZ2VuQUlTY2hlbWEgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFGaWVsZE5hbWVzID0gWydpdGVtcyddO1xuICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZE5hbWVzID0gWydhbnlPZiddO1xuICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZE5hbWVzID0gWydwcm9wZXJ0aWVzJ107XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gJiYgX2pzb25TY2hlbWFbJ2FueU9mJ10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGFuZCBhbnlPZiBjYW5ub3QgYmUgYm90aCBwb3B1bGF0ZWQuJyk7XG4gICAgfVxuICAgIC8qXG4gICAgVGhpcyBpcyB0byBoYW5kbGUgdGhlIG51bGxhYmxlIGFycmF5IG9yIG9iamVjdC4gVGhlIF9qc29uU2NoZW1hIHdpbGxcbiAgICBiZSBpbiB0aGUgZm9ybWF0IG9mIHthbnlPZjogW3t0eXBlOiAnbnVsbCd9LCB7dHlwZTogJ29iamVjdCd9XX0uIFRoZVxuICAgIGxvZ2ljIGlzIHRvIGNoZWNrIGlmIGFueU9mIGhhcyAyIGVsZW1lbnRzIGFuZCBvbmUgb2YgdGhlIGVsZW1lbnQgaXMgbnVsbCxcbiAgICBpZiBzbywgdGhlIGFueU9mIGZpZWxkIGlzIHVubmVjZXNzYXJ5LCBzbyB3ZSBuZWVkIHRvIGdldCByaWQgb2YgdGhlIGFueU9mXG4gICAgZmllbGQgYW5kIG1ha2UgdGhlIHNjaGVtYSBudWxsYWJsZS4gVGhlbiB1c2UgdGhlIG90aGVyIGVsZW1lbnQgYXMgdGhlIG5ld1xuICAgIF9qc29uU2NoZW1hIGZvciBwcm9jZXNzaW5nLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGJhY2tlbmQgZG9lc24ndCBoYXZlIGEgbnVsbFxuICAgIHR5cGUuXG4gICAgVGhpcyBoYXMgdG8gYmUgY2hlY2tlZCBiZWZvcmUgd2UgcHJvY2VzcyBhbnkgb3RoZXIgZmllbGRzLlxuICAgIEZvciBleGFtcGxlOlxuICAgICAgY29uc3Qgb2JqZWN0TnVsbGFibGUgPSB6Lm9iamVjdCh7XG4gICAgICAgIG51bGxhYmxlQXJyYXk6IHouYXJyYXkoei5zdHJpbmcoKSkubnVsbGFibGUoKSxcbiAgICAgIH0pO1xuICAgIFdpbGwgaGF2ZSB0aGUgcmF3IF9qc29uU2NoZW1hIGFzOlxuICAgIHtcbiAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHt0eXBlOiAnbnVsbCd9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyAnbnVsbGFibGVBcnJheScgXSxcbiAgICB9XG4gICAgV2lsbCByZXN1bHQgaW4gZm9sbG93aW5nIHNjaGVtYSBjb21wYXRpYmxlIHdpdGggR2VtaW5pIEFQSTpcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ09CSkVDVCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgbnVsbGFibGVBcnJheToge1xuICAgICAgICAgICAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ0FSUkFZJyxcbiAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgICB9XG4gICAgKi9cbiAgICBjb25zdCBpbmNvbWluZ0FueU9mID0gX2pzb25TY2hlbWFbJ2FueU9mJ107XG4gICAgaWYgKGluY29taW5nQW55T2YgIT0gbnVsbCAmJiBpbmNvbWluZ0FueU9mLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ0FueU9mWzBdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluY29taW5nQW55T2ZbMV1bJ3R5cGUnXSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICBfanNvblNjaGVtYSA9IGluY29taW5nQW55T2ZbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmbGF0dGVuVHlwZUFycmF5VG9BbnlPZihfanNvblNjaGVtYVsndHlwZSddLCBnZW5BSVNjaGVtYSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoX2pzb25TY2hlbWEpKSB7XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIGZpZWxkdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZE5hbWUgPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlOiBudWxsIGNhbiBub3QgYmUgdGhlIG9ubHkgcG9zc2libGUgdHlwZSBmb3IgdGhlIGZpZWxkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIHRoZSB0eXBlIGZpZWxkIHdpdGggYXJyYXkgb2YgdHlwZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsndHlwZSddID0gT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgPyBmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIHByb2Nlc3NKc29uU2NoZW1hKGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZFZhbHVlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtWyd0eXBlJ10gPT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlLnB1c2gocHJvY2Vzc0pzb25TY2hlbWEoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9XG4gICAgICAgICAgICAgICAgbGlzdFNjaGVtYUZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGljdFNjaGVtYUZpZWxkTmFtZXMuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZGljdFNjaGVtYUZpZWxkVmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGljdFNjaGVtYUZpZWxkVmFsdWVba2V5XSA9IHByb2Nlc3NKc29uU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgaXMgbm90IGluY2x1ZGVkIGluIEpTT05TY2hlbWEsIHNraXBwaW5nIGl0LlxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbkFJU2NoZW1hO1xufVxuLy8gd2UgdGFrZSB0aGUgdW5rbm93biBpbiB0aGUgc2NoZW1hIGZpZWxkIGJlY2F1c2Ugd2Ugd2FudCBlbmFibGUgdXNlciB0byBwYXNzXG4vLyB0aGUgb3V0cHV0IG9mIG1ham9yIHNjaGVtYSBkZWNsYXJhdGlvbiB0b29scyB3aXRob3V0IGNhc3RpbmcuIFRvb2xzIHN1Y2ggYXNcbi8vIHpvZFRvSnNvblNjaGVtYSwgdHlwZWJveCwgem9kVG9Kc29uU2NoZW1hIGZ1bmN0aW9uIGNhbiByZXR1cm4gSnNvblNjaGVtYTdUeXBlXG4vLyBvciBvYmplY3QsIHNlZSBkZXRhaWxzIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vU3RlZmFuVGVyZGVsbC96b2QtdG8tanNvbi1zY2hlbWEvYmxvYi83MDUyNWVmZTU1NWNkMjI2NjkxZTA5M2QxNzEzNzBhM2IxMDkyMWQxL3NyYy96b2RUb0pzb25TY2hlbWEudHMjTDdcbi8vIHR5cGVib3ggY2FuIHJldHVybiB1bmtub3duLCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmNsYWlyeng4MS90eXBlYm94L2Jsb2IvNWE1NDMxNDM5ZjdkNWNhNmI0OTRkMGQxOGZiZmQ3YjFhMzU2ZDY3Yy9zcmMvdHlwZS9jcmVhdGUvdHlwZS50cyNMMzVcbi8vIE5vdGU6IHByb3BlciBqc29uIHNjaGVtYXMgd2l0aCB0aGUgJHNjaGVtYSBmaWVsZCBzZXQgbmV2ZXIgYXJyaXZlIHRvIHRoaXNcbi8vIHRyYW5zZm9ybWVyLiBTY2hlbWFzIHdpdGggJHNjaGVtYSBhcmUgcm91dGVkIHRvIHRoZSBlcXVpdmFsZW50IEFQSSBqc29uXG4vLyBzY2hlbWEgZmllbGQuXG5mdW5jdGlvbiB0U2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBwcm9jZXNzSnNvblNjaGVtYShzY2hlbWEpO1xufVxuZnVuY3Rpb24gdFNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZvaWNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgcHJlYnVpbHRWb2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICB2b2ljZU5hbWU6IHNwZWVjaENvbmZpZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3BlZWNoQ29uZmlnIHR5cGU6ICR7dHlwZW9mIHNwZWVjaENvbmZpZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0TGl2ZVNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyBpbiBzcGVlY2hDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBsaXZlIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbn1cbmZ1bmN0aW9uIHRUb29sKHRvb2wpIHtcbiAgICBpZiAodG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gb2YgdG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlID0gcHJvY2Vzc0pzb25TY2hlbWEoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2VKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b29sO1xufVxuZnVuY3Rpb24gdFRvb2xzKHRvb2xzKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGluY29taW5nIHR5cGUgaXMgZGVmaW5lZC5cbiAgICBpZiAodG9vbHMgPT09IHVuZGVmaW5lZCB8fCB0b29scyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29scykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBhcnJheSBvZiBUb29scycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9vbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFByZXBlbmRzIHJlc291cmNlIG5hbWUgd2l0aCBwcm9qZWN0LCBsb2NhdGlvbiwgcmVzb3VyY2VfcHJlZml4IGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBBUEkgY2xpZW50LlxuICogQHBhcmFtIHJlc291cmNlTmFtZSBUaGUgcmVzb3VyY2UgbmFtZS5cbiAqIEBwYXJhbSByZXNvdXJjZVByZWZpeCBUaGUgcmVzb3VyY2UgcHJlZml4LlxuICogQHBhcmFtIHNwbGl0c0FmdGVyUHJlZml4IFRoZSBudW1iZXIgb2Ygc3BsaXRzIGFmdGVyIHRoZSBwcmVmaXguXG4gKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIHJlc291cmNlIG5hbWUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9iYXIvbG9jYXRpb25zL3VzLXdlc3QxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJucyAnY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3NvbWUvd3JvbmcvY2FjaGVkQ29udGVudHMvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqICMgY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiAtPiAnc29tZS93cm9uZy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXNvdXJjZU5hbWUoY2xpZW50LCByZXNvdXJjZU5hbWUsIHJlc291cmNlUHJlZml4LCBzcGxpdHNBZnRlclByZWZpeCA9IDEpIHtcbiAgICBjb25zdCBzaG91bGRBcHBlbmRQcmVmaXggPSAhcmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApICYmXG4gICAgICAgIHJlc291cmNlTmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PT0gc3BsaXRzQWZ0ZXJQcmVmaXg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgnbG9jYXRpb25zLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG59XG5mdW5jdGlvbiB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lKGFwaUNsaWVudCwgbmFtZSwgJ2NhY2hlZENvbnRlbnRzJyk7XG59XG5mdW5jdGlvbiB0VHVuaW5nSm9iU3RhdHVzKHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ1NUQVRFX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICAgICAgY2FzZSAnQ1JFQVRJTkcnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUlVOTklORyc7XG4gICAgICAgIGNhc2UgJ0FDVElWRSc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9TVUNDRUVERUQnO1xuICAgICAgICBjYXNlICdGQUlMRUQnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRkFJTEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSB7XG4gICAgcmV0dXJuIHRCeXRlcyQxKGZyb21JbWFnZUJ5dGVzKTtcbn1cbmZ1bmN0aW9uIF9pc0ZpbGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ25hbWUnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZFZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd2aWRlbycgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW8ob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3VyaScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHRGaWxlTmFtZShmcm9tTmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAoX2lzRmlsZShmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLm5hbWU7XG4gICAgfVxuICAgIGlmIChpc1ZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWUudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0dlbmVyYXRlZFZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gKF9hID0gZnJvbU5hbWUudmlkZW8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmk7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcm9tTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0LicpO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN1ZmZpeC5tYXRjaCgvW2EtejAtOV0rLyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0cmFjdCBmaWxlIG5hbWUgZnJvbSBVUkkgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBtYXRjaFswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnZmlsZXMvJylbMV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gdE1vZGVsc1VybChhcGlDbGllbnQsIGJhc2VNb2RlbHMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJyA6ICdtb2RlbHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0gYmFzZU1vZGVscyA/ICdtb2RlbHMnIDogJ3R1bmVkTW9kZWxzJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRFeHRyYWN0TW9kZWxzKHJlc3BvbnNlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydtb2RlbHMnLCAndHVuZWRNb2RlbHMnLCAncHVibGlzaGVyTW9kZWxzJ10pIHtcbiAgICAgICAgaWYgKGhhc0ZpZWxkKHJlc3BvbnNlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBoYXNGaWVsZChkYXRhLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZmllbGROYW1lIGluIGRhdGE7XG59XG5mdW5jdGlvbiBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtY3BUb29sU2NoZW1hID0gbWNwVG9vbDtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBtY3BUb29sU2NoZW1hWyduYW1lJ10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtY3BUb29sU2NoZW1hWydkZXNjcmlwdGlvbiddLFxuICAgICAgICBwYXJhbWV0ZXJzSnNvblNjaGVtYTogbWNwVG9vbFNjaGVtYVsnaW5wdXRTY2hlbWEnXSxcbiAgICB9O1xuICAgIGlmIChtY3BUb29sU2NoZW1hWydvdXRwdXRTY2hlbWEnXSkge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydyZXNwb25zZUpzb25TY2hlbWEnXSA9IG1jcFRvb2xTY2hlbWFbJ291dHB1dFNjaGVtYSddO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmJlaGF2aW9yKSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25bJ2JlaGF2aW9yJ10gPSBjb25maWcuYmVoYXZpb3I7XG4gICAgfVxuICAgIGNvbnN0IGdlbWluaVRvb2wgPSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICBdLFxuICAgIH07XG4gICAgcmV0dXJuIGdlbWluaVRvb2w7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBNQ1AgdG9vbHMgdG8gYSBzaW5nbGUgR2VtaW5pIHRvb2wgd2l0aCBhIGxpc3Qgb2YgZnVuY3Rpb25cbiAqIGRlY2xhcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWNwVG9vbHNUb0dlbWluaVRvb2wobWNwVG9vbHMsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBjb25zdCB0b29sTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBtY3BUb29sIG9mIG1jcFRvb2xzKSB7XG4gICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICBpZiAodG9vbE5hbWVzLmhhcyhtY3BUb29sTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbE5hbWVzLmFkZChtY3BUb29sTmFtZSk7XG4gICAgICAgIGNvbnN0IGdlbWluaVRvb2wgPSBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnKTtcbiAgICAgICAgaWYgKGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zLnB1c2goLi4uZ2VtaW5pVG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IGZ1bmN0aW9uRGVjbGFyYXRpb25zIH07XG59XG4vLyBUcmFuc2Zvcm1zIGEgc291cmNlIGlucHV0IGludG8gYSBCYXRjaEpvYlNvdXJjZSBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uLlxuZnVuY3Rpb24gdEJhdGNoSm9iU291cmNlKGNsaWVudCwgc3JjKSB7XG4gICAgbGV0IHNvdXJjZU9iajtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnanNvbmwnLCBnY3NVcmk6IFtzcmNdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcmMuc3RhcnRzV2l0aCgnYnE6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnYmlncXVlcnknLCBiaWdxdWVyeVVyaTogc3JjIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN0cmluZyBzb3VyY2UgZm9yIFZlcnRleCBBSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNTERFVlxuICAgICAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZmlsZU5hbWU6IHNyYyB9OyAvLyBEZWZhdWx0IHRvIGZpbGVOYW1lIGZvciBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3RyaW5nIHNvdXJjZSBmb3IgR2VtaW5pIEFQSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lubGluZWRSZXF1ZXN0W10gaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlT2JqID0geyBpbmxpbmVkUmVxdWVzdHM6IHNyYyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhbHJlYWR5IGEgQmF0Y2hKb2JTb3VyY2Ugb2JqZWN0XG4gICAgICAgIHNvdXJjZU9iaiA9IHNyYztcbiAgICB9XG4gICAgLy8gVmFsaWRhdGlvbiBsb2dpY1xuICAgIGNvbnN0IHZlcnRleFNvdXJjZXNDb3VudCA9IFtzb3VyY2VPYmouZ2NzVXJpLCBzb3VyY2VPYmouYmlncXVlcnlVcmldLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgY29uc3QgbWxkZXZTb3VyY2VzQ291bnQgPSBbXG4gICAgICAgIHNvdXJjZU9iai5pbmxpbmVkUmVxdWVzdHMsXG4gICAgICAgIHNvdXJjZU9iai5maWxlTmFtZSxcbiAgICBdLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1sZGV2U291cmNlc0NvdW50ID4gMCB8fCB2ZXJ0ZXhTb3VyY2VzQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhhY3RseSBvbmUgb2YgYGdjc1VyaWAgb3IgYGJpZ3F1ZXJ5VXJpYCBtdXN0IGJlIHNldCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNTERFVlxuICAgICAgICBpZiAodmVydGV4U291cmNlc0NvdW50ID4gMCB8fCBtbGRldlNvdXJjZXNDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGFjdGx5IG9uZSBvZiBgaW5saW5lZFJlcXVlc3RzYCwgYGZpbGVOYW1lYCwgJyArXG4gICAgICAgICAgICAgICAgJ211c3QgYmUgc2V0IGZvciBHZW1pbmkgQVBJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VPYmo7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgY29uc3QgZGVzdFN0cmluZyA9IGRlc3Q7XG4gICAgaWYgKGRlc3RTdHJpbmcuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAnanNvbmwnLFxuICAgICAgICAgICAgZ2NzVXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2JpZ3F1ZXJ5JyxcbiAgICAgICAgICAgIGJpZ3F1ZXJ5VXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZXN0aW5hdGlvbjogJHtkZXN0U3RyaW5nfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgLy8gRW5zdXJlIGRlc3QgaXMgYSBub24tbnVsbCBvYmplY3QgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnb2JqZWN0JyB8fCBkZXN0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBub3QgYW4gb2JqZWN0LCBpdCBjYW5ub3QgYmUgYSB2YWxpZCBCYXRjaEpvYkRlc3RpbmF0aW9uXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBvcGVyYXRpb25zIHBlcmZvcm1lZC4gUmV0dXJuIGl0IGNhc3QsIG9yIGhhbmRsZSBhcyBhbiBlcnJvci5cbiAgICAgICAgLy8gQ2FzdGluZyBhbiBlbXB0eSBvYmplY3QgbWlnaHQgYmUgYSBzYWZlIGRlZmF1bHQuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLy8gQ2FzdCB0byBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB0byBhbGxvdyBzdHJpbmcgcHJvcGVydHkgYWNjZXNzLlxuICAgIGNvbnN0IG9iaiA9IGRlc3Q7XG4gICAgLy8gU2FmZWx5IGFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNWYWwgPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAodHlwZW9mIGlubGluZVJlc3BvbnNlc1ZhbCAhPT0gJ29iamVjdCcgfHwgaW5saW5lUmVzcG9uc2VzVmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNPYmogPSBpbmxpbmVSZXNwb25zZXNWYWw7XG4gICAgY29uc3QgcmVzcG9uc2VzQXJyYXkgPSBpbmxpbmVSZXNwb25zZXNPYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcG9uc2VzQXJyYXkpIHx8IHJlc3BvbnNlc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IHJlc3BvbnNlIGhhcyB0aGUgJ2VtYmVkZGluZycgcHJvcGVydHkuXG4gICAgbGV0IGhhc0VtYmVkZGluZyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2VJdGVtIG9mIHJlc3BvbnNlc0FycmF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VJdGVtICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZUl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSXRlbU9iaiA9IHJlc3BvbnNlSXRlbTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWwgPSByZXNwb25zZUl0ZW1PYmpbJ3Jlc3BvbnNlJ107XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VWYWwgIT09ICdvYmplY3QnIHx8IHJlc3BvbnNlVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZU9iaiA9IHJlc3BvbnNlVmFsO1xuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgJ2VtYmVkZGluZycga2V5LlxuICAgICAgICBpZiAocmVzcG9uc2VPYmpbJ2VtYmVkZGluZyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0VtYmVkZGluZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQZXJmb3JtIHRoZSB0cmFuc2Zvcm1hdGlvbiBpZiBhbiBlbWJlZGRpbmcgd2FzIGZvdW5kLlxuICAgIGlmIChoYXNFbWJlZGRpbmcpIHtcbiAgICAgICAgb2JqWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10gPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICAgICAgZGVsZXRlIG9ialsnaW5saW5lZFJlc3BvbnNlcyddO1xuICAgIH1cbiAgICAvLyBDYXN0IHRoZSAocG90ZW50aWFsbHkpIG1vZGlmaWVkIG9iamVjdCB0byB0aGUgdGFyZ2V0IHR5cGUuXG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBuYW1lO1xuICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCBtbGRldlBhdHRlcm4gPSAvYmF0Y2hlc1xcL1teL10rJC87XG4gICAgICAgIGlmIChtbGRldlBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmcuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXRjaCBqb2IgbmFtZTogJHtuYW1lU3RyaW5nfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJ0ZXhQYXR0ZXJuID0gL15wcm9qZWN0c1xcL1teL10rXFwvbG9jYXRpb25zXFwvW14vXStcXC9iYXRjaFByZWRpY3Rpb25Kb2JzXFwvW14vXSskLztcbiAgICBpZiAodmVydGV4UGF0dGVybi50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdEpvYlN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfVU5TUEVDSUZJRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1BFTkRJTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1BFTkRJTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1JVTk5JTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1JVTk5JTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1NVQ0NFRURFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9GQUlMRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfQ0FOQ0VMTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9DQU5DRUxMRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0VYUElSRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0VYUElSRUQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3RyaW5nO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlc0ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVzcG9uc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgICAgICdpbmxpbmVkUmVzcG9uc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXNwb25zZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXNwb25zZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2NzRGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpUHJlZml4JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlEZXN0aW5hdGlvbicsXG4gICAgICAgICdvdXRwdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZGljdGlvbnNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc0Rlc3RpbmF0aW9uJywgJ291dHB1dFVyaVByZWZpeCddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlEZXN0aW5hdGlvbicsICdvdXRwdXRVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lZFJlc3BvbnNlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5saW5lZFJlc3BvbnNlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnZGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0Sm9iU3RhdGUoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnY3JlYXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnZW5kVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAndXBkYXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdvdXRwdXQnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbU1sZGV2KHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0Sm9iU3RhdGUoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5wdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcmMnXSwgYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4KGZyb21TcmMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc3QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbmZpZyddKTtcbiAgICBpZiAoZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXN0J10sIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luc3RhbmNlc0Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzU291cmNlJywgJ3VyaXMnXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpZ3F1ZXJ5U291cmNlJyxcbiAgICAgICAgJ2lucHV0VXJpJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ3F1ZXJ5VXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVxdWVzdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkUmVxdWVzdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZFJlcXVlc3RzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVxdWVzdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZFJlcXVlc3RUb01sZGV2KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0cycsICdyZXF1ZXN0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc0Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzU291cmNlJywgJ3VyaXMnXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5U291cmNlJywgJ2lucHV0VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlTmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRSZXF1ZXN0cyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5saW5lZFJlcXVlc3RzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudCddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50J10sIGZyb21Db250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNpdGF0aW9uTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaXRhdGlvbk1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9uTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbk1ldGFkYXRhJ10sIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tQ2l0YXRpb25NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5Db3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoUmVhc29uJ10pO1xuICAgIGlmIChmcm9tRmluaXNoUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoUmVhc29uJ10sIGZyb21GaW5pc2hSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXZnTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tQXZnTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdmdMb2dwcm9icyddLCBmcm9tQXZnTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdncm91bmRpbmdNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hcm91bmRpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dyb3VuZGluZ01ldGFkYXRhJ10sIGZyb21Hcm91bmRpbmdNZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5kZXgnXSk7XG4gICAgaWYgKGZyb21JbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luZGV4J10sIGZyb21JbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9ic1Jlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvZ3Byb2JzUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnNSZXN1bHQnXSwgZnJvbUxvZ3Byb2JzUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVJhdGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlSYXRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNhZmV0eVJhdGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVJhdGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eVJhdGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHRNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybENvbnRleHRNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0TWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0TWV0YWRhdGEnXSwgZnJvbVVybENvbnRleHRNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvblNvdXJjZXMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNpdGF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQ0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydiYXRjaCcsICdkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXN0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc3QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc3QnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ291dHB1dENvbmZpZyddLCBiYXRjaEpvYkRlc3RpbmF0aW9uVG9WZXJ0ZXgodEJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcmMnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaCcsICdpbnB1dENvbmZpZyddLCBiYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCB0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBmcm9tU3JjKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcmMnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnB1dENvbmZpZyddLCBiYXRjaEpvYlNvdXJjZVRvVmVydGV4KHRCYXRjaEpvYlNvdXJjZShhcGlDbGllbnQsIGZyb21TcmMpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JhdGNoJywgJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2gnLCAnaW5wdXRDb25maWcnXSwgZW1iZWRkaW5nc0JhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIGZyb21TcmMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVSZXNvdXJjZUpvYkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50QmF0Y2hUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdyZXF1ZXN0JywgJ2NvbnRlbnQnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3NlbGYnXSwgZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiQxKGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgICAgIG1vdmVWYWx1ZUJ5UGF0aCh0b09iamVjdCwgeyAncmVxdWVzdHNbXS4qJzogJ3JlcXVlc3RzW10ucmVxdWVzdC4qJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGFza1R5cGUnXSwgZnJvbVRhc2tUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRvVHJ1bmNhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRkaW5nc0JhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVfbmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlcXVlc3RzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlcXVlc3RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXF1ZXN0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzJ10sIGVtYmVkQ29udGVudEJhdGNoVG9NbGRldihhcGlDbGllbnQsIGZyb21JbmxpbmVkUmVxdWVzdHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDQodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCB0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDQodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIGZyb21Ub29sQ29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCB0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgZnJvbUltYWdlQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUZyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVxdWVzdFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkNChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYkMShhcGlDbGllbnQsIGZyb21Db25maWcsIGdldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnXSwge30pKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGlubGluZWRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3BlcmF0aW9ucyddKTtcbiAgICBpZiAoZnJvbUJhdGNoSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQmF0Y2hKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2hKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaEpvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiYXRjaFByZWRpY3Rpb25Kb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJhdGNoSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQmF0Y2hKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSm9iRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkNChmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQ0KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5U2V0dGluZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRob2QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldiQ0KGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkNChmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBQYWdlZEl0ZW07XG4oZnVuY3Rpb24gKFBhZ2VkSXRlbSkge1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQkFUQ0hfSk9CU1wiXSA9IFwiYmF0Y2hKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9NT0RFTFNcIl0gPSBcIm1vZGVsc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fVFVOSU5HX0pPQlNcIl0gPSBcInR1bmluZ0pvYnNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0ZJTEVTXCJdID0gXCJmaWxlc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTXCJdID0gXCJjYWNoZWRDb250ZW50c1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fUkFHX1NUT1JFU1wiXSA9IFwicmFnU3RvcmVzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9ET0NVTUVOVFNcIl0gPSBcImRvY3VtZW50c1wiO1xufSkoUGFnZWRJdGVtIHx8IChQYWdlZEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBQYWdlciBjbGFzcyBmb3IgaXRlcmF0aW5nIHRocm91Z2ggcGFnaW5hdGVkIHJlc3VsdHMuXG4gKi9cbmNsYXNzIFBhZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gW107XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSB7fTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SW50ZXJuYWwgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLm5hbWVJbnRlcm5hbCA9IG5hbWU7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gcmVzcG9uc2VbdGhpcy5uYW1lSW50ZXJuYWxdIHx8IFtdO1xuICAgICAgICB0aGlzLnNka0h0dHBSZXNwb25zZUludGVybmFsID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZTtcbiAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCA9IDA7XG4gICAgICAgIGxldCByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIGlmICghcGFyYW1zIHx8IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdFBhcmFtc1snY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddWydwYWdlVG9rZW4nXSA9IHJlc3BvbnNlWyduZXh0UGFnZVRva2VuJ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHJlcXVlc3RQYXJhbXM7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsU2l6ZSA9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSByZXF1ZXN0UGFyYW1zWydjb25maWcnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydwYWdlU2l6ZSddKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIGluaXROZXh0UGFnZShyZXNwb25zZSkge1xuICAgICAgICB0aGlzLmluaXQodGhpcy5uYW1lSW50ZXJuYWwsIHJlc3BvbnNlLCB0aGlzLnBhcmFtc0ludGVybmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwYWdlLCB3aGljaCBpcyBhIGxpc3Qgb2YgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBmaXJzdCBwYWdlIGlzIHJldHJpZXZlZCB3aGVuIHRoZSBwYWdlciBpcyBjcmVhdGVkLiBUaGUgcmV0dXJuZWQgbGlzdCBvZlxuICAgICAqIGl0ZW1zIGNvdWxkIGJlIGEgc3Vic2V0IG9mIHRoZSBlbnRpcmUgbGlzdC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHBhZ2VkIGl0ZW0gKGZvciBleGFtcGxlLCBgYGJhdGNoX2pvYnNgYCkuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwYWdlIGZldGNoZWQgZWFjaCB0aW1lIGJ5IHRoaXMgcGFnZXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBhZ2UgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwYWdlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlYWRlcnMgb2YgdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgc2RrSHR0cFJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZGtIdHRwUmVzcG9uc2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVycyB3aGVuIG1ha2luZyB0aGUgQVBJIHJlcXVlc3QgZm9yIHRoZSBuZXh0IHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBhcmFtZXRlcnMgY29udGFpbiBhIHNldCBvZiBvcHRpb25hbCBjb25maWdzIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBjdXN0b21pemUgdGhlIEFQSSByZXF1ZXN0LiBGb3IgZXhhbXBsZSwgdGhlIGBwYWdlVG9rZW5gIHBhcmFtZXRlclxuICAgICAqIGNvbnRhaW5zIHRoZSB0b2tlbiB0byByZXF1ZXN0IHRoZSBuZXh0IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqL1xuICAgIGdldCBwYWdlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRJdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFtpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IgdGhhdCBzdXBwb3J0IGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBpdGVtc1xuICAgICAqIHJldHJpZXZlZCBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBpdGVyYXRvciB3aWxsIGF1dG9tYXRpY2FsbHkgZmV0Y2ggdGhlIG5leHQgcGFnZSBpZiB0aGVyZSBhcmUgbW9yZSBpdGVtc1xuICAgICAqIHRvIGZldGNoIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBwYWdlcikge1xuICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHhJbnRlcm5hbCA+PSB0aGlzLnBhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uZXh0UGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0odGhpcy5pZHhJbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG5leHQgcGFnZSBvZiBpdGVtcy4gVGhpcyBtYWtlcyBhIG5ldyBBUEkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBhcmUgbm8gbW9yZSBwYWdlcyB0byBmZXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGxldCBwYWdlID0gcGFnZXIucGFnZTtcbiAgICAgKiB3aGlsZSAodHJ1ZSkge1xuICAgICAqICAgZm9yIChjb25zdCBmaWxlIG9mIHBhZ2UpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIGlmICghcGFnZXIuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAqICAgICBicmVhaztcbiAgICAgKiAgIH1cbiAgICAgKiAgIHBhZ2UgPSBhd2FpdCBwYWdlci5uZXh0UGFnZSgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBuZXh0UGFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9yZSBwYWdlcyB0byBmZXRjaC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdEludGVybmFsKHRoaXMucGFyYW1zKTtcbiAgICAgICAgdGhpcy5pbml0TmV4dFBhZ2UocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgcGFnZXMgdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqL1xuICAgIGhhc05leHRQYWdlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5wYXJhbXNbJ2NvbmZpZyddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3BhZ2VUb2tlbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXRjaGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmJhdGNoZXMuY3JlYXRlKHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIHNyYzoge2djc1VyaTogJ2dzOi8vYnVja2V0L3BhdGgvdG8vZmlsZS5qc29ubCcsIGZvcm1hdDogJ2pzb25sJ30sXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBkZXN0OiB7Z2NzVXJpOiAnZ3M6Ly9idWNrZXQvcGF0aC9vdXRwdXQvZGlyZWN0b3J5JywgZm9ybWF0OiAnanNvbmwnfSxcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGUgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9ybWF0IGRlc3RpbmF0aW9uIGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgIC8vIENhc3QgcGFyYW1zLnNyYyBhcyBWZXJ0ZXggQUkgcGF0aCBkb2VzIG5vdCBoYW5kbGUgSW5saW5lZFJlcXVlc3RbXVxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcgPSB0aGlzLmZvcm1hdERlc3RpbmF0aW9uKHBhcmFtcy5zcmMsIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqRXhwZXJpbWVudGFsKiogQ3JlYXRlcyBhbiBlbWJlZGRpbmcgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBlbWJlZGRpbmcgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmJhdGNoZXMuY3JlYXRlRW1iZWRkaW5ncyh7XG4gICAgICAgICAqICAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAgICAgKiAgIHNyYzoge2ZpbGVOYW1lOiAnZmlsZXMvbXlfZW1iZWRkaW5nX2lucHV0J30sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVFbWJlZGRpbmdzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdiYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3MoKSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggQUkgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFbWJlZGRpbmdzSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGJhdGNoIGpvYiBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBwYWdpbmF0ZWQgcmVzdWx0cyBvZiB0aGUgbGlzdCBvZiBiYXRjaCBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBiYXRjaEpvYnMgPSBhd2FpdCBhaS5iYXRjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgYmF0Y2hKb2Igb2YgYmF0Y2hKb2JzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coYmF0Y2hKb2IpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0JBVENIX0pPQlMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBpbmxpbmVkIGdlbmVyYXRlIGNvbnRlbnQgcmVxdWVzdHNcbiAgICBjcmVhdGVJbmxpbmVkR2VuZXJhdGVDb250ZW50UmVxdWVzdChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIC8vIFVzZSBpbnN0YW5jZSBhcGlDbGllbnRcbiAgICAgICAgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gYm9keVsnX3VybCddO1xuICAgICAgICBjb25zdCBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoR2VuZXJhdGVDb250ZW50JywgdXJsUGFyYW1zKTtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBib2R5WydiYXRjaCddO1xuICAgICAgICBjb25zdCBpbnB1dENvbmZpZyA9IGJhdGNoWydpbnB1dENvbmZpZyddO1xuICAgICAgICBjb25zdCByZXF1ZXN0c1dyYXBwZXIgPSBpbnB1dENvbmZpZ1sncmVxdWVzdHMnXTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSByZXF1ZXN0c1dyYXBwZXJbJ3JlcXVlc3RzJ107XG4gICAgICAgIGNvbnN0IG5ld1JlcXVlc3RzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdERpY3QgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KTsgLy8gQ2xvbmVcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5c3RlbUluc3RydWN0aW9uVmFsdWUgPSByZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ3N5c3RlbUluc3RydWN0aW9uJ107XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdENvbnRlbnQgPSByZXF1ZXN0RGljdFsncmVxdWVzdCddO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RDb250ZW50WydzeXN0ZW1JbnN0cnVjdGlvbiddID0gc3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGljdFsncmVxdWVzdCddID0gcmVxdWVzdENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSZXF1ZXN0cy5wdXNoKHJlcXVlc3REaWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0c1dyYXBwZXJbJ3JlcXVlc3RzJ10gPSBuZXdSZXF1ZXN0cztcbiAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgIHJldHVybiB7IHBhdGgsIGJvZHkgfTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgZmlyc3QgR0NTIFVSSVxuICAgIGdldEdjc1VyaShzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLnN0YXJ0c1dpdGgoJ2dzOi8vJykgPyBzcmMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykgJiYgc3JjLmdjc1VyaSAmJiBzcmMuZ2NzVXJpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuZ2NzVXJpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIEJpZ1F1ZXJ5IFVSSVxuICAgIGdldEJpZ3F1ZXJ5VXJpKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuc3RhcnRzV2l0aCgnYnE6Ly8nKSA/IHNyYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5iaWdxdWVyeVVyaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBGdW5jdGlvbiB0byBmb3JtYXQgdGhlIGRlc3RpbmF0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIFZlcnRleCBBSVxuICAgIGZvcm1hdERlc3RpbmF0aW9uKHNyYywgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IGNvbmZpZyA/IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZykgOiB7fTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wU3RyID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xuICAgICAgICBpZiAoIW5ld0NvbmZpZy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgbmV3Q29uZmlnLmRpc3BsYXlOYW1lID0gYGdlbmFpQmF0Y2hKb2JfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLmRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZ2NzVXJpID0gdGhpcy5nZXRHY3NVcmkoc3JjKTtcbiAgICAgICAgICAgIGNvbnN0IGJpZ3F1ZXJ5VXJpID0gdGhpcy5nZXRCaWdxdWVyeVVyaShzcmMpO1xuICAgICAgICAgICAgaWYgKGdjc1VyaSkge1xuICAgICAgICAgICAgICAgIGlmIChnY3NVcmkuZW5kc1dpdGgoJy5qc29ubCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciAuanNvbmwgZmlsZXMsIHJlbW92ZSBzdWZmaXggYW5kIGFkZCAvZGVzdFxuICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcuZGVzdCA9IGAke2djc1VyaS5zbGljZSgwLCAtNil9L2Rlc3RgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG90aGVyIEdDUyBVUklzXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7Z2NzVXJpfV9kZXN0XyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmlncXVlcnlVcmkpIHtcbiAgICAgICAgICAgICAgICBuZXdDb25maWcuZGVzdCA9IGAke2JpZ3F1ZXJ5VXJpfV9kZXN0XyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNvdXJjZSBmb3IgVmVydGV4IEFJOiBObyBHQ1Mgb3IgQmlnUXVlcnkgVVJJIGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hHZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFbWJlZGRpbmdzSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTphc3luY0JhdGNoRW1iZWRDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGJhdGNoIGpvYiBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmdldCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY2FuY2VsIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmNhbmNlbCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RCYXRjaEpvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuZGVsZXRlKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlUmVzb3VyY2VKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDModENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgZnJvbVRvb2xDb25maWcpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydrbXNLZXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrbXNLZXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIGZyb21Ub29sQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUttc0tleU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ttc0tleU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21LbXNLZXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2VuY3J5cHRpb25fc3BlYycsICdrbXNLZXlOYW1lJ10sIGZyb21LbXNLZXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZWRDb250ZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVkQ29udGVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQzKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDMoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkMyhmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBDYWNoZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBwYWdpbmF0ZWQgcmVzdWx0cyBvZiB0aGUgbGlzdCBvZiBjYWNoZWQgY29udGVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGNhY2hlZENvbnRlbnRzID0gYXdhaXQgYWkuY2FjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2FjaGVkQ29udGVudCBvZiBjYWNoZWRDb250ZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGNhY2hlZENvbnRlbnQpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGVkIGNvbnRlbnRzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb250ZXh0IGNhY2hpbmcgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHNwZWNpZmljIG1vZGVscy4gU2VlIFtHZW1pbmlcbiAgICAgKiBEZXZlbG9wZXIgQVBJIHJlZmVyZW5jZV0oaHR0cHM6Ly9haS5nb29nbGUuZGV2L2dlbWluaS1hcGkvZG9jcy9jYWNoaW5nP2xhbmc9bm9kZS9jb250ZXh0LWNhYylcbiAgICAgKiBhbmQgW1ZlcnRleCBBSSByZWZlcmVuY2VdKGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZ2VuZXJhdGl2ZS1haS9kb2NzL2NvbnRleHQtY2FjaGUvY29udGV4dC1jYWNoZS1vdmVydmlldyNzdXBwb3J0ZWRfbW9kZWxzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250ZW50cyA9IC4uLjsgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGVudCB0byBjYWNoZS5cbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAnY29udGVudHMnOiBjb250ZW50cyxcbiAgICAgKiAgICAnZGlzcGxheU5hbWUnOiAndGVzdCBjYWNoZScsXG4gICAgICogICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgdHdvIHBkZnM/JyxcbiAgICAgKiAgICAndHRsJzogJzg2NDAwcycsXG4gICAgICogIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdXBkYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy51cGRhdGUoe1xuICAgICAqICAgbmFtZTogJy4uLicsICAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqICAgY29uZmlnOiB7J3R0bCc6ICc3NjAwcyd9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyA9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gKF9hID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkQ29udGVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC5wYXJ0cyA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhwYXJ0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBoaXN0b3J5IGNvbnRhaW5zIHRoZSBjb3JyZWN0IHJvbGVzLlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHVzZXIgdHVybi5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgY29udGFpbnMgYW4gaW52YWxpZCByb2xlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIC8vIEVtcHR5IGhpc3RvcnkgaXMgdmFsaWQuXG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucm9sZSAhPT0gJ3VzZXInICYmIGNvbnRlbnQucm9sZSAhPT0gJ21vZGVsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb2xlIG11c3QgYmUgdXNlciBvciBtb2RlbCwgYnV0IGdvdCAke2NvbnRlbnQucm9sZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBjdXJhdGVkICh2YWxpZCkgaGlzdG9yeSBmcm9tIGEgY29tcHJlaGVuc2l2ZSBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgbW9kZWwgbWF5IHNvbWV0aW1lcyBnZW5lcmF0ZSBpbnZhbGlkIG9yIGVtcHR5IGNvbnRlbnRzKGUuZy4sIGR1ZSB0byBzYWZ0eVxuICogZmlsdGVycyBvciByZWNpdGF0aW9uKS4gRXh0cmFjdGluZyB2YWxpZCB0dXJucyBmcm9tIHRoZSBoaXN0b3J5XG4gKiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBjb3VsZCBiZSBhY2NwZXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDdXJhdGVkSGlzdG9yeShjb21wcmVoZW5zaXZlSGlzdG9yeSkge1xuICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeSA9PT0gdW5kZWZpbmVkIHx8IGNvbXByZWhlbnNpdmVIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGN1cmF0ZWRIaXN0b3J5ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCguLi5tb2RlbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdXNlciBpbnB1dCB3aGVuIG1vZGVsIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyYXRlZEhpc3Rvcnk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBjcmVhdGUgYSBjaGF0IHNlc3Npb24uXG4gKi9cbmNsYXNzIENoYXRzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbHNNb2R1bGUsIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgY29uZmlnIGluIHRoZSBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgd2l0aGluIHRoZSBjaGF0XG4gICAgICogc2Vzc2lvbiB1bmxlc3Mgb3ZlcnJpZGRlbiBieSBhIHBlci1yZXF1ZXN0IGBjb25maWdgIGluXG4gICAgICogQHNlZSB7QGxpbmsgdHlwZXMuU2VuZE1lc3NhZ2VQYXJhbWV0ZXJzI2NvbmZpZ30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNoYXQgPSBhaS5jaGF0cy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICogICAgIG1heE91dHB1dFRva2VuczogMTAyNCxcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdCh0aGlzLmFwaUNsaWVudCwgdGhpcy5tb2RlbHNNb2R1bGUsIHBhcmFtcy5tb2RlbCwgcGFyYW1zLmNvbmZpZywgXG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShwYXJhbXMuaGlzdG9yeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hhdCBzZXNzaW9uIHRoYXQgZW5hYmxlcyBzZW5kaW5nIG1lc3NhZ2VzIHRvIHRoZSBtb2RlbCB3aXRoIHByZXZpb3VzXG4gKiBjb252ZXJzYXRpb24gY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNlc3Npb24gbWFpbnRhaW5zIGFsbCB0aGUgdHVybnMgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdCB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBtb2RlbHNNb2R1bGUsIG1vZGVsLCBjb25maWcgPSB7fSwgaGlzdG9yeSA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50IHRvIHRoZVxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlU3RyZWFtfSBmb3Igc3RyZWFtaW5nIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3Igc2VuZGluZyBtZXNzYWdlcyB3aXRoaW4gYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgQUZDIGlucHV0IGNvbnRhaW5zIHRoZSBlbnRpcmUgY3VyYXRlZCBjaGF0IGhpc3RvcnkgaW5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBuZXcgdXNlciBpbnB1dCwgd2UgbmVlZCB0byB0cnVuY2F0ZSB0aGUgQUZDIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIHRvIGRlZHVwbGljYXRlIHRoZSBleGlzdGluZyBjaGF0IGhpc3RvcnkuXG4gICAgICAgICAgICBjb25zdCBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SGlzdG9yeSh0cnVlKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgaWYgKGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnkuc2xpY2UoaW5kZXgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gb3V0cHV0Q29udGVudCA/IFtvdXRwdXRDb250ZW50XSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc2V0cyBzZW5kUHJvbWlzZSB0byBhdm9pZCBzdWJzZXF1ZW50IGNhbGxzIGZhaWxpbmdcbiAgICAgICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSBwcm9jZXNzZWQgYmVmb3JlXG4gICAgICogc2VuZGluZyB0aGUgbmV4dCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQ2hhdCNzZW5kTWVzc2FnZX0gZm9yIG5vbi1zdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAqICAgY29uc29sZS5sb2coY2h1bmsudGV4dCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2U7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IHRDb250ZW50KHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGludGVybmFsIHRyYWNraW5nIG9mIHNlbmQgY29tcGxldGlvbiBwcm9taXNlIC0gYHNlbmRQcm9taXNlYFxuICAgICAgICAvLyBmb3IgYm90aCBzdWNjZXNzIGFuZCBmYWlsdXJlIHJlc3BvbnNlLiBUaGUgYWN0dWFsIGZhaWx1cmUgaXMgc3RpbGxcbiAgICAgICAgLy8gcHJvcGFnYXRlZCBieSB0aGUgYGF3YWl0IHN0cmVhbVJlc3BvbnNlYC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IHN0cmVhbVJlc3BvbnNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdHJlYW1SZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGlucHV0Q29udGVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGhpc3RvcnkgaXMgYSBsaXN0IG9mIGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGhpc3Rvcnk6XG4gICAgICogLSBUaGUgYGN1cmF0ZWQgaGlzdG9yeWAgY29udGFpbnMgb25seSB0aGUgdmFsaWQgdHVybnMgYmV0d2VlbiB1c2VyIGFuZFxuICAgICAqIG1vZGVsLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG1vZGVsLlxuICAgICAqIC0gVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGNvbnRhaW5zIGFsbCB0dXJucywgaW5jbHVkaW5nIGludmFsaWQgb3JcbiAgICAgKiAgIGVtcHR5IG1vZGVsIG91dHB1dHMsIHByb3ZpZGluZyBhIGNvbXBsZXRlIHJlY29yZCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIFRoZSBoaXN0b3J5IGlzIHVwZGF0ZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbCxcbiAgICAgKiBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLCBpdCBtZWFucyByZWNlaXZpbmcgdGhlIGxhc3QgY2h1bmsgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGlzIHJldHVybmVkIGJ5IGRlZmF1bHQuIFRvIGdldCB0aGUgYGN1cmF0ZWRcbiAgICAgKiBoaXN0b3J5YCwgc2V0IHRoZSBgY3VyYXRlZGAgcGFyYW1ldGVyIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJhdGVkIC0gd2hldGhlciB0byByZXR1cm4gdGhlIGN1cmF0ZWQgaGlzdG9yeSBvciB0aGUgY29tcHJlaGVuc2l2ZVxuICAgICAqICAgICBoaXN0b3J5LlxuICAgICAqIEByZXR1cm4gSGlzdG9yeSBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsIGZvciB0aGUgZW50aXJlXG4gICAgICogICAgIGNoYXQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRIaXN0b3J5KGN1cmF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY3VyYXRlZFxuICAgICAgICAgICAgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KVxuICAgICAgICAgICAgOiB0aGlzLmhpc3Rvcnk7XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoaGlzdG9yeSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShzdHJlYW1SZXNwb25zZSwgaW5wdXRDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1SZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW1SZXNwb25zZSksIHN0cmVhbVJlc3BvbnNlXzFfMTsgc3RyZWFtUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChzdHJlYW1SZXNwb25zZV8xLm5leHQoKSksIF9jID0gc3RyZWFtUmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lID0gc3RyZWFtUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYSA9IGNodW5rLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29udGVudC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSBzdHJlYW1SZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChzdHJlYW1SZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG91dHB1dENvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb3JkSGlzdG9yeSh1c2VySW5wdXQsIG1vZGVsT3V0cHV0LCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSB7XG4gICAgICAgIGxldCBvdXRwdXRDb250ZW50cyA9IFtdO1xuICAgICAgICBpZiAobW9kZWxPdXRwdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbW9kZWxPdXRwdXQuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSAmJlxuICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5leHRyYWN0Q3VyYXRlZEhpc3RvcnkoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEFQSSBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGUnXSwgZnJvbUZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RGaWxlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlcyddKTtcbiAgICBpZiAoZnJvbUZpbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGFsbCBjdXJyZW50IHByb2plY3QgZmlsZXMgZnJvbSB0aGUgc2VydmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0XG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBwcmludHMgdGhlIG5hbWVzIG9mIGFsbCBmaWxlcyBmcm9tIHRoZSBzZXJ2aWNlLCB0aGVcbiAgICAgICAgICogc2l6ZSBvZiBlYWNoIHBhZ2UgaXMgMTAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGxpc3RSZXNwb25zZSA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDEwfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgbGlzdFJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9GSUxFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgR2VtaW5pIEFQSS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIGluIFZlcnRleCBBSS5cbiAgICAgKiBTdXBwb3J0ZWQgdXBsb2FkIHNvdXJjZXM6XG4gICAgICogLSBOb2RlLmpzOiBGaWxlIHBhdGggKHN0cmluZykgb3IgQmxvYiBvYmplY3QuXG4gICAgICogLSBCcm93c2VyOiBCbG9iIG9iamVjdCAoZS5nLiwgRmlsZSkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBgbWltZVR5cGVgIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBjb25maWdgIHBhcmFtZXRlci4gSWYgb21pdHRlZDpcbiAgICAgKiAgLSBGb3IgZmlsZSBwYXRoIChzdHJpbmcpIGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZVxuICAgICAqICAgICBmaWxlIGV4dGVuc2lvbi5cbiAgICAgKiAgLSBGb3IgQmxvYiBvYmplY3QgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIHNldCB0byB0aGUgQmxvYidzIGB0eXBlYFxuICAgICAqICAgICBwcm9wZXJ0eS5cbiAgICAgKiBTb21leCBlYW1wbGVzIGZvciBmaWxlIGV4dGVuc2lvbiB0byBtaW1lVHlwZSBtYXBwaW5nOlxuICAgICAqIC50eHQgLT4gdGV4dC9wbGFpblxuICAgICAqIC5qc29uIC0+IGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAuanBnICAtPiBpbWFnZS9qcGVnXG4gICAgICogLnBuZyAtPiBpbWFnZS9wbmdcbiAgICAgKiAubXAzIC0+IGF1ZGlvL21wZWdcbiAgICAgKiAubXA0IC0+IHZpZGVvL21wNFxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVyc2AgaW50ZXJmYWNlLlxuICAgICAqICAgICAgICAgQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnMjY29uZmlnfSBmb3IgdGhlIG9wdGlvbmFsXG4gICAgICogICAgICAgICBjb25maWcgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB0eXBlcy5GaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqIHRoZSBgbWltZVR5cGVgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHBhcmFtcy5jb25maWdgIHBhcmFtZXRlci5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIG9jY3VycyBpZiBhIHN1aXRhYmxlIHVwbG9hZCBsb2NhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB1cGxvYWRzIGEgZmlsZSB0byBHZW1pbmkgQVBJLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgYWkuZmlsZXMudXBsb2FkKHtmaWxlOiAnZmlsZS50eHQnLCBjb25maWc6IHtcbiAgICAgKiAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICogfX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IHVwbG9hZGluZyBmaWxlcy4gWW91IGNhbiBzaGFyZSBmaWxlcyB0aHJvdWdoIGEgR0NTIGJ1Y2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgIC51cGxvYWRGaWxlKHBhcmFtcy5maWxlLCBwYXJhbXMuY29uZmlnKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgcmVtb3RlbHkgc3RvcmVkIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gYSBsb2NhdGlvbiBzcGVjaWZpZWQgaW5cbiAgICAgKiB0aGUgYHBhcmFtc2Agb2JqZWN0LiBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIG9uIE5vZGUgZW52aXJvbm1lbnQsIHRvXG4gICAgICogZG93bmxvYWQgZmlsZXMgaW4gdGhlIGJyb3dzZXIsIHVzZSBhIGJyb3dzZXIgY29tcGxpYW50IG1ldGhvZCBsaWtlIGFuIDxhPlxuICAgICAqIHRhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRvd25sb2FkIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBkb3dubG9hZHMgYW4gZXhhbXBsZSBmaWxlIG5hbWVkIFwiZmlsZXMvbWVob3pweGY4NzdkXCIgYXNcbiAgICAgKiBcImZpbGUudHh0XCIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmZpbGVzLmRvd25sb2FkKHtmaWxlOiBmaWxlLm5hbWUsIGRvd25sb2FkUGF0aDogJ2ZpbGUudHh0J30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkKHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5kb3dubG9hZEZpbGUocGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEZpbGVzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENyZWF0ZUZpbGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWxlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gVGhlIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHlwZXMuRmlsZSBvYmplY3QgcmVxdWVzdGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbmZpZzogR2V0RmlsZVBhcmFtZXRlcnMgPSB7XG4gICAgICogICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgKiB9O1xuICAgICAqIGZpbGUgPSBhd2FpdCBhaS5maWxlcy5nZXQoY29uZmlnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlcy97ZmlsZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgRGVsZXRlRmlsZVJlc3BvbnNlLCB0aGUgcmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZGVsZXRlcyBhbiBleGFtcGxlIGZpbGUgbmFtZWQgXCJmaWxlcy9tZWhvenB4Zjg3N2RcIi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuZmlsZXMuZGVsZXRlKHtuYW1lOiBmaWxlLm5hbWV9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21vZGVsU2VsZWN0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxDb25maWcnXSwgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgZnJvbVJlc3BvbnNlU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvdXRpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyb3V0aW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJvdXRpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10sIGZyb21Sb3V0aW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCQxKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCB0TGl2ZVNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDIodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIGZyb21Qcm9hY3Rpdml0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleCQxKGZyb21HZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCQxKHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDEodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIGZyb21TZXNzaW9uUmVzdW1wdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIGZyb21Qcm9hY3Rpdml0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tV2VpZ2h0ZWRQcm9tcHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2VpZ2h0ZWRQcm9tcHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdlaWdodGVkUHJvbXB0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tV2VpZ2h0ZWRQcm9tcHRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRCbG9icyhmcm9tTWVkaWEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2JUb01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCBibG9iVG9NbGRldiQyKHRBdWRpb0Jsb2IoZnJvbUF1ZGlvKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIGJsb2JUb01sZGV2JDIodEltYWdlQmxvYihmcm9tVmlkZW8pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgZnJvbUFjdGl2aXR5U3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBmcm9tQWN0aXZpdHlFbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRCbG9icyhmcm9tTWVkaWEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCB0QXVkaW9CbG9iKGZyb21BdWRpbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHRJbWFnZUJsb2IoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgZnJvbUFjdGl2aXR5U3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBmcm9tQWN0aXZpdHlFbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGZyb21TZXR1cENvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGZyb21TZXJ2ZXJDb250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ2FsbCddKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGwnXSwgZnJvbVRvb2xDYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbENhbGxDYW5jZWxsYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbENhbmNlbGxhdGlvbiddLCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgdXNhZ2VNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbVVzYWdlTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvQXdheSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29Bd2F5J10pO1xuICAgIGlmIChmcm9tR29Bd2F5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29Bd2F5J10sIGZyb21Hb0F3YXkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJ10sIGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQyKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDIoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc3BhcmVudCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgZnJvbVZvaWNlQ29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDIoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZnJvbUdvb2dsZU1hcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZnJvbUdvb2dsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2VuQ291bnQnXSwgZnJvbVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhZmZpY1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10pO1xuICAgIGlmIChmcm9tVHJhZmZpY1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmFmZmljVHlwZSddLCBmcm9tVHJhZmZpY1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBmcm9tQ29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5UmF0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvblNvdXJjZXMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNpdGF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbnNJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbnNJbmZvJ10pO1xuICAgIGlmIChmcm9tVG9rZW5zSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9rZW5zSW5mbztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5zSW5mbyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0aXN0aWNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0aXN0aWNzJ10pO1xuICAgIGlmIChmcm9tU3RhdGlzdGljcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSwgY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21TdGF0aXN0aWNzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJ1bmNhdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cnVuY2F0ZWQnXSk7XG4gICAgaWYgKGZyb21UcnVuY2F0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cnVuY2F0ZWQnXSwgZnJvbVRydW5jYXRlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbl9jb3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250cm9sVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udHJvbFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250cm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10sIGZyb21Db250cm9sVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZUNvbnRyb2wnXSwgZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzeXN0ZW1JbnN0cnVjdGlvbiBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGlvbkNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21HZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRWRpdE1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VkaXRNb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRWRpdE1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0TW9kZSddLCBmcm9tRWRpdE1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ3Rhc2tfdHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dG9UcnVuY2F0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXV0b1RydW5jYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXV0b1RydW5jYXRlJ10sIGZyb21BdXRvVHJ1bmNhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW1iZWRkaW5ncyddKTtcbiAgICBpZiAoZnJvbUVtYmVkZGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVtYmVkZGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zW10nLFxuICAgICAgICAnZW1iZWRkaW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbmRwb2ludEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVwbG95ZWRNb2RlbElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVwbG95ZWRNb2RlbElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlcGxveWVkTW9kZWxJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlcGxveWVkTW9kZWxJZCddLCBmcm9tRGVwbG95ZWRNb2RlbElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQxKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMSh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgZnJvbVRvb2xDb25maWcpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXVkaW9UaW1lc3RhbXAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUNvbmZpZyddLCBmcm9tSW1hZ2VDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIGZyb21Ub29sQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCh0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1RpbWVzdGFtcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvVGltZXN0YW1wJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSwgZnJvbUF1ZGlvVGltZXN0YW1wKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUNvbmZpZyddLCBmcm9tSW1hZ2VDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRHY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmVnYXRpdmVQcm9tcHQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZ2F0aXZlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRXYXRlcm1hcmsgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlSW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmhhbmNlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmhhbmNlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVJbWFnZXNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHVic3ViVG9waWMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0ZUF1ZGlvJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZUF1ZGlvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0RnJhbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhc3RGcmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbGFzdEZyYW1lJ10sIGltYWdlVG9NbGRldihmcm9tTGFzdEZyYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFzayddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFzayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wcmVzc2lvblF1YWxpdHknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uUXVhbGl0eSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc29sdXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncmVzb2x1dGlvbiddLCBmcm9tUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QdWJzdWJUb3BpYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QdWJzdWJUb3BpYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3B1YnN1YlRvcGljJ10sIGZyb21QdWJzdWJUb3BpYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdnZW5lcmF0ZUF1ZGlvJ10sIGZyb21HZW5lcmF0ZUF1ZGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RGcmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFzdEZyYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFzdEZyYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdsYXN0RnJhbWUnXSwgaW1hZ2VUb1ZlcnRleChmcm9tTGFzdEZyYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncmVmZXJlbmNlSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWFzayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbWFzayddLCB2aWRlb0dlbmVyYXRpb25NYXNrVG9WZXJ0ZXgoZnJvbU1hc2spKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAnZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldihmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub01sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub1ZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZWRTYW1wbGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub01sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaUZpbHRlcmVkUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpRmlsdGVyZWRSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpRmlsdGVyZWRSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlGaWx0ZXJlZFJlYXNvbiddLCBmcm9tUmFpRmlsdGVyZWRSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21TYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlGaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaUZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpRmlsdGVyZWRSZWFzb24nXSwgZnJvbVJhaUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VkUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21FbmhhbmNlZFByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuaGFuY2VkUHJvbXB0J10sIGZyb21FbmhhbmNlZFByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1hc2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTWFzayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2snXSwgaW1hZ2VGcm9tVmVydGV4KGZyb21NYXNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tTGFiZWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tTWxkZXYoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1RpbWVzdGFtcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvVGltZXN0YW1wJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSwgZnJvbUF1ZGlvVGltZXN0YW1wKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIGZyb21SZXNwb25zZVNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb3V0aW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncm91dGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Sb3V0aW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm91dGluZ0NvbmZpZyddLCBmcm9tUm91dGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9WZXJ0ZXgoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUJ5dGVzJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUXVlcnlCYXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydxdWVyeUJhc2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21RdWVyeUJhc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3VybCcsICdtb2RlbHNfdXJsJ10sIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBmcm9tUXVlcnlCYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWFza01vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tNb2RlJ10pO1xuICAgIGlmIChmcm9tTWFza01vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrTW9kZSddLCBmcm9tTWFza01vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlZ21lbnRhdGlvbkNsYXNzZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tDbGFzc2VzJ10sIGZyb21TZWdtZW50YXRpb25DbGFzc2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tEaWxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza0RpbGF0aW9uJ10pO1xuICAgIGlmIChmcm9tTWFza0RpbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUb2tlbkxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUb2tlbkxpbWl0J10sIGZyb21JbnB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VG9rZW5MaW1pdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRva2VuTGltaXQnXSwgZnJvbU91dHB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwcG9ydGVkQWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cHBvcnRlZEdlbmVyYXRpb25NZXRob2RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cHBvcnRlZEFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBwb3J0ZWRBY3Rpb25zJ10sIGZyb21TdXBwb3J0ZWRBY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kZWxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbklkJ10pO1xuICAgIGlmIChmcm9tVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZlcnNpb24nXSwgZnJvbVZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXBsb3llZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW5kcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tVHVuZWRNb2RlbEluZm8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNoZWNrcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50cyddKTtcbiAgICBpZiAoZnJvbUNoZWNrcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaGVja3BvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2hlY2twb2ludHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMShmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByb2R1Y3RJbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9kdWN0SW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2R1Y3RJbWFnZSddKTtcbiAgICBpZiAoZnJvbVByb2R1Y3RJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVByb2R1Y3RJbWFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICByZWNvbnRleHRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGVyc29uSW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncGVyc29uSW1hZ2UnLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUGVyc29uSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2R1Y3RJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9kdWN0SW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2R1Y3RJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVByb2R1Y3RJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZHVjdEltYWdlVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb2R1Y3RJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZUltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlSW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUmVmZXJlbmNlSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZWZlcmVuY2VJZCddKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlSWQnXSwgZnJvbVJlZmVyZW5jZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VUeXBlJ10sIGZyb21SZWZlcmVuY2VUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21hc2tJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXNrSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrSW1hZ2VDb25maWcnXSwgbWFza1JlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21NYXNrSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRyb2xJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db250cm9sSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250cm9sSW1hZ2VDb25maWcnXSwgY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21Db250cm9sSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0eWxlSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdHlsZUltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0eWxlSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdHlsZUltYWdlQ29uZmlnJ10sIGZyb21TdHlsZUltYWdlQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1YmplY3RJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1YmplY3RJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdWJqZWN0SW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdWJqZWN0SW1hZ2VDb25maWcnXSwgZnJvbVN1YmplY3RJbWFnZUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3JpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ2NhdGVnb3JpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcmllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3JpZXMnXSwgZnJvbUNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdzY29yZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2NvcmVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NvcmVzJ10sIGZyb21TY29yZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udGVudFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50VHlwZSddLCBmcm9tQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2F0ZWdvcnknXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3J5J10sIGZyb21DYXRlZ29yeSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RocmVzaG9sZCddKTtcbiAgICBpZiAoZnJvbVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RocmVzaG9sZCddLCBmcm9tVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2NyaWJibGVJbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhQcmVkaWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heFByZWRpY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbWF4UHJlZGljdGlvbnMnXSwgZnJvbU1heFByZWRpY3Rpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb25maWRlbmNlVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdjb25maWRlbmNlVGhyZXNob2xkJ10sIGZyb21Db25maWRlbmNlVGhyZXNob2xkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tEaWxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza0RpbGF0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWFza0RpbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbWFza0RpbGF0aW9uJ10sIGZyb21NYXNrRGlsYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaW5hcnlDb2xvclRocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2JpbmFyeUNvbG9yVGhyZXNob2xkJ10sIGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNlZ21lbnRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2VnbWVudEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZE1hc2tzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVkaWN0aW9ucyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZE1hc2tzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRNYXNrcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZU1hc2tGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkTWFza3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NyaWJibGVJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NjcmliYmxlSW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2NyaWJibGVJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnc2NyaWJibGUnXSwgc2NyaWJibGVJbWFnZVRvVmVydGV4KGZyb21TY3JpYmJsZUltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgZnJvbVZvaWNlQ29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDEoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQxKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhYmVscycsXG4gICAgICAgICdnb29nbGUtdmVydGV4LWxsbS10dW5pbmctYmFzZS1tb2RlbC1pZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlSW5wdXRJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VJbnB1dEltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VJbnB1dEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICdlbmhhbmNlSW5wdXRJbWFnZSddLCBmcm9tRW5oYW5jZUlucHV0SW1hZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbWFnZVByZXNlcnZhdGlvbkZhY3RvcicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAnaW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3InXSwgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwc2NhbGVGYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cHNjYWxlRmFjdG9yJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVwc2NhbGVGYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAndXBzY2FsZUZhY3RvciddLCBmcm9tVXBzY2FsZUZhY3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RlZFZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RpbmcnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25NYXNrVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3NlbGYnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrTW9kZSddKTtcbiAgICBpZiAoZnJvbU1hc2tNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza01vZGUnXSwgZnJvbU1hc2tNb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VUeXBlJ10sIGZyb21SZWZlcmVuY2VUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9CeXRlcyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNvZGVkVmlkZW8nXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY29kaW5nJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9CeXRlcyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9ICdDb250ZW50LVR5cGUnO1xuY29uc3QgU0VSVkVSX1RJTUVPVVRfSEVBREVSID0gJ1gtU2VydmVyLVRpbWVvdXQnO1xuY29uc3QgVVNFUl9BR0VOVF9IRUFERVIgPSAnVXNlci1BZ2VudCc7XG5jb25zdCBHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIgPSAneC1nb29nLWFwaS1jbGllbnQnO1xuY29uc3QgU0RLX1ZFUlNJT04gPSAnMS4yOC4wJzsgLy8geC1yZWxlYXNlLXBsZWFzZS12ZXJzaW9uXG5jb25zdCBMSUJSQVJZX0xBQkVMID0gYGdvb2dsZS1nZW5haS1zZGsvJHtTREtfVkVSU0lPTn1gO1xuY29uc3QgVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04gPSAndjFiZXRhMSc7XG5jb25zdCBHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiA9ICd2MWJldGEnO1xuY29uc3QgcmVzcG9uc2VMaW5lUkUgPSAvXlxccypkYXRhOiAoLiopKD86XFxuXFxufFxcclxccnxcXHJcXG5cXHJcXG4pLztcbi8qKlxuICogVGhlIEFwaUNsaWVudCBjbGFzcyBpcyB1c2VkIHRvIHNlbmQgcmVxdWVzdHMgdG8gdGhlIEdlbWluaSBBUEkgb3IgVmVydGV4IEFJXG4gKiBlbmRwb2ludHMuXG4gKi9cbmNsYXNzIEFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IHByb2plY3Q6IG9wdHMucHJvamVjdCwgbG9jYXRpb246IG9wdHMubG9jYXRpb24sIGFwaUtleTogb3B0cy5hcGlLZXksIHZlcnRleGFpOiBvcHRzLnZlcnRleGFpIH0pO1xuICAgICAgICBjb25zdCBpbml0SHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmFwaVZlcnNpb24gPVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY2xpZW50T3B0aW9ucy5hcGlWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gdGhpcy5iYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVBdXRoUGFyYW1ldGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VtaW5pIEFQSVxuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmFwaVZlcnNpb24gPVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuY2xpZW50T3B0aW9ucy5hcGlWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdEh0dHBPcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldERlZmF1bHRIZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyA9IGluaXRIdHRwT3B0aW9ucztcbiAgICAgICAgaWYgKG9wdHMuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyhpbml0SHR0cE9wdGlvbnMsIG9wdHMuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGJhc2UgVVJMIGZvciBWZXJ0ZXggQUkgYmFzZWQgb24gcHJvamVjdCBhbmQgbG9jYXRpb24uXG4gICAgICogVXNlcyB0aGUgZ2xvYmFsIGVuZHBvaW50IGlmIGxvY2F0aW9uIGlzICdnbG9iYWwnIG9yIGlmIHByb2plY3QvbG9jYXRpb25cbiAgICAgKiBhcmUgbm90IHNwZWNpZmllZCAoaW1wbHlpbmcgQVBJIGtleSB1c2FnZSkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBiYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIC8vIFJlZ2lvbmFsIGVuZHBvaW50XG4gICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb259LWFpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb20vYDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHbG9iYWwgZW5kcG9pbnQgKGNvdmVycyAnZ2xvYmFsJyBsb2NhdGlvbiBhbmQgQVBJIGtleSB1c2FnZSlcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2FpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb20vYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzIGZvciBWZXJ0ZXggQUkuXG4gICAgICogSWYgcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIHByb3ZpZGVkLCBBUEkga2V5IGlzIGNsZWFyZWQuXG4gICAgICogSWYgcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIG5vdCBwcm92aWRlZCAoaW1wbHlpbmcgQVBJIGtleSB1c2FnZSksXG4gICAgICogcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIGNsZWFyZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3JtYWxpemVBdXRoUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ICYmIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbikge1xuICAgICAgICAgICAgLy8gVXNpbmcgcHJvamVjdC9sb2NhdGlvbiBmb3IgYXV0aCwgY2xlYXIgcG90ZW50aWFsIEFQSSBrZXlcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNpbmcgQVBJIGtleSBmb3IgYXV0aCAob3Igbm8gYXV0aCBwcm92aWRlZCB5ZXQpLCBjbGVhciBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlzVmVydGV4QUkoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgfVxuICAgIGdldFByb2plY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdDtcbiAgICB9XG4gICAgZ2V0TG9jYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb247XG4gICAgfVxuICAgIGdldEFwaVZlcnNpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5hcGlWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSB2ZXJzaW9uIGlzIG5vdCBzZXQuJyk7XG4gICAgfVxuICAgIGdldEJhc2VVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jhc2UgVVJMIGlzIG5vdCBzZXQuJyk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbCh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRIZWFkZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlcnMgYXJlIG5vdCBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVxdWVzdFVybEludGVybmFsKGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGlmICghaHR0cE9wdGlvbnMgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmJhc2VVcmwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgb3B0aW9ucyBhcmUgbm90IGNvcnJlY3RseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGh0dHBPcHRpb25zLmJhc2VVcmwuZW5kc1dpdGgoJy8nKVxuICAgICAgICAgICAgPyBodHRwT3B0aW9ucy5iYXNlVXJsLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgOiBodHRwT3B0aW9ucy5iYXNlVXJsO1xuICAgICAgICBjb25zdCB1cmxFbGVtZW50ID0gW2Jhc2VVcmxdO1xuICAgICAgICBpZiAoaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAmJiBodHRwT3B0aW9ucy5hcGlWZXJzaW9uICE9PSAnJykge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKGh0dHBPcHRpb25zLmFwaVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxFbGVtZW50LmpvaW4oJy8nKTtcbiAgICB9XG4gICAgZ2V0QmFzZVJlc291cmNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke3RoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0fS9sb2NhdGlvbnMvJHt0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb259YDtcbiAgICB9XG4gICAgZ2V0QXBpS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmFwaUtleTtcbiAgICB9XG4gICAgZ2V0V2Vic29ja2V0QmFzZVVybCgpIHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCB1cmxQYXJ0cyA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICAgIHVybFBhcnRzLnByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2wgPT0gJ2h0dHA6JyA/ICd3cycgOiAnd3NzJztcbiAgICAgICAgcmV0dXJuIHVybFBhcnRzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNldEJhc2VVcmwodXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdFVybChwYXRoLCBodHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICBjb25zdCB1cmxFbGVtZW50ID0gW3RoaXMuZ2V0UmVxdWVzdFVybEludGVybmFsKGh0dHBPcHRpb25zKV07XG4gICAgICAgIGlmIChwcmVwZW5kUHJvamVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2godGhpcy5nZXRCYXNlUmVzb3VyY2VQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoICE9PSAnJykge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dXJsRWxlbWVudC5qb2luKCcvJyl9YCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5wYXRoLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdGhlIHBhdGggYWxyZWFkeSBzdGFydHMgd2l0aFxuICAgICAgICAgICAgLy8gYHByb2plY3RzLzxwcm9qZWN0Pi9sb2NhdGlvbi88bG9jYXRpb24+YC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJyAmJlxuICAgICAgICAgICAgcmVxdWVzdC5wYXRoLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscycpKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBwYXRocyBhcmUgdXNlZCBieSBWZXJ0ZXgncyBtb2RlbHMuZ2V0IGFuZCBtb2RlbHMubGlzdFxuICAgICAgICAgICAgLy8gY2FsbHMuIEZvciBiYXNlIG1vZGVscyBWZXJ0ZXggZG9lcyBub3QgYWNjZXB0IGEgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICAgICAgLy8gcHJlZml4IChmb3IgdHVuZWQgbW9kZWwgdGhlIHByZWZpeCBpcyByZXF1aXJlZCkuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmIChyZXF1ZXN0LnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1ZXN0LnF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBNZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSAhPT0gJ3t9Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCBib2R5IHNob3VsZCBiZSBlbXB0eSBmb3IgR0VUIHJlcXVlc3QsIGJ1dCBnb3Qgbm9uIGVtcHR5IHJlcXVlc3QgYm9keScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdEluaXQuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdCA9IGF3YWl0IHRoaXMuaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBwYXRjaGVkSHR0cE9wdGlvbnMsIHVybC50b1N0cmluZygpLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIHBhdGNoSHR0cE9wdGlvbnMoYmFzZUh0dHBPcHRpb25zLCByZXF1ZXN0SHR0cE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEh0dHBPcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYXNlSHR0cE9wdGlvbnMpKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdEh0dHBPcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gUmVjb3JkcyBjb21waWxlIHRvIG9iamVjdHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMyMzQ1VFM3MDUzOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGV4cHJlc3Npb24gb2YgdHlwZSAnc3RyaW5nJyBjYW4ndCBiZSB1c2VkIHRvIGluZGV4IHR5cGVcbiAgICAgICAgICAgICAgICAvLyAnSHR0cE9wdGlvbnMnLlxuICAgICAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaGVkSHR0cE9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RTdHJlYW0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmICghdXJsLnNlYXJjaFBhcmFtcy5oYXMoJ2FsdCcpIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdhbHQnKSAhPT0gJ3NzZScpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhbHQnLCAnc3NlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgdXJsLnRvU3RyaW5nKCksIHJlcXVlc3QuYWJvcnRTaWduYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIGFzeW5jIGluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMsIHVybCwgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgaWYgKChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy50aW1lb3V0KSB8fCBhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIChodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMudGltZW91dCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aW1lb3V0SGFuZGxlLnVucmVmID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHVucmVmIHRvIHByZXZlbnQgbm9kZWpzIHByb2Nlc3MgZnJvbSBoYW5naW5nLCBzZWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RJbml0LnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuZXh0cmFCb2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMuZXh0cmFCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdC5oZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMsIHVybCk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SW5pdDtcbiAgICB9XG4gICAgYXN5bmMgdW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh0dHBSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgaHR0cE1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlDYWxsKHVybC50b1N0cmluZygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RJbml0KSwgeyBtZXRob2Q6IGh0dHBNZXRob2QgfSkpXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgYm9keSBpcyBlbXB0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0geWllbGQgX19hd2FpdChyZWFkZXIucmVhZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGxldGUgSlNPTiBzZWdtZW50IGF0IHRoZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU3RyaW5nID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGNodW5rIGNvbnRhaW5zIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtKc29uID0gSlNPTi5wYXJzZShjaHVua1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBjaHVua0pzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckpzb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNodW5rSnNvblsnZXJyb3InXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycm9ySnNvblsnc3RhdHVzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGVycm9ySnNvblsnY29kZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBnb3Qgc3RhdHVzOiAke3N0YXR1c30uICR7SlNPTi5zdHJpbmdpZnkoY2h1bmtKc29uKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID49IDQwMCAmJiBjb2RlIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFwaUVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBcGlFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gYnVmZmVyLm1hdGNoKHJlc3BvbnNlTGluZVJFKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRDaHVua1N0cmluZyA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsUmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocHJvY2Vzc2VkQ2h1bmtTdHJpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChuZXcgSHR0cFJlc3BvbnNlKHBhcnRpYWxSZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gYnVmZmVyLm1hdGNoKHJlc3BvbnNlTGluZVJFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleGNlcHRpb24gcGFyc2luZyBzdHJlYW0gY2h1bmsgJHtwcm9jZXNzZWRDaHVua1N0cmluZ30uICR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0KSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHJlcXVlc3RJbml0KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleGNlcHRpb24gJHtlfSBzZW5kaW5nIHJlcXVlc3RgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERlZmF1bHRIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGNvbnN0IHZlcnNpb25IZWFkZXJWYWx1ZSA9IExJQlJBUllfTEFCRUwgKyAnICcgKyB0aGlzLmNsaWVudE9wdGlvbnMudXNlckFnZW50RXh0cmE7XG4gICAgICAgIGhlYWRlcnNbVVNFUl9BR0VOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0gPSB2ZXJzaW9uSGVhZGVyVmFsdWU7XG4gICAgICAgIGhlYWRlcnNbQ09OVEVOVF9UWVBFX0hFQURFUl0gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBnZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMsIHVybCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGh0dHBPcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBlbmQgYSB0aW1lb3V0IGhlYWRlciBpZiBpdCBpcyBzZXQsIG5vdGUgdGhhdCB0aGUgdGltZW91dCBvcHRpb24gaXNcbiAgICAgICAgICAgIC8vIGluIG1pbGxpc2Vjb25kcyBidXQgdGhlIGhlYWRlciBpcyBpbiBzZWNvbmRzLlxuICAgICAgICAgICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQgJiYgaHR0cE9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChTRVJWRVJfVElNRU9VVF9IRUFERVIsIFN0cmluZyhNYXRoLmNlaWwoaHR0cE9wdGlvbnMudGltZW91dCAvIDEwMDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnRPcHRpb25zLmF1dGguYWRkQXV0aEhlYWRlcnMoaGVhZGVycywgdXJsKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIHN0cmluZyBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkIG9yIGEgQmxvYiBvYmplY3QuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGUgYFVwbG9hZEZpbGVDb25maWdgXG4gICAgICogICAgIGludGVyZmFjZS4gQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkRmlsZUNvbmZpZ31cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRmlsZShmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZmlsZVRvVXBsb2FkID0ge307XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5kaXNwbGF5TmFtZSA9IGNvbmZpZy5kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZVRvVXBsb2FkLm5hbWUgJiYgIWZpbGVUb1VwbG9hZC5uYW1lLnN0YXJ0c1dpdGgoJ2ZpbGVzLycpKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGBmaWxlcy8ke2ZpbGVUb1VwbG9hZC5uYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMudXBsb2FkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gYXdhaXQgdXBsb2FkZXIuc3RhdChmaWxlKTtcbiAgICAgICAgZmlsZVRvVXBsb2FkLnNpemVCeXRlcyA9IFN0cmluZyhmaWxlU3RhdC5zaXplKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubWltZVR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGVTdGF0LnR5cGU7XG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1pbWVUeXBlID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGRldGVybWluZSBtaW1lVHlwZS4gUGxlYXNlIHByb3ZpZGUgbWltZVR5cGUgaW4gdGhlIGNvbmZpZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgbGV0IGZpbGVOYW1lID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZS5yZXBsYWNlKC9bL1xcXFxdKyQvLCAnJyk7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IChfYiA9IGZpbGVOYW1lLnNwbGl0KC9bL1xcXFxdLykucG9wKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwbG9hZFVybCA9IGF3YWl0IHRoaXMuZmV0Y2hVcGxvYWRVcmwoZmlsZVRvVXBsb2FkLCBmaWxlTmFtZSwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbXMgcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LCBzZWUge0BsaW5rXG4gICAgICogdHlwZXMuRG93bmxvYWRGaWxlUGFyYW1ldGVyc31cbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZEZpbGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMuZG93bmxvYWRlcjtcbiAgICAgICAgYXdhaXQgZG93bmxvYWRlci5kb3dubG9hZChwYXJhbXMsIHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFVwbG9hZFVybChmaWxlLCBmaWxlTmFtZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLCAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBgJHtmaWxlLnNpemVCeXRlc31gLCAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlJzogYCR7ZmlsZS5taW1lVHlwZX1gIH0sIChmaWxlTmFtZSA/IHsgJ1gtR29vZy1VcGxvYWQtRmlsZS1OYW1lJzogZmlsZU5hbWUgfSA6IHt9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICAnZmlsZSc6IGZpbGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3JCb2R5O1xuICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHJlc3BvbnNlLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3JCb2R5KTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIGByZXF1ZXN0SW5pdC5ib2R5YCB3aXRoIHZhbHVlcyBmcm9tIGFuIGBleHRyYUJvZHlgIG9iamVjdC5cbiAqXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB0byBiZSBKU09OIGFuZCB3aWxsIGJlIHBhcnNlZC5cbiAqIFRoZSBgZXh0cmFCb2R5YCBpcyB0aGVuIGRlZXBseSBtZXJnZWQgaW50byB0aGlzIHBhcnNlZCBvYmplY3QuXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBCbG9iLCBgZXh0cmFCb2R5YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhIHdhcm5pbmcgbG9nZ2VkLFxuICogYXMgbWVyZ2luZyBzdHJ1Y3R1cmVkIGRhdGEgaW50byBhbiBvcGFxdWUgQmxvYiBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBlbmZvcmNlIHRoYXQgdXBkYXRlZCB2YWx1ZXMgZnJvbSBgZXh0cmFCb2R5YCBoYXZlIHRoZVxuICogc2FtZSB0eXBlIGFzIGV4aXN0aW5nIHZhbHVlcyBpbiBgcmVxdWVzdEluaXQuYm9keWAuIFR5cGUgbWlzbWF0Y2hlcyBkdXJpbmdcbiAqIHRoZSBtZXJnZSB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcsIGJ1dCB0aGUgdmFsdWUgZnJvbSBgZXh0cmFCb2R5YCB3aWxsIG92ZXJ3cml0ZVxuICogdGhlIG9yaWdpbmFsLiBgZXh0cmFCb2R5YCB1c2VycyBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIGBleHRyYUJvZHlgIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RJbml0IFRoZSBSZXF1ZXN0SW5pdCBvYmplY3Qgd2hvc2UgYm9keSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gZXh0cmFCb2R5IFRoZSBvYmplY3QgY29udGFpbmluZyB1cGRhdGVzIHRvIGJlIG1lcmdlZCBpbnRvIGByZXF1ZXN0SW5pdC5ib2R5YC5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGV4dHJhQm9keSkge1xuICAgIGlmICghZXh0cmFCb2R5IHx8IE9iamVjdC5rZXlzKGV4dHJhQm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IGV4dHJhQm9keSBwcm92aWRlZCBidXQgY3VycmVudCByZXF1ZXN0IGJvZHkgaXMgYSBCbG9iLiBleHRyYUJvZHkgd2lsbCBiZSBpZ25vcmVkIGFzIG1lcmdpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgQmxvYiBib2RpZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRCb2R5T2JqZWN0ID0ge307XG4gICAgLy8gSWYgYWRkaW5nIG5ldyB0eXBlIHRvIEh0dHBSZXF1ZXN0LmJvZHksIHBsZWFzZSBjaGVjayB0aGUgY29kZSBiZWxvdyB0b1xuICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbG9naWMuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SW5pdC5ib2R5ID09PSAnc3RyaW5nJyAmJiByZXF1ZXN0SW5pdC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5T2JqZWN0ID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyB2YWxpZCBKU09OIGJ1dCBub3QgYSBub24tYXJyYXkgb2JqZWN0LiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyBub3QgdmFsaWQgSlNPTi4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBvdXRwdXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSAhPT0gdHlwZW9mIHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OmRlZXBNZXJnZTogVHlwZSBtaXNtYXRjaCBmb3Iga2V5IFwiJHtrZXl9XCIuIE9yaWdpbmFsIHR5cGU6ICR7dHlwZW9mIHRhcmdldFZhbHVlfSwgTmV3IHR5cGU6ICR7dHlwZW9mIHNvdXJjZVZhbHVlfS4gT3ZlcndyaXRpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQm9keSA9IGRlZXBNZXJnZShjdXJyZW50Qm9keU9iamVjdCwgZXh0cmFCb2R5KTtcbiAgICByZXF1ZXN0SW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkQm9keSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIFRPRE86IGIvNDE2MDQxMjI5IC0gRGV0ZXJtaW5lIGhvdyB0byByZXRyaWV2ZSB0aGUgTUNQIHBhY2thZ2UgdmVyc2lvbi5cbmNvbnN0IE1DUF9MQUJFTCA9ICdtY3BfdXNlZC91bmtub3duJztcbi8vIFdoZXRoZXIgTUNQIHRvb2wgdXNhZ2UgaXMgZGV0ZWN0ZWQgZnJvbSBtY3BUb1Rvb2wuIFRoaXMgaXMgdXNlZCBmb3Jcbi8vIHRlbGVtZXRyeS5cbmxldCBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gZmFsc2U7XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgTUNQIHRvb2xzLlxuZnVuY3Rpb24gaGFzTWNwVG9vbFVzYWdlKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIGlmIChpc01jcENhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b29sID09PSAnb2JqZWN0JyAmJiAnaW5wdXRTY2hlbWEnIGluIHRvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sO1xufVxuLy8gU2V0cyB0aGUgTUNQIHZlcnNpb24gbGFiZWwgaW4gdGhlIEdvb2dsZSBBUEkgY2xpZW50IGhlYWRlci5cbmZ1bmN0aW9uIHNldE1jcFVzYWdlSGVhZGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSAoX2EgPSBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IChleGlzdGluZ0hlYWRlciArIGAgJHtNQ1BfTEFCRUx9YCkudHJpbVN0YXJ0KCk7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIE1DUCBDYWxsYWJsZVRvb2wsIG90aGVyd2lzZSBmYWxzZS5cbmZ1bmN0aW9uIGlzTWNwQ2FsbGFibGVUb29sKG9iamVjdCkge1xuICAgIHJldHVybiAob2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iamVjdCBpbnN0YW5jZW9mIE1jcENhbGxhYmxlVG9vbCk7XG59XG4vLyBMaXN0IGFsbCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50LlxuZnVuY3Rpb24gbGlzdEFsbFRvb2xzKG1jcENsaWVudCwgbWF4VG9vbHMgPSAxMDApIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBsaXN0QWxsVG9vbHNfMSgpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG51bVRvb2xzID0gMDtcbiAgICAgICAgd2hpbGUgKG51bVRvb2xzIDwgbWF4VG9vbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB5aWVsZCBfX2F3YWl0KG1jcENsaWVudC5saXN0VG9vbHMoeyBjdXJzb3IgfSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHQudG9vbHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHRvb2wpO1xuICAgICAgICAgICAgICAgIG51bVRvb2xzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXQubmV4dEN1cnNvcikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3Vyc29yID0gdC5uZXh0Q3Vyc29yO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIE1jcENhbGxhYmxlVG9vbCBjYW4gYmUgdXNlZCBmb3IgbW9kZWwgaW5mZXJlbmNlIGFuZCBpbnZva2luZyBNQ1AgY2xpZW50cyB3aXRoXG4gKiBnaXZlbiBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmNsYXNzIE1jcENhbGxhYmxlVG9vbCB7XG4gICAgY29uc3RydWN0b3IobWNwQ2xpZW50cyA9IFtdLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5tY3BUb29scyA9IFtdO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50ID0ge307XG4gICAgICAgIHRoaXMubWNwQ2xpZW50cyA9IG1jcENsaWVudHM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUobWNwQ2xpZW50cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWNwQ2FsbGFibGVUb29sKG1jcENsaWVudHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZnVuY3Rpb24gbmFtZXMgYXJlIG5vdCBkdXBsaWNhdGUgYW5kIGluaXRpYWxpemUgdGhlIGZ1bmN0aW9uXG4gICAgICogbmFtZSB0byBNQ1AgY2xpZW50IG1hcHBpbmcuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIE1DUCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50cyBoYXZlIGR1cGxpY2F0ZSB0b29sXG4gICAgICogICAgIG5hbWVzLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLm1jcFRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbk1hcCA9IHt9O1xuICAgICAgICBjb25zdCBtY3BUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1jcENsaWVudCBvZiB0aGlzLm1jcENsaWVudHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMobGlzdEFsbFRvb2xzKG1jcENsaWVudCkpKSwgX2Y7IF9mID0gYXdhaXQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2wgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgbWNwVG9vbHMucHVzaChtY3BUb29sKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWNwVG9vbE5hbWUgPSBtY3BUb29sLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbk1hcFttY3BUb29sTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdID0gbWNwQ2xpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBtY3BUb29scztcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IGZ1bmN0aW9uTWFwO1xuICAgIH1cbiAgICBhc3luYyB0b29sKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG1jcFRvb2xzVG9HZW1pbmlUb29sKHRoaXMubWNwVG9vbHMsIHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbFRvb2woZnVuY3Rpb25DYWxscykge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uQ2FsbCBvZiBmdW5jdGlvbkNhbGxzKSB7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm5hbWUgaW4gdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1jcENsaWVudCA9IHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnRbZnVuY3Rpb25DYWxsLm5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBiLzQyNDIzODY1NCAtIEFkZCBzdXBwb3J0IGZvciBmaW5lciBncmFpbmVkIHRpbWVvdXQgY29udHJvbC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxUb29sUmVzcG9uc2UgPSBhd2FpdCBtY3BDbGllbnQuY2FsbFRvb2woe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBmdW5jdGlvbkNhbGwuYXJncyxcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHJlc3VsdCBzY2hlbWEgdG8gdW5kZWZpbmVkIHRvIGFsbG93IE1DUCB0byByZWx5IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc2NoZW1hLlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGNhbGxUb29sUmVzcG9uc2UuaXNFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBlcnJvcjogY2FsbFRvb2xSZXNwb25zZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxsVG9vbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWNwQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoY2xpZW50ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdsaXN0VG9vbHMnIGluIGNsaWVudCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50Lmxpc3RUb29scyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBNY3BDYWxsYWJsZVRvb2wgZnJvbSBNQ1AgY2xpZW50cyBhbmQgYW4gb3B0aW9uYWwgY29uZmlnLlxuICpcbiAqIFRoZSBjYWxsYWJsZSB0b29sIGNhbiBpbnZva2UgdGhlIE1DUCBjbGllbnRzIHdpdGggZ2l2ZW4gZnVuY3Rpb24gY2FsbFxuICogYXJndW1lbnRzLiAob2Z0ZW4gZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nKS5cbiAqIFVzZSB0aGUgY29uZmlnIHRvIG1vZGlmeSB0b29sIHBhcmFtZXRlcnMgc3VjaCBhcyBiZWhhdmlvci5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvVG9vbCguLi5hcmdzKSB7XG4gICAgLy8gU2V0IE1DUCB1c2FnZSBmb3IgdGVsZW1ldHJ5LlxuICAgIGhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wgPSB0cnVlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE1DUCBjbGllbnRzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlQ29uZmlnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc01jcENsaWVudChtYXliZUNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncywge30pO1xuICAgIH1cbiAgICByZXR1cm4gTWNwQ2FsbGFibGVUb29sLmNyZWF0ZShhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSksIG1heWJlQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLlxuICogTm90ZSB0aGF0IHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhXG4gKiBzZXR1cENvbXBsZXRlIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVNdXNpY1NlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc2VydmVyTWVzc2FnZSwgZGF0YSk7XG4gICAgb25tZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xufVxuLyoqXG4gICBMaXZlTXVzaWMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIG11c2ljXG4gICBnZW5lcmF0aW9uIHZpYSBMeXJpYSBMaXZlIG1vZGVscy5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZU11c2ljIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGF1dGgsIHdlYlNvY2tldEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIG1vZGVsIGFuZCByZXR1cm5zIGFcbiAgICAgICBMaXZlTXVzaWNTZXNzaW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhhdCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbCA9ICdtb2RlbHMvbHlyaWEtcmVhbHRpbWUtZXhwJztcbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5tdXNpYy5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICBvbm1lc3NhZ2U6IChlOiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXI6ICVzXFxuJywgZGVidWcoZS5kYXRhKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uZXJyb3I6IChlOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkOiAlc1xcbicsIGRlYnVnKGUuZXJyb3IpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25jbG9zZTogKGU6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBjbG9zZWQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgIH0pO1xuICAgICAgIGBgYFxuICAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpdmUgbXVzaWMgaXMgbm90IHN1cHBvcnRlZCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignTGl2ZSBtdXNpYyBnZW5lcmF0aW9uIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldEJhc2VVcmwgPSB0aGlzLmFwaUNsaWVudC5nZXRXZWJzb2NrZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IGFwaVZlcnNpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlWZXJzaW9uKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtYXBUb0hlYWRlcnMkMSh0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5haS5nZW5lcmF0aXZlbGFuZ3VhZ2UuJHthcGlWZXJzaW9ufS5HZW5lcmF0aXZlU2VydmljZS5CaWRpR2VuZXJhdGVNdXNpYz9rZXk9JHthcGlLZXl9YDtcbiAgICAgICAgbGV0IG9ub3BlblJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IG9ub3BlblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBwYXJhbXMuY2FsbGJhY2tzO1xuICAgICAgICBjb25zdCBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIGNhbGxiYWNrcy5vbm1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVycm9yOiAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlOiAoX2IgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLndlYlNvY2tldEZhY3RvcnkuY3JlYXRlKHVybCwgaGVhZGVyc1RvTWFwJDEoaGVhZGVycyksIHdlYnNvY2tldENhbGxiYWNrcyk7XG4gICAgICAgIGNvbm4uY29ubmVjdCgpO1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgd2Vic29ja2V0IHRvIG9wZW4gYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHMuXG4gICAgICAgIGF3YWl0IG9ub3BlblByb21pc2U7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdE1vZGVsKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMubW9kZWwpO1xuICAgICAgICBjb25zdCBzZXR1cCA9IHsgbW9kZWwgfTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHsgc2V0dXAgfTtcbiAgICAgICAgY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXZlTXVzaWNTZXNzaW9uKGNvbm4sIHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG59XG4vKipcbiAgIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIHRoZSBBUEkuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmVNdXNpY1Nlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbm4sIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZXRzIGlucHV0cyB0byBzdGVlciBtdXNpYyBnZW5lcmF0aW9uLiBVcGRhdGVzIHRoZSBzZXNzaW9uJ3MgY3VycmVudFxuICAgICAgd2VpZ2h0ZWQgcHJvbXB0cy5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgd2VpZ2h0ZWRQcm9tcHRzYC5cbiAgXG4gICAgICAgIC0gYHdlaWdodGVkUHJvbXB0c2AgdG8gc2VuZCB0byB0aGUgbW9kZWw7IHdlaWdodHMgYXJlIG5vcm1hbGl6ZWQgdG9cbiAgICAgICAgICBzdW0gdG8gMS4wLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRXZWlnaHRlZFByb21wdHMocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLndlaWdodGVkUHJvbXB0cyB8fFxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zLndlaWdodGVkUHJvbXB0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlaWdodGVkIHByb21wdHMgbXVzdCBiZSBzZXQgYW5kIGNvbnRhaW4gYXQgbGVhc3Qgb25lIGVudHJ5LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudENvbnRlbnQgPSBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeSh7IGNsaWVudENvbnRlbnQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgYSBjb25maWd1cmF0aW9uIHRvIHRoZSBtb2RlbC4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIG11c2ljIGdlbmVyYXRpb24gY29uZmlnLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtdXNpY0dlbmVyYXRpb25Db25maWdgLlxuICBcbiAgICAgICAgLSBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYCB0byBzZXQgaW4gdGhlIG1vZGVsLiBQYXNzaW5nIGFuIGVtcHR5IG9yXG4gICAgICB1bmRlZmluZWQgY29uZmlnIHRvIHRoZSBtb2RlbCB3aWxsIHJlc2V0IHRoZSBjb25maWcgdG8gZGVmYXVsdHMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICBwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0Q29uZmlnUGFyYW1ldGVycyA9IGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KHNldENvbmZpZ1BhcmFtZXRlcnMpKTtcbiAgICB9XG4gICAgc2VuZFBsYXliYWNrQ29udHJvbChwbGF5YmFja0NvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHsgcGxheWJhY2tDb250cm9sIH07XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIG11c2ljIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBMQVkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcmlseSBoYWx0IHRoZSBtdXNpYyBzdHJlYW0uIFVzZSBgcGxheWAgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5QQVVTRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIG11c2ljIHN0cmVhbSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHNcbiAgICAgKiBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuU1RPUCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAqIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0cyBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHJlc2V0Q29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5SRVNFVF9DT05URVhUKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgVGVybWluYXRlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwJDEoaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJNYXBba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJNYXA7XG59XG4vLyBDb252ZXJ0cyBhIFwibWFwXCIgb2JqZWN0IHRvIGEgaGVhZGVycyBvYmplY3QuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoXG4vLyBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHMgd2hpbGUgdGhlIEFQSSBjbGllbnQgZGVmYXVsdCBoZWFkZXJzXG4vLyByZXR1cm5zIGEgbWFwLlxuZnVuY3Rpb24gbWFwVG9IZWFkZXJzJDEobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEID0gJ0Z1bmN0aW9uUmVzcG9uc2UgcmVxdWVzdCBtdXN0IGhhdmUgYW4gYGlkYCBmaWVsZCBmcm9tIHRoZSByZXNwb25zZSBvZiBhIFRvb2xDYWxsLkZ1bmN0aW9uYWxDYWxscyBpbiBHb29nbGUgQUkuJztcbi8qKlxuICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZXMsIHRyYW5zZm9ybWluZyB0aGVtXG4gKiBpbnRvIExpdmVTZXJ2ZXJNZXNzYWdlcywgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLiBOb3RlIHRoYXRcbiAqIHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhIHNldHVwQ29tcGxldGVcbiAqIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBvbm1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IG5ldyBMaXZlU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBqc29uRGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAganNvbkRhdGEgPSBhd2FpdCBldmVudC5kYXRhLnRleHQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGpzb25EYXRhID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbkRhdGEgPSBldmVudC5kYXRhO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uRGF0YSk7XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbVZlcnRleChkYXRhKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBkYXRhO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmUgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIGludGVyYWN0aW9uIHdpdGggdGhlXG4gICBHZW5lcmF0aXZlIExhbmd1YWdlIEFQSS4gSXQgZW1iZWRzIEFwaUNsaWVudCBmb3IgZ2VuZXJhbCBBUEkgc2V0dGluZ3MuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5tdXNpYyA9IG5ldyBMaXZlTXVzaWModGhpcy5hcGlDbGllbnQsIHRoaXMuYXV0aCwgdGhpcy53ZWJTb2NrZXRGYWN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpblxuICAgICAgIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9LFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ub3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gdGhlIHNvY2tldC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIC8vIFRPRE86IGIvNDA0OTQ2NzQ2IC0gU3VwcG9ydCBwZXIgcmVxdWVzdCBIVFRQIG9wdGlvbnMuXG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIExpdmUgbW9kdWxlIGRvZXMgbm90IHN1cHBvcnQgaHR0cE9wdGlvbnMgYXQgcmVxdWVzdC1sZXZlbCBpbicgK1xuICAgICAgICAgICAgICAgICcgTGl2ZUNvbm5lY3RDb25maWcgeWV0LiBQbGVhc2UgdXNlIHRoZSBjbGllbnQtbGV2ZWwgaHR0cE9wdGlvbnMnICtcbiAgICAgICAgICAgICAgICAnIGNvbmZpZ3VyYXRpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBjb25zdCBjbGllbnRIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0SGVhZGVycygpO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzKGNsaWVudEhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS4ke2FwaVZlcnNpb259LkxsbUJpZGlTZXJ2aWNlL0JpZGlHZW5lcmF0ZUNvbnRlbnRgO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudCc7XG4gICAgICAgICAgICBsZXQga2V5TmFtZSA9ICdrZXknO1xuICAgICAgICAgICAgaWYgKGFwaUtleSA9PT0gbnVsbCB8fCBhcGlLZXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwaUtleS5zdGFydHNXaXRoKCdhdXRoX3Rva2Vucy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogRXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpVmVyc2lvbiAhPT0gJ3YxYWxwaGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IFRoZSBTREsncyBlcGhlbWVyYWwgdG9rZW4gc3VwcG9ydCBpcyBpbiB2MWFscGhhIG9ubHkuIFBsZWFzZSB1c2UgY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogdG9rZW4ubmFtZSwgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH19KTsgYmVmb3JlIHNlc3Npb24gY29ubmVjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdCaWRpR2VuZXJhdGVDb250ZW50Q29uc3RyYWluZWQnO1xuICAgICAgICAgICAgICAgIGtleU5hbWUgPSAnYWNjZXNzX3Rva2VuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5haS5nZW5lcmF0aXZlbGFuZ3VhZ2UuJHthcGlWZXJzaW9ufS5HZW5lcmF0aXZlU2VydmljZS4ke21ldGhvZH0/JHtrZXlOYW1lfT0ke2FwaUtleX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbm9wZW5SZXNvbHZlID0gKCkgPT4geyB9O1xuICAgICAgICBjb25zdCBvbm9wZW5Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgY29uc3Qgb25vcGVuQXdhaXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9ub3BlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25vcGVuOiBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlV2ViU29ja2V0TWVzc2FnZShhcGlDbGllbnQsIGNhbGxiYWNrcy5vbm1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVycm9yOiAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlOiAoX2IgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLndlYlNvY2tldEZhY3RvcnkuY3JlYXRlKHVybCwgaGVhZGVyc1RvTWFwKGhlYWRlcnMpLCB3ZWJzb2NrZXRDYWxsYmFja3MpO1xuICAgICAgICBjb25uLmNvbm5lY3QoKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdlYnNvY2tldCB0byBvcGVuIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICBhd2FpdCBvbm9wZW5Qcm9taXNlO1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zLm1vZGVsKTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJlxuICAgICAgICAgICAgdHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gdGhpcy5hcGlDbGllbnQuZ2V0UHJvamVjdCgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRNb2RlbCA9XG4gICAgICAgICAgICAgICAgYHByb2plY3RzLyR7cHJvamVjdH0vbG9jYXRpb25zLyR7bG9jYXRpb259L2AgKyB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGllbnRNZXNzYWdlID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgICgoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzcG9uc2VNb2RhbGl0aWVzKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdCB0byBBVURJTyB0byBhbGlnbiB3aXRoIE1MRGV2IEFQSS5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnID0geyByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcucmVzcG9uc2VNb2RhbGl0aWVzID0gW01vZGFsaXR5LkFVRElPXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdlbmVyYXRpb25Db25maWcpIHtcbiAgICAgICAgICAgIC8vIFJhaXNlIGRlcHJlY2F0aW9uIHdhcm5pbmcgZm9yIGdlbmVyYXRpb25Db25maWcuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NldHRpbmcgYExpdmVDb25uZWN0Q29uZmlnLmdlbmVyYXRpb25fY29uZmlnYCBpcyBkZXByZWNhdGVkLCBwbGVhc2Ugc2V0IHRoZSBmaWVsZHMgb24gYExpdmVDb25uZWN0Q29uZmlnYCBkaXJlY3RseS4gVGhpcyB3aWxsIGJlY29tZSBhbiBlcnJvciBpbiBhIGZ1dHVyZSB2ZXJzaW9uIChub3QgYmVmb3JlIFEzIDIwMjUpLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0VG9vbHMgPSAoX2YgPSAoX2UgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudG9vbHMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IFtdO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgaW5wdXRUb29scykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZFRvb2xzLnB1c2goYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKHRvb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb252ZXJ0ZWRUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzID0gY29udmVydGVkVG9vbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybWVkTW9kZWwsXG4gICAgICAgICAgICBjb25maWc6IHBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHBhcmFtcy5jYWxsYmFja3MsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBsaXZlQ29ubmVjdFBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjbGllbnRNZXNzYWdlWydjb25maWcnXTtcbiAgICAgICAgY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXNzaW9uKGNvbm4sIHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG4gICAgLy8gVE9ETzogYi80MTYwNDEyMjkgLSBBYnN0cmFjdCB0aGlzIG1ldGhvZCB0byBhIGNvbW1vbiBwbGFjZS5cbiAgICBpc0NhbGxhYmxlVG9vbCh0b29sKSB7XG4gICAgICAgIHJldHVybiAnY2FsbFRvb2wnIGluIHRvb2wgJiYgdHlwZW9mIHRvb2wuY2FsbFRvb2wgPT09ICdmdW5jdGlvbic7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdExpdmVTZW5kQ2xpZW50Q29udGVudFBhcmFtZXJ0ZXJzID0ge1xuICAgIHR1cm5Db21wbGV0ZTogdHJ1ZSxcbn07XG4vKipcbiAgIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIHRoZSBBUEkuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIFNlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbm4sIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgdExpdmVDbGllbnRDb250ZW50KGFwaUNsaWVudCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMudHVybnMgIT09IG51bGwgJiYgcGFyYW1zLnR1cm5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IHRDb250ZW50cyhwYXJhbXMudHVybnMpO1xuICAgICAgICAgICAgICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvTWxkZXYkMShpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgY2xpZW50IGNvbnRlbnQgXCJ0dXJuc1wiLCB0eXBlOiAnJHt0eXBlb2YgcGFyYW1zLnR1cm5zfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuczogY29udGVudHMsIHR1cm5Db21wbGV0ZTogcGFyYW1zLnR1cm5Db21wbGV0ZSB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdExpdmVDbGllbnR0VG9vbFJlc3BvbnNlKGFwaUNsaWVudCwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBpZiAocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25SZXNwb25zZXMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcykpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzID0gW3BhcmFtcy5mdW5jdGlvblJlc3BvbnNlc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25SZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZnVuY3Rpb25SZXNwb25zZSBvZiBmdW5jdGlvblJlc3BvbnNlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAhKCduYW1lJyBpbiBmdW5jdGlvblJlc3BvbnNlKSB8fFxuICAgICAgICAgICAgICAgICEoJ3Jlc3BvbnNlJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGZ1bmN0aW9uIHJlc3BvbnNlLCB0eXBlICcke3R5cGVvZiBmdW5jdGlvblJlc3BvbnNlfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgISgnaWQnIGluIGZ1bmN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgdG9vbFJlc3BvbnNlOiB7IGZ1bmN0aW9uUmVzcG9uc2VzOiBmdW5jdGlvblJlc3BvbnNlcyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xpZW50TWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyB0d28gKipvcHRpb25hbCoqIHByb3BlcnRpZXMsIGB0dXJuc2AgYW5kXG4gICAgICAgICAgYHR1cm5Db21wbGV0ZWAuXG4gIFxuICAgICAgICAtIGB0dXJuc2Agd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQ29udGVudFtdYFxuICAgICAgICAtIGB0dXJuQ29tcGxldGU6IHRydWVgIFtkZWZhdWx0XSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIGRvbmUgc2VuZGluZ1xuICAgICAgICAgIGNvbnRlbnQgYW5kIGV4cGVjdCBhIHJlc3BvbnNlLiBJZiBgdHVybkNvbXBsZXRlOiBmYWxzZWAsIHRoZSBzZXJ2ZXJcbiAgICAgICAgICB3aWxsIHdhaXQgZm9yIGFkZGl0aW9uYWwgbWVzc2FnZXMgYmVmb3JlIHN0YXJ0aW5nIGdlbmVyYXRpb24uXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBUaGVyZSBhcmUgdHdvIHdheXMgdG8gc2VuZCBtZXNzYWdlcyB0byB0aGUgbGl2ZSBBUEk6XG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIGFuZCBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgYXJlIGFkZGVkIHRvIHRoZSBtb2RlbCBjb250ZXh0ICoqaW4gb3JkZXIqKi5cbiAgICAgIEhhdmluZyBhIGNvbnZlcnNhdGlvbiB1c2luZyBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGlzIHJvdWdobHlcbiAgICAgIGVxdWl2YWxlbnQgdG8gdXNpbmcgdGhlIGBDaGF0LnNlbmRNZXNzYWdlU3RyZWFtYCwgZXhjZXB0IHRoYXQgdGhlIHN0YXRlIG9mXG4gICAgICB0aGUgYGNoYXRgIGhpc3RvcnkgaXMgc3RvcmVkIG9uIHRoZSBBUEkgc2VydmVyIGluc3RlYWQgb2YgbG9jYWxseS5cbiAgXG4gICAgICBCZWNhdXNlIG9mIGBzZW5kQ2xpZW50Q29udGVudGAncyBvcmRlciBndWFyYW50ZWUsIHRoZSBtb2RlbCBjYW5ub3QgcmVzcG9uc1xuICAgICAgYXMgcXVpY2tseSB0byBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFzIHRvIGBzZW5kUmVhbHRpbWVJbnB1dGBcbiAgICAgIG1lc3NhZ2VzLiBUaGlzIG1ha2VzIHRoZSBiaWdnZXN0IGRpZmZlcmVuY2Ugd2hlbiBzZW5kaW5nIG9iamVjdHMgdGhhdCBoYXZlXG4gICAgICBzaWduaWZpY2FudCBwcmVwcm9jZXNzaW5nIHRpbWUgKHR5cGljYWxseSBpbWFnZXMpLlxuICBcbiAgICAgIFRoZSBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2Ugc2VuZHMgYSBgQ29udGVudFtdYFxuICAgICAgd2hpY2ggaGFzIG1vcmUgb3B0aW9ucyB0aGFuIHRoZSBgQmxvYmAgc2VudCBieSBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIFNvIHRoZSBtYWluIHVzZS1jYXNlcyBmb3IgYHNlbmRDbGllbnRDb250ZW50YCBvdmVyIGBzZW5kUmVhbHRpbWVJbnB1dGAgYXJlOlxuICBcbiAgICAgIC0gU2VuZGluZyBhbnl0aGluZyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGFzIGEgYEJsb2JgICh0ZXh0LFxuICAgICAgYHNlbmRDbGllbnRDb250ZW50KHt0dXJucz1cIkhlbGxvP1wifWApKS5cbiAgICAgIC0gTWFuYWdpbmcgdHVybnMgd2hlbiBub3QgdXNpbmcgYXVkaW8gaW5wdXQgYW5kIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbi5cbiAgICAgICAgKGBzZW5kQ2xpZW50Q29udGVudCh7dHVybkNvbXBsZXRlOnRydWV9KWAgb3IgdGhlIHNob3J0IGZvcm1cbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCgpYClcbiAgICAgIC0gUHJlZmlsbGluZyBhIGNvbnZlcnNhdGlvbiBjb250ZXh0XG4gICAgICAgIGBgYFxuICAgICAgICBzZW5kQ2xpZW50Q29udGVudCh7XG4gICAgICAgICAgICB0dXJuczogW1xuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgICAgYGBgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2VuZENsaWVudENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdExpdmVTZW5kQ2xpZW50Q29udGVudFBhcmFtZXJ0ZXJzKSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHRoaXMudExpdmVDbGllbnRDb250ZW50KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIHJlYWx0aW1lIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgbWVkaWFgLlxuICBcbiAgICAgICAgLSBgbWVkaWFgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJsb2JgXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRSZWFsdGltZUlucHV0YCBmb3IgcmVhbHRpbWUgYXVkaW8gY2h1bmtzIGFuZCB2aWRlbyBmcmFtZXMgKGltYWdlcykuXG4gIFxuICAgICAgV2l0aCBgc2VuZFJlYWx0aW1lSW5wdXRgIHRoZSBhcGkgd2lsbCByZXNwb25kIHRvIGF1ZGlvIGF1dG9tYXRpY2FsbHlcbiAgICAgIGJhc2VkIG9uIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbiAoVkFEKS5cbiAgXG4gICAgICBgc2VuZFJlYWx0aW1lSW5wdXRgIGlzIG9wdGltaXplZCBmb3IgcmVzcG9uc2l2bmVzcyBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAgZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBndWFyYW50ZWVzLiBBdWRpbyBhbmQgdmlkZW8gdG9rZW5zIGFyZSB0byB0aGVcbiAgICAgIGNvbnRleHQgd2hlbiB0aGV5IGJlY29tZSBhdmFpbGFibGUuXG4gIFxuICAgICAgTm90ZTogVGhlIENhbGwgc2lnbmF0dXJlIGV4cGVjdHMgYSBgQmxvYmAgb2JqZWN0LCBidXQgb25seSBhIHN1YnNldFxuICAgICAgb2YgYXVkaW8gYW5kIGltYWdlIG1pbWV0eXBlcyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBzZW5kUmVhbHRpbWVJbnB1dChwYXJhbXMpIHtcbiAgICAgICAgbGV0IGNsaWVudE1lc3NhZ2UgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIGZ1bmN0aW9uIHJlc3BvbnNlIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgcHJvcGVydHkgYGZ1bmN0aW9uUmVzcG9uc2VzYC5cbiAgXG4gICAgICAgIC0gYGZ1bmN0aW9uUmVzcG9uc2VzYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBmdW5jdGlvblJlc3BvbnNlc1tdYFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRGdW5jdGlvblJlc3BvbnNlYCB0byByZXBseSB0byBgTGl2ZVNlcnZlclRvb2xDYWxsYCBmcm9tIHRoZSBzZXJ2ZXIuXG4gIFxuICAgICAgVXNlIHtAbGluayB0eXBlcy5MaXZlQ29ubmVjdENvbmZpZyN0b29sc30gdG8gY29uZmlndXJlIHRoZSBjYWxsYWJsZSBmdW5jdGlvbnMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRUb29sUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sIHJlc3BvbnNlIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZSh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9XG4gICAgICAgfSk7XG4gIFxuICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICBgYGBcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJNYXAgPSB7fTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyTWFwW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyTWFwO1xufVxuLy8gQ29udmVydHMgYSBcIm1hcFwiIG9iamVjdCB0byBhIGhlYWRlcnMgb2JqZWN0LiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aFxuLy8gaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzIHdoaWxlIHRoZSBBUEkgY2xpZW50IGRlZmF1bHQgaGVhZGVyc1xuLy8gcmV0dXJucyBhIG1hcC5cbmZ1bmN0aW9uIG1hcFRvSGVhZGVycyhtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTID0gMTA7XG4vKiogUmV0dXJucyB3aGV0aGVyIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGlzIGRpc2FibGVkLiAqL1xuZnVuY3Rpb24gc2hvdWxkRGlzYWJsZUFmYyhjb25maWcpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBjYWxsYWJsZVRvb2xzUHJlc2VudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2IgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudG9vbHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgY2FsbGFibGVUb29sc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjYWxsYWJsZVRvb2xzUHJlc2VudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWF4Q2FsbHMgPSAoX2MgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4aW11bVJlbW90ZUNhbGxzO1xuICAgIGlmICgobWF4Q2FsbHMgJiYgKG1heENhbGxzIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihtYXhDYWxscykpKSB8fFxuICAgICAgICBtYXhDYWxscyA9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBtYXhpbXVtUmVtb3RlQ2FsbHMgdmFsdWUgcHJvdmlkZWQgZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nLiBEaXNhYmxlZCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBpbnRlZ2VyIHZhbHVlIGdyZWF0ZXIgdGhhbiAwLiBtYXhpbXVtUmVtb3RlQ2FsbHMgcHJvdmlkZWQ6JywgbWF4Q2FsbHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgIHJldHVybiAnY2FsbFRvb2wnIGluIHRvb2wgJiYgdHlwZW9mIHRvb2wuY2FsbFRvb2wgPT09ICdmdW5jdGlvbic7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgQ2FsbGFibGVUb29scy4gV2lsbCByZXR1cm4gdHJ1ZVxuLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIENhbGxhYmxlVG9vbC5cbmZ1bmN0aW9uIGhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHRvb2wpID0+IGlzQ2FsbGFibGVUb29sKHRvb2wpKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgbm9uLWNhbGxhYmxlIHRvb2xzLiBXaWxsIHJldHVyblxuLy8gdHJ1ZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbm9uLUNhbGxhYmxlIHRvb2wuXG5mdW5jdGlvbiBoYXNOb25DYWxsYWJsZVRvb2xzKHBhcmFtcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb21lKCh0b29sKSA9PiAhaXNDYWxsYWJsZVRvb2wodG9vbCkpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRvIGFwcGVuZCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyBoaXN0b3J5IHRvIHRoZVxuICogcmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEFwcGVuZEFmY0hpc3RvcnkoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhKChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZ25vcmVDYWxsSGlzdG9yeSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE1vZGVscyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGFuIEFQSSByZXF1ZXN0IHRvIGdlbmVyYXRlIGNvbnRlbnQgd2l0aCBhIGdpdmVuIG1vZGVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgVmVydGV4IEFJIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgZnVsbCByZXNvdXJjZSBuYW1lIHN0YXJ0cyB3aXRoICdwcm9qZWN0cy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwcm9qZWN0cy9teS1wcm9qZWN0LWlkL2xvY2F0aW9ucy91cy1jZW50cmFsMS9wdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgcGFydGlhbCByZXNvdXJjZSBuYW1lIHdpdGggJ3B1Ymxpc2hlcnMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnIG9yXG4gICAgICAgICAqICAncHVibGlzaGVycy9tZXRhL21vZGVscy9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKiAtIGAvYCBzZXBhcmF0ZWQgcHVibGlzaGVyIGFuZCBtb2RlbCBuYW1lLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ2dvb2dsZS9nZW1pbmktMi4wLWZsYXNoJyBvciAnbWV0YS9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgR2VtaW5pIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAnbW9kZWxzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIEZvciB0dW5lZCBtb2RlbHMsIHRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICd0dW5lZE1vZGVscy8nLFxuICAgICAgICAgKiBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ3R1bmVkTW9kZWxzLzEyMzQ1Njc4OTAxMjM0NTY3ODknXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvbWUgbW9kZWxzIHN1cHBvcnQgbXVsdGltb2RhbCBpbnB1dCBhbmQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBjb250ZW50czogJ3doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIGNhbmRpZGF0ZUNvdW50OiAyLFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29udGVudCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbShwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCFoYXNDYWxsYWJsZVRvb2xzKHBhcmFtcykgfHwgc2hvdWxkRGlzYWJsZUFmYyhwYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudEludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNOb25DYWxsYWJsZVRvb2xzKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyBhbmQgVG9vbHMgaXMgbm90IHlldCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gdHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgICAgICBsZXQgcmVtb3RlQ2FsbHMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxzIDwgbWF4UmVtb3RlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UuZnVuY3Rpb25DYWxscyB8fCByZXNwb25zZS5mdW5jdGlvbkNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2UgPSAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9vbHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgY2FsbGFibGVUb29sLmNhbGxUb29sKHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZVBhcnRzLnB1c2goLi4ucGFydHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW90ZUNhbGxzKys7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cy5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5LnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kQWZjSGlzdG9yeSh0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbCBhbmQgeWllbGRzIHRoZVxuICAgICAgICAgKiByZXNwb25zZSBpbiBjaHVua3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3R1bmVkTW9kZWxzLzEyMzQ1Njc4OTAxMjM0NTY3ODknXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvbWUgbW9kZWxzIHN1cHBvcnQgbXVsdGltb2RhbCBpbnB1dCBhbmQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgY29udGVudCB3aXRoIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBjb250ZW50czogJ3doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIG1heE91dHB1dFRva2VuczogMjAwLFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2UpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjaHVuayk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbShwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHNob3VsZERpc2FibGVBZmMocGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm9jZXNzQWZjU3RyZWFtKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgYW4gaW1hZ2UgYmFzZWQgb24gYSB0ZXh0IGRlc2NyaXB0aW9uIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgaW1hZ2VzLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5nZW5lcmF0ZUltYWdlcyh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyJyxcbiAgICAgICAgICogIHByb21wdDogJ1JvYm90IGhvbGRpbmcgYSByZWQgc2thdGVib2FyZCcsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUltYWdlcyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlSW1hZ2VzSW50ZXJuYWwocGFyYW1zKS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZEltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChhcGlSZXNwb25zZSA9PT0gbnVsbCB8fCBhcGlSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBpUmVzcG9uc2UuZ2VuZXJhdGVkSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZ2VuZXJhdGVkSW1hZ2Ugb2YgYXBpUmVzcG9uc2UuZ2VuZXJhdGVkSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkSW1hZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYSA9IGdlbmVyYXRlZEltYWdlID09PSBudWxsIHx8IGdlbmVyYXRlZEltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmF0ZWRJbWFnZS5zYWZldHlBdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudFR5cGUpID09PSAnUG9zaXRpdmUgUHJvbXB0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdlbmVyYXRlZEltYWdlID09PSBudWxsIHx8IGdlbmVyYXRlZEltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmF0ZWRJbWFnZS5zYWZldHlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkSW1hZ2VzLnB1c2goZ2VuZXJhdGVkSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkSW1hZ2VzOiBnZW5lcmF0ZWRJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM6IHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNka0h0dHBSZXNwb25zZTogYXBpUmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNka0h0dHBSZXNwb25zZTogYXBpUmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeUJhc2U6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnKSwgcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29uZmlnOiBhY3R1YWxDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWN0dWFsUGFyYW1zLmNvbmZpZy5xdWVyeUJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IGFjdHVhbFBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsdGVyaW5nIHR1bmVkIG1vZGVscyBsaXN0IGZvciBWZXJ0ZXggQUkgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFBhcmFtcy5jb25maWcuZmlsdGVyID0gJ2xhYmVscy50dW5lLXR5cGU6Kic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX01PREVMUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChhY3R1YWxQYXJhbXMpLCBhY3R1YWxQYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRWRpdHMgYW4gaW1hZ2UgYmFzZWQgb24gYSBwcm9tcHQsIGxpc3Qgb2YgcmVmZXJlbmNlIGltYWdlcywgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZWRpdGluZyBhbiBpbWFnZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5tb2RlbHMuZWRpdEltYWdlKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1jYXBhYmlsaXR5LTAwMScsXG4gICAgICAgICAqICBwcm9tcHQ6ICdHZW5lcmF0ZSBhbiBpbWFnZSBjb250YWluaW5nIGEgbXVnIHdpdGggdGhlIHByb2R1Y3QgbG9nbyBbMV0gdmlzaWJsZSBvbiB0aGUgc2lkZSBvZiB0aGUgbXVnLicsXG4gICAgICAgICAqICByZWZlcmVuY2VJbWFnZXM6IFtzdWJqZWN0UmVmZXJlbmNlSW1hZ2VdXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0SW1hZ2UgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXNJbnRlcm5hbCA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICAgIHByb21wdDogcGFyYW1zLnByb21wdCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VJbWFnZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcGFyYW1zLmNvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFyYW1zLnJlZmVyZW5jZUltYWdlcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc0ludGVybmFsLnJlZmVyZW5jZUltYWdlcyA9IHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMubWFwKChpbWcpID0+IGltZy50b1JlZmVyZW5jZUltYWdlQVBJKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVkaXRJbWFnZUludGVybmFsKHBhcmFtc0ludGVybmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwc2NhbGVzIGFuIGltYWdlIGJhc2VkIG9uIGFuIGltYWdlLCB1cHNjYWxlIGZhY3RvciwgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIE9ubHkgc3VwcG9ydGVkIGluIFZlcnRleCBBSSBjdXJyZW50bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdXBzY2FsaW5nIGFuIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy51cHNjYWxlSW1hZ2Uoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWdlbmVyYXRlLTAwMicsXG4gICAgICAgICAqICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAqICB1cHNjYWxlRmFjdG9yOiAneDInLFxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cHNjYWxlSW1hZ2UgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBsZXQgYXBpQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAgICAgICAgICAgIG1vZGU6ICd1cHNjYWxlJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZykge1xuICAgICAgICAgICAgICAgIGFwaUNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXBpQ29uZmlnKSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbWFnZTogcGFyYW1zLmltYWdlLFxuICAgICAgICAgICAgICAgIHVwc2NhbGVGYWN0b3I6IHBhcmFtcy51cHNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogYXBpQ29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwc2NhbGVJbWFnZUludGVybmFsKGFwaVBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgR2VuZXJhdGVzIHZpZGVvcyBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyB2aWRlb3MuXG4gICAgICAgICAqIEByZXR1cm4gQSBQcm9taXNlPEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uPiB3aGljaCBhbGxvd3MgeW91IHRvIHRyYWNrIHRoZSBwcm9ncmVzcyBhbmQgZXZlbnR1YWxseSByZXRyaWV2ZSB0aGUgZ2VuZXJhdGVkIHZpZGVvcyB1c2luZyB0aGUgb3BlcmF0aW9ucy5nZXQgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBvcGVyYXRpb24gPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVWaWRlb3Moe1xuICAgICAgICAgKiAgbW9kZWw6ICd2ZW8tMi4wLWdlbmVyYXRlLTAwMScsXG4gICAgICAgICAqICBzb3VyY2U6IHtcbiAgICAgICAgICogICAgcHJvbXB0OiAnQSBuZW9uIGhvbG9ncmFtIG9mIGEgY2F0IGRyaXZpbmcgYXQgdG9wIHNwZWVkJyxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgbnVtYmVyT2ZWaWRlb3M6IDFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHdoaWxlICghb3BlcmF0aW9uLmRvbmUpIHtcbiAgICAgICAgICogICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMDApKTtcbiAgICAgICAgICogICBvcGVyYXRpb24gPSBhd2FpdCBhaS5vcGVyYXRpb25zLmdldFZpZGVvc09wZXJhdGlvbih7b3BlcmF0aW9uOiBvcGVyYXRpb259KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhvcGVyYXRpb24ucmVzcG9uc2U/LmdlbmVyYXRlZFZpZGVvcz8uWzBdPy52aWRlbz8udXJpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlVmlkZW9zID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBpZiAoKHBhcmFtcy5wcm9tcHQgfHwgcGFyYW1zLmltYWdlIHx8IHBhcmFtcy52aWRlbykgJiYgcGFyYW1zLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBwcm9tcHQvaW1hZ2UvdmlkZW8gYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4gUGxlYXNlIG9ubHkgdXNlIHNvdXJjZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdlbWluaSBBUEkgZG9lcyBub3Qgc3VwcG9ydCB2aWRlbyBieXRlcy5cbiAgICAgICAgICAgIGlmICghdGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBwYXJhbXMudmlkZW8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmkpICYmICgoX2IgPSBwYXJhbXMudmlkZW8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aWRlb0J5dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudmlkZW8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHBhcmFtcy52aWRlby51cmksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFyYW1zLnZpZGVvLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoKF9kID0gKF9jID0gcGFyYW1zLnNvdXJjZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZpZGVvKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudXJpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9mID0gKF9lID0gcGFyYW1zLnNvdXJjZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnZpZGVvKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudmlkZW9CeXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNvdXJjZS52aWRlbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogcGFyYW1zLnNvdXJjZS52aWRlby51cmksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFyYW1zLnNvdXJjZS52aWRlby5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVZpZGVvc0ludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbG9naWMgaXMgbmVlZGVkIGZvciBHZW5lcmF0ZUNvbnRlbnRDb25maWcgb25seS5cbiAgICAgKiBQcmV2aW91c2x5IHdlIG1hZGUgR2VuZXJhdGVDb250ZW50Q29uZmlnLnJlc3BvbnNlU2NoZW1hIGZpZWxkIHRvIGFjY2VwdFxuICAgICAqIHVua25vd24uIFNpbmNlIHYxLjkuMCwgd2Ugc3dpdGNoIHRvIHVzZSBiYWNrZW5kIEpTT04gc2NoZW1hIHN1cHBvcnQuXG4gICAgICogVG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgd2UgbW92ZSB0aGUgZGF0YSB0aGF0IHdhcyB0cmVhdGVkIGFzXG4gICAgICogSlNPTiBzY2hlbWEgZnJvbSB0aGUgcmVzcG9uc2VTY2hlbWEgZmllbGQgdG8gdGhlIHJlc3BvbnNlSnNvblNjaGVtYSBmaWVsZC5cbiAgICAgKi9cbiAgICBtYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJiBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5jb25maWcucmVzcG9uc2VKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWEpLmluY2x1ZGVzKCckc2NoZW1hJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy5yZXNwb25zZUpzb25TY2hlbWEgPSBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBDYWxsYWJsZVRvb2xzIGluIHRoZSBwYXJhbWV0ZXJzIHRvIGJlIHNpbXBseSBUb29scywgaXRcbiAgICAgKiBjb3BpZXMgdGhlIHBhcmFtcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZXMgdGhlIHRvb2xzLCBpdCBkb2VzIG5vdFxuICAgICAqIG1vZGlmeSB0aGUgb3JpZ2luYWwgcGFyYW1zLiBBbHNvIHNldHMgdGhlIE1DUCB1c2FnZSBoZWFkZXIgaWYgdGhlcmUgYXJlXG4gICAgICogTUNQIHRvb2xzIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGFzeW5jIHByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdG9vbHMgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHM7XG4gICAgICAgIGlmICghdG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRUb29scyA9IGF3YWl0IFByb21pc2UuYWxsKHRvb2xzLm1hcChhc3luYyAodG9vbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b29sO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogcGFyYW1zLmNvbnRlbnRzLFxuICAgICAgICAgICAgY29uZmlnOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcy5jb25maWcpLCB7IHRvb2xzOiB0cmFuc2Zvcm1lZFRvb2xzIH0pLFxuICAgICAgICB9O1xuICAgICAgICBuZXdQYXJhbXMuY29uZmlnLnRvb2xzID0gdHJhbnNmb3JtZWRUb29scztcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiZcbiAgICAgICAgICAgIHBhcmFtcy5jb25maWcudG9vbHMgJiZcbiAgICAgICAgICAgIGhhc01jcFRvb2xVc2FnZShwYXJhbXMuY29uZmlnLnRvb2xzKSkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IChfYyA9IChfYiA9IHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fTtcbiAgICAgICAgICAgIGxldCBuZXdIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3SGVhZGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV3SGVhZGVycyA9IHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihuZXdIZWFkZXJzKTtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpLCB7IGhlYWRlcnM6IG5ld0hlYWRlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgaW5pdEFmY1Rvb2xzTWFwKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgYWZjVG9vbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xEZWNsYXJhdGlvbiA9IGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiAoX2MgPSB0b29sRGVjbGFyYXRpb24uZnVuY3Rpb25EZWNsYXJhdGlvbnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVjbGFyYXRpb24ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBkZWNsYXJhdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZmNUb29scy5oYXMoZGVjbGFyYXRpb24ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIHRvb2wgZGVjbGFyYXRpb24gbmFtZTogJHtkZWNsYXJhdGlvbi5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFmY1Rvb2xzLnNldChkZWNsYXJhdGlvbi5uYW1lLCBjYWxsYWJsZVRvb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWZjVG9vbHM7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtYXhSZW1vdGVDYWxscyA9IChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhpbXVtUmVtb3RlQ2FsbHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUztcbiAgICAgICAgbGV0IHdlcmVGdW5jdGlvbnNDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlbW90ZUNhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGFmY1Rvb2xzTWFwID0gYXdhaXQgdGhpcy5pbml0QWZjVG9vbHNNYXAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAobW9kZWxzLCBhZmNUb29scywgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYywgZV8xLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxDb3VudCA8IG1heFJlbW90ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZXJlRnVuY3Rpb25zQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVDYWxsQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlcmVGdW5jdGlvbnNDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgcmVzcG9uc2VfMSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UpKSwgcmVzcG9uc2VfMV8xOyByZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KHJlc3BvbnNlXzEubmV4dCgpKSwgX2MgPSByZXNwb25zZV8xXzEuZG9uZSwgIV9jOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZSA9IHJlc3BvbnNlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmNhbmRpZGF0ZXMgJiYgKChfYSA9IGNodW5rLmNhbmRpZGF0ZXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRlbnRzLnB1c2goY2h1bmsuY2FuZGlkYXRlc1swXS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfYiA9IGNodW5rLmNhbmRpZGF0ZXNbMF0uY29udGVudC5wYXJ0cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscyAmJiBwYXJ0LmZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydC5mdW5jdGlvbkNhbGwubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGwgbmFtZSB3YXMgbm90IHJldHVybmVkIGJ5IHRoZSBtb2RlbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmNUb29scy5oYXMocGFydC5mdW5jdGlvbkNhbGwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyB3YXMgcmVxdWVzdGVkLCBidXQgbm90IGFsbCB0aGUgdG9vbHMgdGhlIG1vZGVsIHVzZWQgaW1wbGVtZW50IHRoZSBDYWxsYWJsZVRvb2wgaW50ZXJmYWNlLiBBdmFpbGFibGUgdG9vbHM6ICR7YWZjVG9vbHMua2V5cygpfSwgbWlzaW5nIHRvb2w6ICR7cGFydC5mdW5jdGlvbkNhbGwubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUGFydHMgPSB5aWVsZCBfX2F3YWl0KGFmY1Rvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbFRvb2woW3BhcnQuZnVuY3Rpb25DYWxsXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcy5wdXNoKC4uLnJlc3BvbnNlUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2MgJiYgKF9kID0gcmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9kLmNhbGwocmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvblJlc3BvbnNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcG9uc2VDaHVuayA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRSZXNwb25zZUNodW5rLmNhbmRpZGF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcG9uc2VDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudHMucHVzaCguLi5yZXNwb25zZUNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb250ZW50cyA9IHRDb250ZW50cyhwYXJhbXMuY29udGVudHMpLmNvbmNhdChuZXdDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29udGVudHMgPSB1cGRhdGVkQ29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSh0aGlzLCBhZmNUb29sc01hcCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpnZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzFfMTsgYXBpUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8xLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BbJ3Nka0h0dHBSZXNwb25zZSddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBjaHVuay5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gYXBpUmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoYXBpUmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06c3RyZWFtR2VuZXJhdGVDb250ZW50P2FsdD1zc2UnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXBpQ2xpZW50LnJlcXVlc3RTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChhcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgYXBpUmVzcG9uc2VfMiA9IF9fYXN5bmNWYWx1ZXMoYXBpUmVzcG9uc2UpLCBhcGlSZXNwb25zZV8yXzE7IGFwaVJlc3BvbnNlXzJfMSA9IHlpZWxkIF9fYXdhaXQoYXBpUmVzcG9uc2VfMi5uZXh0KCkpLCBfYSA9IGFwaVJlc3BvbnNlXzJfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gYXBpUmVzcG9uc2VfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BbJ3Nka0h0dHBSZXNwb25zZSddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBjaHVuay5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gYXBpUmVzcG9uc2VfMi5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoYXBpUmVzcG9uc2VfMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGVtYmVkZGluZ3MgZm9yIHRoZSBnaXZlbiBjb250ZW50cy4gT25seSB0ZXh0IGlzIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZW1iZWRkaW5nIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5lbWJlZENvbnRlbnQoe1xuICAgICAqICBtb2RlbDogJ3RleHQtZW1iZWRkaW5nLTAwNCcsXG4gICAgICogIGNvbnRlbnRzOiBbXG4gICAgICogICAgJ1doYXQgaXMgeW91ciBuYW1lPycsXG4gICAgICogICAgJ1doYXQgaXMgeW91ciBmYXZvcml0ZSBjb2xvcj8nLFxuICAgICAqICBdLFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBvdXRwdXREaW1lbnNpb25hbGl0eTogNjQsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkQ29udGVudChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRW1iZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEVtYmVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGVkaXRpbmcgYW4gaW1hZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVkaXRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgdXBzY2FsaW5nIGFuIGltYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHVwc2NhbGVJbWFnZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcHNjYWxlSW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb250ZXh0dWFsaXplcyBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgcmVjb250ZXh0dWFsaXphdGlvbiBjdXJyZW50bHkgc3VwcG9ydGVkOlxuICAgICAqIDEpIEltYWdlbiBQcm9kdWN0IFJlY29udGV4dCAtIEdlbmVyYXRlIGltYWdlcyBvZiBwcm9kdWN0cyBpbiBuZXcgc2NlbmVzXG4gICAgICogICAgYW5kIGNvbnRleHRzLlxuICAgICAqIDIpIFZpcnR1YWwgVHJ5LU9uOiBHZW5lcmF0ZSBpbWFnZXMgb2YgcGVyc29ucyBtb2RlbGluZyBmYXNoaW9uIHByb2R1Y3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciByZWNvbnRleHR1YWxpemluZyBhbiBpbWFnZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UxID0gYXdhaXQgYWkubW9kZWxzLnJlY29udGV4dEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZW4tcHJvZHVjdC1yZWNvbnRleHQtcHJldmlldy0wNi0zMCcsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIHByb21wdDogJ0luIGEgbW9kZXJuIGtpdGNoZW4gc2V0dGluZy4nLFxuICAgICAqICAgIHByb2R1Y3RJbWFnZXM6IFtwcm9kdWN0SW1hZ2VdLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZTE/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBhaS5tb2RlbHMucmVjb250ZXh0SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ3ZpcnR1YWwtdHJ5LW9uLXByZXZpZXctMDgtMDQnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBwZXJzb25JbWFnZTogcGVyc29uSW1hZ2UsXG4gICAgICogICAgcHJvZHVjdEltYWdlczogW3Byb2R1Y3RJbWFnZV0sXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlMj8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWNvbnRleHRJbWFnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHJlY29udGV4dEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFJlY29udGV4dEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZ21lbnRzIGFuIGltYWdlLCBjcmVhdGluZyBhIG1hc2sgb2YgYSBzcGVjaWZpZWQgYXJlYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3Igc2VnbWVudGluZyBhbiBpbWFnZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuc2VnbWVudEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZS1zZWdtZW50YXRpb24tMDAxJyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgaW1hZ2U6IGltYWdlLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBtb2RlOiAnZm9yZWdyb3VuZCcsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZE1hc2tzPy5bMF0/Lm1hc2s/LmltYWdlQnl0ZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlZ21lbnRJbWFnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNlZ21lbnRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gc2VnbWVudEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgU2VnbWVudEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBtb2RlbCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG1vZGVsSW5mbyA9IGF3YWl0IGFpLm1vZGVscy5nZXQoe21vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbHNfdXJsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RNb2RlbHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsc191cmx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0TW9kZWxzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSB0dW5lZCBtb2RlbCBieSBpdHMgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdXBkYXRpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy51cGRhdGUoe1xuICAgICAqICAgbW9kZWw6ICd0dW5lZC1tb2RlbC1uYW1lJyxcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICBkaXNwbGF5TmFtZTogJ05ldyBkaXNwbGF5IG5hbWUnLFxuICAgICAqICAgICBkZXNjcmlwdGlvbjogJ05ldyBkZXNjcmlwdGlvbicsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgdHVuZWQgbW9kZWwgYnkgaXRzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGRlbGV0aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZGVsZXRlKHttb2RlbDogJ3R1bmVkLW1vZGVsLW5hbWUnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVNb2RlbFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlTW9kZWxSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb250ZW50cy4gTXVsdGltb2RhbCBpbnB1dCBpc1xuICAgICAqIHN1cHBvcnRlZCBmb3IgR2VtaW5pIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb3VudFRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50VG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvdW50VG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBjb250ZW50cywgcmV0dXJucyBhIGNvcnJlc3BvbmRpbmcgVG9rZW5zSW5mbyBjb250YWluaW5nXG4gICAgICogdGhlIGxpc3Qgb2YgdG9rZW5zIGFuZCBsaXN0IG9mIHRva2VuIGlkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb21wdXRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb21wdXRlVG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdXaGF0IGlzIHlvdXIgbmFtZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvbXB1dGVUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb21wdXRlVG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb21wdXRlVG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY29tcHV0ZVRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvbXB1dGVUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGdlbmVyYXRpbmcgdmlkZW9zLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlVmlkZW9zSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0TG9uZ1J1bm5pbmcnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0TG9uZ1J1bm5pbmcnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBPcGVyYXRpb25zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgb3BlcmF0aW9uIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBPcGVyYXRpb24gb2JqZWN0LCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIG9yIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWaWRlb3NPcGVyYXRpb24ocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJhbWV0ZXJzLm9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gcGFyYW1ldGVycy5jb25maWc7XG4gICAgICAgIGlmIChvcGVyYXRpb24ubmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbi5uYW1lID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBvcGVyYXRpb24ubmFtZS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmICdodHRwT3B0aW9ucycgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU5hbWU6IHJlc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHsgaHR0cE9wdGlvbnM6IGh0dHBPcHRpb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiByZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IGh0dHBPcHRpb25zOiBodHRwT3B0aW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgaXNWZXJ0ZXhBSTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5nZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRleEFJOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tvcGVyYXRpb25OYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cmVzb3VyY2VOYW1lfTpmZXRjaFByZWRpY3RPcGVyYXRpb24nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXdTZXNzaW9uRXhwaXJlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyduZXdTZXNzaW9uRXhwaXJlVGltZSddLCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXNlcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVVzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndXNlcyddLCBmcm9tVXNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGl2ZUNvbm5lY3RDb25zdHJhaW50cycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddLCBsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldihhcGlDbGllbnQsIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvY2tBZGRpdGlvbmFsRmllbGRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2ZpZWxkTWFzayddLCBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldihmcm9tU2Vzc2lvblJlc3VtcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIGZyb21SZWFsdGltZUlucHV0Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgZnJvbVByb2FjdGl2aXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcGFyZW50IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldihmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzIGZyb20gYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHNldHVwIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmaWVsZCBtYXNrcyBmcm9tLlxuICogQHJldHVybiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzLlxuICovXG5mdW5jdGlvbiBnZXRGaWVsZE1hc2tzKHNldHVwKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR1cCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXR1cFtrZXldO1xuICAgICAgICAgICAgLy8gMm5kIGxheWVyLCByZWN1cnNpdmVseSBnZXQgZmllbGQgbWFza3Mgc2VlIFRPRE8oYi80MTgyOTAxMDApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2spID0+IGAke2tleX0uJHtra31gKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChrZXkpOyAvLyAxc3QgbGF5ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLlxuICogQHBhcmFtIHJlcXVlc3REaWN0IC0gVGhlIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIC0gVGhlIG1vZGlmaWVkIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChyZXF1ZXN0RGljdCwgY29uZmlnKSB7XG4gICAgLy8gQ29udmVydCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgZnJvbSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuc2V0dXAuXG4gICAgbGV0IHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBudWxsO1xuICAgIGNvbnN0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID0gcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIGlmICh0eXBlb2YgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICdzZXR1cCcgaW4gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUpIHtcbiAgICAgICAgLy8gTm93IHdlIGtub3cgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYSAnc2V0dXAnXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBjb25zdCBpbm5lclNldHVwID0gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWVcbiAgICAgICAgICAgIC5zZXR1cDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclNldHVwID09PSAnb2JqZWN0JyAmJiBpbm5lclNldHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBpbm5lciBzZXR1cCBmb3VuZC5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSA9IGlubmVyU2V0dXA7XG4gICAgICAgICAgICBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gaW5uZXJTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZS5zZXR1cGAgaXMgbm90IGEgdmFsaWQgb2JqZWN0OyB0cmVhdCBhc1xuICAgICAgICAgICAgLy8gaWYgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGlzIGludmFsaWQuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgZXhpc3RzIGJ1dCBub3QgaW4gdGhlIGV4cGVjdGVkXG4gICAgICAgIC8vIHNoYXBlIHtzZXR1cDogey4uLn19OyB0cmVhdCBhcyBpbnZhbGlkLlxuICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIH1cbiAgICBjb25zdCBwcmVFeGlzdGluZ0ZpZWxkTWFzayA9IHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAvLyBIYW5kbGUgbWFzayBnZW5lcmF0aW9uIHNldHVwLlxuICAgIGlmIChzZXR1cEZvck1hc2tHZW5lcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE1hc2tGcm9tQmlkaSA9IGdldEZpZWxkTWFza3Moc2V0dXBGb3JNYXNrR2VuZXJhdGlvbik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAxOiBsb2NrQWRkaXRpb25hbEZpZWxkcyBpcyBhbiBlbXB0eSBhcnJheS4gTG9jayBvbmx5IGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAvLyBiaWRpIHNldHVwLlxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIG1hc2sgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZ2VuZXJhdGVkTWFza0Zyb21CaWRpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTsgLy8gSWYgbWFzayBpcyBlbXB0eSwgZWZmZWN0aXZlbHkgbm9cbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBmaWVsZHMgbG9ja2VkIGJ5IGJpZGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAyOiBMb2NrIGZpZWxkcyBmcm9tIGJpZGkgc2V0dXAgKyBhZGRpdGlvbmFsIGZpZWxkc1xuICAgICAgICAgICAgLy8gKHByZUV4aXN0aW5nRmllbGRNYXNrKS5cbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWdGaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgICAgICAgICAndG9wSycsXG4gICAgICAgICAgICAgICAgJ3RvcFAnLFxuICAgICAgICAgICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgICAgICAgICAgICAgICdzZWVkJyxcbiAgICAgICAgICAgICAgICAnc3BlZWNoQ29uZmlnJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gW107XG4gICAgICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IHByZUV4aXN0aW5nRmllbGRNYXNrLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25Db25maWdGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGdlbmVyYXRpb25Db25maWcuJHtmaWVsZH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDsgLy8gS2VlcCBvcmlnaW5hbCBmaWVsZCBuYW1lIGlmIG5vdCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBnZW5lcmF0aW9uQ29uZmlnRmllbGRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hc2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goZ2VuZXJhdGVkTWFza0Zyb21CaWRpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goLi4ubWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbE1hc2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZmluYWxNYXNrUGFydHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZmllbGRzIGZyb20gYmlkaSBhbmQgbm8gdmFsaWQgYWRkaXRpb25hbCBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHByZS1leGlzdGluZyBtYXNrLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXNlIDM6IFwiTG9jayBhbGwgZmllbGRzXCIgKG1lYW5pbmcsIGRvbid0IHNlbmQgYSBmaWVsZF9tYXNrLCBsZXQgc2VydmVyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cyBhcHBseSBvciBhbGwgYXJlIG11dGFibGUpLiBUaGlzIGlzIGhpdCBpZjpcbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIG5vbi1lbXB0eSwgQlVUXG4gICAgICAgICAgICAvLyAgYHByZUV4aXN0aW5nRmllbGRNYXNrYCBpcyBudWxsLCBub3QgYSBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIHdhcyBmb3VuZCBvciBleHRyYWN0ZWQuXG4gICAgICAgIC8vIFwiTG9jayBhZGRpdGlvbmFsIG51bGwgZmllbGRzIGlmIGFueVwiLlxuICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJlLWV4aXN0aW5nIGZpZWxkIG1hc2ssIGl0J3MgYSBzdHJpbmcsIGFuZCBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gZW1wdHksIHRoZW4gd2Ugc2hvdWxkIGxvY2sgYWxsIGZpZWxkcy5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IHByZUV4aXN0aW5nRmllbGRNYXNrLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3REaWN0O1xufVxuY2xhc3MgVG9rZW5zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVwaGVtZXJhbCBhdXRoIHRva2VuIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFcGhlbWVyYWwgYXV0aCB0b2tlbnMgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvbiBjb25uZWN0aW9uIHRvIHRoZSBMaXZlIGNvbnN0cmFpbmVkIEFQSS5cbiAgICAgKiBTdXBwb3J0IGluIHYxYWxwaGEgb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNyZWF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYXV0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gICAgICogICAgIGFwaUtleTogdG9rZW4ubmFtZSxcbiAgICAgKiAgICAgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH0gIC8vIFN1cHBvcnQgaW4gdjFhbHBoYSBvbmx5LlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAxOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyB1bnNldCwgdW5sb2NrIExpdmVDb25uZWN0Q29uZmlnXG4gICAgICogLy8gd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEVhY2ggc2Vzc2lvbiBjb25uZWN0aW9uIGNhblxuICAgICAqIC8vIHVzZSBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID0ge1xuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMjogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0LCBsb2NrIGFsbCBmaWVsZHMgaW5cbiAgICAgKiAvLyBMaXZlQ29ubmVjdENvbmZpZyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRm9yXG4gICAgICogLy8gZXhhbXBsZSwgY2hhbmdpbmcgYG91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbmAgaW4gdGhlIExpdmUgQVBJXG4gICAgICogLy8gY29ubmVjdGlvbiB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIEFQSS5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDM6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBzZXQsIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgYW5kIGFkZGl0aW9uYWwgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiwgdGVtcGVyYXR1cmUgaW4gdGhpcyBleGFtcGxlKSB3aGVuXG4gICAgICogLy8gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFsndGVtcGVyYXR1cmUnXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDQ6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBlbXB0eSBhcnJheSwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uIGluIHRoaXMgZXhhbXBsZSkgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAvLyB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGllbnQudG9rZW5zLmNyZWF0ZSBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYXV0aF90b2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJvZHkgPSBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKGJvZHksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBHT09HTEVfQVBJX0tFWV9IRUFERVIgPSAneC1nb29nLWFwaS1rZXknO1xuY29uc3QgUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0nO1xuY2xhc3MgTm9kZUF1dGgge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0cy5hcGlLZXk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVydGV4QXV0aE9wdGlvbnMgPSBidWlsZEdvb2dsZUF1dGhPcHRpb25zKG9wdHMuZ29vZ2xlQXV0aE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdvb2dsZUF1dGggPSBuZXcgR29vZ2xlQXV0aCh2ZXJ0ZXhBdXRoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCkge1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpS2V5LnN0YXJ0c1dpdGgoJ2F1dGhfdG9rZW5zLycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcGhlbWVyYWwgdG9rZW5zIGFyZSBvbmx5IHN1cHBvcnRlZCBieSB0aGUgbGl2ZSBBUEkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEtleUhlYWRlcihoZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGRHb29nbGVBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpO1xuICAgIH1cbiAgICBhZGRLZXlIZWFkZXIoaGVhZGVycykge1xuICAgICAgICBpZiAoaGVhZGVycy5nZXQoR09PR0xFX0FQSV9LRVlfSEVBREVSKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAvLyB3aGVuIGFwaUtleSBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgQVBJIGtleSBoZWFkZXIgYnV0IGFwaUtleSBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5hcHBlbmQoR09PR0xFX0FQSV9LRVlfSEVBREVSLCB0aGlzLmFwaUtleSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCkge1xuICAgICAgICBpZiAodGhpcy5nb29nbGVBdXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYWRkR29vZ2xlQXV0aEhlYWRlcnMgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFwaUtleSBzZXQgYW5kIGluIHRoZXNlIGNhc2VzIGdvb2dsZUF1dGhcbiAgICAgICAgICAgIC8vIGlzIHNldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHNldCBnb29nbGUtYXV0aCBoZWFkZXJzIGJ1dCBnb29nbGVBdXRoIGlzIHVuc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCB0aGlzLmdvb2dsZUF1dGguZ2V0UmVxdWVzdEhlYWRlcnModXJsKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXV0aEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmdldChrZXkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMoZ29vZ2xlQXV0aE9wdGlvbnMpIHtcbiAgICBsZXQgYXV0aE9wdGlvbnM7XG4gICAgaWYgKCFnb29nbGVBdXRoT3B0aW9ucykge1xuICAgICAgICBhdXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNjb3BlczogW1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRV0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhPcHRpb25zID0gZ29vZ2xlQXV0aE9wdGlvbnM7XG4gICAgICAgIGlmICghYXV0aE9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMgPSBbUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFXTtcbiAgICAgICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodHlwZW9mIGF1dGhPcHRpb25zLnNjb3BlcyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3BlcyAhPT0gUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoYXV0aE9wdGlvbnMuc2NvcGVzKSAmJlxuICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3Blcy5pbmRleE9mKFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSkgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF1dGggc2NvcGVzLiBTY29wZXMgbXVzdCBpbmNsdWRlOiAke1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlRG93bmxvYWRlciB7XG4gICAgYXN5bmMgZG93bmxvYWQocGFyYW1zLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5kb3dubG9hZFBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG93bmxvYWRGaWxlKHBhcmFtcywgYXBpQ2xpZW50KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlU3RyZWFtKHBhcmFtcy5kb3dubG9hZFBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBSZWFkYWJsZS5mcm9tV2ViKHJlc3BvbnNlLnJlc3BvbnNlSW50ZXJuYWwuYm9keSk7XG4gICAgICAgICAgICAgICAgYm9keS5waXBlKHdyaXRlcik7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQod3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZShwYXJhbXMuZG93bmxvYWRQYXRoLCByZXNwb25zZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHdyaXRlIGZpbGUgdG8gJHtwYXJhbXMuZG93bmxvYWRQYXRofTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUocGFyYW1zLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBuYW1lID0gdEZpbGVOYW1lKHBhcmFtcy5maWxlKTtcbiAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBgZmlsZXMvJHtuYW1lfTpkb3dubG9hZGAsXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgJ2FsdCc6ICdtZWRpYScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0dlbmVyYXRlZFZpZGVvKHBhcmFtcy5maWxlKSkge1xuICAgICAgICBjb25zdCB2aWRlb0J5dGVzID0gKF9jID0gcGFyYW1zLmZpbGUudmlkZW8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52aWRlb0J5dGVzO1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvQnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIGdlbmVyYXRlZCB2aWRlbywgVXJpIG9yIHZpZGVvQnl0ZXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVmlkZW8ocGFyYW1zLmZpbGUpKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvQnl0ZXMgPSBwYXJhbXMuZmlsZS52aWRlb0J5dGVzO1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvQnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIHZpZGVvLCBVcmkgb3IgdmlkZW9CeXRlcyBub3QgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmlsZSB0eXBlJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgY3JlYXRlKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVdlYlNvY2tldCh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcyk7XG4gICAgfVxufVxuY2xhc3MgTm9kZVdlYlNvY2tldCB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLndzID0gbmV3IE5vZGVXcy5XZWJTb2NrZXQodGhpcy51cmwsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IHRoaXMuY2FsbGJhY2tzLm9ub3BlbjtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gdGhpcy5jYWxsYmFja3Mub25lcnJvcjtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5jYWxsYmFja3Mub25jbG9zZTtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLmNhbGxiYWNrcy5vbm1lc3NhZ2U7XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWxpZGF0aW9uRGF0YXNldCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc2NyaXB0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXBvY2hDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdlcG9jaENvdW50J10sIGZyb21FcG9jaENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJ10sIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGFwdGVyU2l6ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWRhcHRlclNpemUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmF0Y2hTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2JhdGNoU2l6ZSddLCBmcm9tQmF0Y2hTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGVhcm5pbmdSYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZSddLCBmcm9tTGVhcm5pbmdSYXRlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmV0YSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmV0YSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGxldCBkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbVZhbGlkYXRpb25EYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZhbGlkYXRpb25EYXRhc2V0JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21WYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICd2YWxpZGF0aW9uRGF0YXNldCcsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZhbGlkYXRpb25EYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyddLCB0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4KGZyb21WYWxpZGF0aW9uRGF0YXNldCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUVwb2NoQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoQ291bnQnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXBvY2hDb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgW1xuICAgICAgICAgICAgICAgICdwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsXG4gICAgICAgICAgICAgICAgJ2h5cGVyUGFyYW1ldGVycycsXG4gICAgICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICAgICAgXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgWydjb25maWcnLCAnbWV0aG9kJ10pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10sIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddLCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tQWRhcHRlclNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkYXB0ZXJTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnYWRhcHRlclNpemUnXSwgZnJvbUFkYXB0ZXJTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhdGNoU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xlYXJuaW5nUmF0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVhcm5pbmdSYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJldGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JldGEnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CZXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdiZXRhJ10sIGZyb21CZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWluaW5nRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyYWluaW5nRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmFpbmluZ0RhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tVHJhaW5pbmdEYXRhc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHR1bmluZ0RhdGFzZXRUb1ZlcnRleChmcm9tVHJhaW5pbmdEYXRhc2V0LCB0b09iamVjdCwgcm9vdE9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0LCByb290T2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuZWRNb2RlbHMnXSk7XG4gICAgaWYgKGZyb21UdW5pbmdKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21UdW5pbmdKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYkZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5pbmdKb2JzJ10pO1xuICAgIGlmIChmcm9tVHVuaW5nSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVHVuaW5nSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdKb2JGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRwb2ludCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kcG9pbnQnXSwgZnJvbUVuZHBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRGF0YXNldFRvTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnRleERhdGFzZXRSZXNvdXJjZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVydGV4RGF0YXNldFJlc291cmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZXMnXSk7XG4gICAgaWYgKGZyb21FeGFtcGxlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRXhhbXBsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGVzJywgJ2V4YW1wbGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0RhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGxldCBkaXNjcmltaW5hdG9yR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JHY3NVcmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yR2NzVXJpID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckdjc1VyaSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yR2NzVXJpID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UnLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhhbXBsZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0VHVuaW5nSm9iU3RhdHVzKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnc3RhcnRUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdUYXNrJyxcbiAgICAgICAgJ2NvbXBsZXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsJ10sIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0VHVuaW5nSm9iU3RhdHVzKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbCddLCBmcm9tVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVUdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlVHVuZWRNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVUdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlVHVuZWRNb2RlbCddLCBmcm9tUHJlVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cGVydmlzZWRUdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnXSwgZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyddLCBmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nRGF0YVN0YXRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nRGF0YVN0YXRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVR1bmluZ0RhdGFTdGF0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0RhdGFTdGF0cyddLCBmcm9tVHVuaW5nRGF0YVN0YXRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuY3J5cHRpb25TcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5jcnlwdGlvblNwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5jcnlwdGlvblNwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNyeXB0aW9uU3BlYyddLCBmcm9tRW5jcnlwdGlvblNwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcnRuZXJNb2RlbFR1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRuZXJNb2RlbFR1bmluZ1NwZWMnXSwgZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3VzdG9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tQmFzZU1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUN1c3RvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2N1c3RvbUJhc2VNb2RlbCddLCBmcm9tQ3VzdG9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGVyaW1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSk7XG4gICAgaWYgKGZyb21FeHBlcmltZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwZXJpbWVudCddLCBmcm9tRXhwZXJpbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0VXJpJ10pO1xuICAgIGlmIChmcm9tT3V0cHV0VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VXJpJ10sIGZyb21PdXRwdXRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGlwZWxpbmVKb2IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10pO1xuICAgIGlmIChmcm9tUGlwZWxpbmVKb2IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwaXBlbGluZUpvYiddLCBmcm9tUGlwZWxpbmVKb2IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmljZUFjY291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2aWNlQWNjb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2aWNlQWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZpY2VBY2NvdW50J10sIGZyb21TZXJ2aWNlQWNjb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVvVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Zlb1R1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmVvVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Zlb1R1bmluZ1NwZWMnXSwgZnJvbVZlb1R1bmluZ1NwZWMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIFR1bmluZ3MgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgVHVuaW5nSm9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSByZXNvdXJjZSBuYW1lIG9mIHRoZSB0dW5pbmcgam9iLlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBUdW5pbmdKb2Igb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIC0gVGhlIFNESydzIHR1bmluZyBpbXBsZW1lbnRhdGlvbiBpcyBleHBlcmltZW50YWwsIGFuZCBtYXlcbiAgICAgICAgICogY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0SW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIGxpc3Qgb2YgdHVuaW5nIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX1RVTklOR19KT0JTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50dW5lID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmFzZU1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZVR1bmVkTW9kZWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZTogcGFyYW1zLmJhc2VNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVUdW5lZE1vZGVsLmNoZWNrcG9pbnRJZCA9IHBhcmFtcy5jb25maWcucHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByZVR1bmVkTW9kZWw6IHByZVR1bmVkTW9kZWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1ByaXZhdGUuYmFzZU1vZGVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHVuZUludGVybmFsKHBhcmFtc1ByaXZhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IHRoaXMudHVuZU1sZGV2SW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHR1bmVkTW9kZWxOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvblsnbWV0YWRhdGEnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ21ldGFkYXRhJ11bJ3R1bmVkTW9kZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uWyduYW1lJ10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25bJ25hbWUnXS5pbmNsdWRlcygnL29wZXJhdGlvbnMvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ25hbWUnXS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR1bmluZ0pvYiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHVuZWRNb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBKb2JTdGF0ZS5KT0JfU1RBVEVfUVVFVUVELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RUdW5pbmdKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmVkTW9kZWxzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIHR1bmluZyBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLnR1bmluZ3MuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvVmVydGV4KHBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHR1bmVNbGRldkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmVkTW9kZWxzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBNQVhfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0ICogODsgLy8gYnl0ZXNcbmNvbnN0IE1BWF9SRVRSWV9DT1VOVCA9IDM7XG5jb25zdCBJTklUSUFMX1JFVFJZX0RFTEFZX01TID0gMTAwMDtcbmNvbnN0IERFTEFZX01VTFRJUExJRVIgPSAyO1xuY29uc3QgWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEID0gJ3gtZ29vZy11cGxvYWQtc3RhdHVzJztcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJsb2IoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UobmV3IFJlc3BvbnNlKCkpO1xuICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgZmlsZVNpemUgPSBmaWxlLnNpemU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnREZWxheU1zID0gSU5JVElBTF9SRVRSWV9ERUxBWV9NUztcbiAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGNodW5rU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgY3VycmVudERlbGF5TXMgPSBjdXJyZW50RGVsYXlNcyAqIERFTEFZX01VTFRJUExJRVI7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgLy8gVGhlIGB4LWdvb2ctdXBsb2FkLXN0YXR1c2AgaGVhZGVyIGZpZWxkIGNhbiBiZSBgYWN0aXZlYCwgYGZpbmFsYCBhbmRcbiAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhiLzQwMTM5MTQzMCkgSW52ZXN0aWdhdGUgd2h5IHRoZSB1cGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWRcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggYWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQuXG4gICAgICAgIGlmIChmaWxlU2l6ZSA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgIGlmICgoKF9jID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZTogVXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iU3RhdChmaWxlKSB7XG4gICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IGZpbGUuc2l6ZSwgdHlwZTogZmlsZS50eXBlIH07XG4gICAgcmV0dXJuIGZpbGVTdGF0O1xufVxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmVQcm9taXNlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmVQcm9taXNlLCBtcykpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlVXBsb2FkZXIge1xuICAgIGFzeW5jIHN0YXQoZmlsZSkge1xuICAgICAgICBjb25zdCBmaWxlU3RhdCA9IHsgc2l6ZTogMCwgdHlwZTogdW5kZWZpbmVkIH07XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhdCA9IGF3YWl0IGZzLnN0YXQoZmlsZSk7XG4gICAgICAgICAgICBmaWxlU3RhdC5zaXplID0gb3JpZ2luYWxTdGF0LnNpemU7XG4gICAgICAgICAgICBmaWxlU3RhdC50eXBlID0gdGhpcy5pbmZlck1pbWVUeXBlKGZpbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVTdGF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdldEJsb2JTdGF0KGZpbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51cGxvYWRGaWxlRnJvbVBhdGgoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZEJsb2IoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZmVycyB0aGUgTUlNRSB0eXBlIG9mIGEgZmlsZSBiYXNlZCBvbiBpdHMgZXh0ZW5zaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIFRoZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm5zIFRoZSBNSU1FIHR5cGUgb2YgdGhlIGZpbGUsIG9yIHVuZGVmaW5lZCBpZiBpdCBjYW5ub3QgYmUgaW5mZXJyZWQuXG4gICAgICovXG4gICAgaW5mZXJNaW1lVHlwZShmaWxlUGF0aCkge1xuICAgICAgICAvLyBHZXQgdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZmlsZVBhdGguc2xpY2UoZmlsZVBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgZmlsZSBleHRlbnNpb25zIHRvIE1JTUUgdHlwZXMuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlcyA9IHtcbiAgICAgICAgICAgICdhYWMnOiAnYXVkaW8vYWFjJyxcbiAgICAgICAgICAgICdhYncnOiAnYXBwbGljYXRpb24veC1hYml3b3JkJyxcbiAgICAgICAgICAgICdhcmMnOiAnYXBwbGljYXRpb24veC1mcmVlYXJjJyxcbiAgICAgICAgICAgICdhdmknOiAndmlkZW8veC1tc3ZpZGVvJyxcbiAgICAgICAgICAgICdhencnOiAnYXBwbGljYXRpb24vdm5kLmFtYXpvbi5lYm9vaycsXG4gICAgICAgICAgICAnYmluJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAnYm1wJzogJ2ltYWdlL2JtcCcsXG4gICAgICAgICAgICAnYnonOiAnYXBwbGljYXRpb24veC1iemlwJyxcbiAgICAgICAgICAgICdiejInOiAnYXBwbGljYXRpb24veC1iemlwMicsXG4gICAgICAgICAgICAnY3NoJzogJ2FwcGxpY2F0aW9uL3gtY3NoJyxcbiAgICAgICAgICAgICdjc3MnOiAndGV4dC9jc3MnLFxuICAgICAgICAgICAgJ2Nzdic6ICd0ZXh0L2NzdicsXG4gICAgICAgICAgICAnZG9jJzogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gICAgICAgICAgICAnZG9jeCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAnZW90JzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0JyxcbiAgICAgICAgICAgICdlcHViJzogJ2FwcGxpY2F0aW9uL2VwdWIremlwJyxcbiAgICAgICAgICAgICdneic6ICdhcHBsaWNhdGlvbi9nemlwJyxcbiAgICAgICAgICAgICdnaWYnOiAnaW1hZ2UvZ2lmJyxcbiAgICAgICAgICAgICdodG0nOiAndGV4dC9odG1sJyxcbiAgICAgICAgICAgICdodG1sJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAnaWNvJzogJ2ltYWdlL3ZuZC5taWNyb3NvZnQuaWNvbicsXG4gICAgICAgICAgICAnaWNzJzogJ3RleHQvY2FsZW5kYXInLFxuICAgICAgICAgICAgJ2phcic6ICdhcHBsaWNhdGlvbi9qYXZhLWFyY2hpdmUnLFxuICAgICAgICAgICAgJ2pwZWcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAnanBnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJ2pzJzogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgICAgICAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdqc29ubGQnOiAnYXBwbGljYXRpb24vbGQranNvbicsXG4gICAgICAgICAgICAna21sJzogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbCcsXG4gICAgICAgICAgICAna216JzogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua216K3htbCcsXG4gICAgICAgICAgICAnbWpzJzogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgICAgICAnbXAzJzogJ2F1ZGlvL21wZWcnLFxuICAgICAgICAgICAgJ21wNCc6ICd2aWRlby9tcDQnLFxuICAgICAgICAgICAgJ21wZWcnOiAndmlkZW8vbXBlZycsXG4gICAgICAgICAgICAnbXBrZyc6ICdhcHBsaWNhdGlvbi92bmQuYXBwbGUuaW5zdGFsbGVyK3htbCcsXG4gICAgICAgICAgICAnb2R0JzogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dCcsXG4gICAgICAgICAgICAnb2dhJzogJ2F1ZGlvL29nZycsXG4gICAgICAgICAgICAnb2d2JzogJ3ZpZGVvL29nZycsXG4gICAgICAgICAgICAnb2d4JzogJ2FwcGxpY2F0aW9uL29nZycsXG4gICAgICAgICAgICAnb3B1cyc6ICdhdWRpby9vcHVzJyxcbiAgICAgICAgICAgICdvdGYnOiAnZm9udC9vdGYnLFxuICAgICAgICAgICAgJ3BuZyc6ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgJ3BkZic6ICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAgICAgJ3BocCc6ICdhcHBsaWNhdGlvbi94LWh0dHBkLXBocCcsXG4gICAgICAgICAgICAncHB0JzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JyxcbiAgICAgICAgICAgICdwcHR4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgJ3Jhcic6ICdhcHBsaWNhdGlvbi92bmQucmFyJyxcbiAgICAgICAgICAgICdydGYnOiAnYXBwbGljYXRpb24vcnRmJyxcbiAgICAgICAgICAgICdzaCc6ICdhcHBsaWNhdGlvbi94LXNoJyxcbiAgICAgICAgICAgICdzdmcnOiAnaW1hZ2Uvc3ZnK3htbCcsXG4gICAgICAgICAgICAnc3dmJzogJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJyxcbiAgICAgICAgICAgICd0YXInOiAnYXBwbGljYXRpb24veC10YXInLFxuICAgICAgICAgICAgJ3RpZic6ICdpbWFnZS90aWZmJyxcbiAgICAgICAgICAgICd0aWZmJzogJ2ltYWdlL3RpZmYnLFxuICAgICAgICAgICAgJ3RzJzogJ3ZpZGVvL21wMnQnLFxuICAgICAgICAgICAgJ3R0Zic6ICdmb250L3R0ZicsXG4gICAgICAgICAgICAndHh0JzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgJ3ZzZCc6ICdhcHBsaWNhdGlvbi92bmQudmlzaW8nLFxuICAgICAgICAgICAgJ3dhdic6ICdhdWRpby93YXYnLFxuICAgICAgICAgICAgJ3dlYmEnOiAnYXVkaW8vd2VibScsXG4gICAgICAgICAgICAnd2VibSc6ICd2aWRlby93ZWJtJyxcbiAgICAgICAgICAgICd3ZWJwJzogJ2ltYWdlL3dlYnAnLFxuICAgICAgICAgICAgJ3dvZmYnOiAnZm9udC93b2ZmJyxcbiAgICAgICAgICAgICd3b2ZmMic6ICdmb250L3dvZmYyJyxcbiAgICAgICAgICAgICd4aHRtbCc6ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnLFxuICAgICAgICAgICAgJ3hscyc6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICAgICAgICAgICAgJ3hsc3gnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnLFxuICAgICAgICAgICAgJ3htbCc6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgICAgICAgJ3h1bCc6ICdhcHBsaWNhdGlvbi92bmQubW96aWxsYS54dWwreG1sJyxcbiAgICAgICAgICAgICd6aXAnOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICAgICAgICAgICczZ3AnOiAndmlkZW8vM2dwcCcsXG4gICAgICAgICAgICAnM2cyJzogJ3ZpZGVvLzNncHAyJyxcbiAgICAgICAgICAgICc3eic6ICdhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQnLFxuICAgICAgICB9O1xuICAgICAgICAvLyBMb29rIHVwIHRoZSBNSU1FIHR5cGUgYmFzZWQgb24gdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IG1pbWVUeXBlc1tmaWxlRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIE1JTUUgdHlwZS5cbiAgICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRGaWxlRnJvbVBhdGgoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBmaWxlU2l6ZSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICAgICAgbGV0IHVwbG9hZENvbW1hbmQgPSAndXBsb2FkJztcbiAgICAgICAgbGV0IGZpbGVIYW5kbGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaWxlSGFuZGxlID0gYXdhaXQgZnMub3BlbihmaWxlLCAncicpO1xuICAgICAgICAgICAgaWYgKCFmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gb3BlbiBmaWxlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlU2l6ZSA9IChhd2FpdCBmaWxlSGFuZGxlLnN0YXQoKSkuc2l6ZTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIGNodW5rU2l6ZSA+PSBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJ5dGVzUmVhZDogYnl0ZXNSZWFkIH0gPSBhd2FpdCBmaWxlSGFuZGxlLnJlYWQoYnVmZmVyLCAwLCBjaHVua1NpemUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCAhPT0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlYWQgJHtjaHVua1NpemV9IGJ5dGVzIGZyb20gZmlsZSBhdCBvZmZzZXQgJHtvZmZzZXR9LiBieXRlcyBhY3R1YWxseSByZWFkOiAke2J5dGVzUmVhZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgQmxvYihbYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGVsYXlNcyA9IElOSVRJQUxfUkVUUllfREVMQVlfTVM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiB1cGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtT2Zmc2V0JzogU3RyaW5nKG9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IFN0cmluZyhieXRlc1JlYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChjdXJyZW50RGVsYXlNcyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgICAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgICAgICAgICAgaWYgKCgoX2MgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZUpzb25bJ2ZpbGUnXTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZmlsZSBoYW5kbGUgaXMgYWx3YXlzIGNsb3NlZFxuICAgICAgICAgICAgaWYgKGZpbGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmaWxlSGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IExBTkdVQUdFX0xBQkVMX1BSRUZJWCA9ICdnbC1ub2RlLyc7XG4vKipcbiAqIFRoZSBHb29nbGUgR2VuQUkgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIEdlbkFJIGZlYXR1cmVzIHRocm91Z2ggZWl0aGVyIHRoZSB7QGxpbmtcbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IEdlbWluaSBBUEl9IG9yXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IFZlcnRleCBBSVxuICogQVBJfS5cbiAqXG4gKiBUaGUge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy52ZXJ0ZXhhaX0gdmFsdWUgZGV0ZXJtaW5lcyB3aGljaCBvZiB0aGUgQVBJXG4gKiBzZXJ2aWNlcyB0byB1c2UuXG4gKlxuICogV2hlbiB1c2luZyB0aGUgR2VtaW5pIEFQSSwgYSB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLmFwaUtleX0gbXVzdCBhbHNvIGJlXG4gKiBzZXQuIFdoZW4gdXNpbmcgVmVydGV4IEFJLCBib3RoIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMucHJvamVjdH0gYW5kIHtAbGlua1xuICogR29vZ2xlR2VuQUlPcHRpb25zLmxvY2F0aW9ufSBtdXN0IGJlIHNldCwgb3IgYSB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYmUgc2V0IHdoZW4gdXNpbmcgRXhwcmVzcyBNb2RlLlxuICpcbiAqIEV4cGxpY2l0bHkgcGFzc2VkIGluIHZhbHVlcyBpbiB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zfSB3aWxsIGFsd2F5cyB0YWtlXG4gKiBwcmVjZWRlbmNlIG92ZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBJZiBib3RoIHByb2plY3QvbG9jYXRpb24gYW5kIGFwaV9rZXlcbiAqIGV4aXN0IGluIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHRoZSBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogSW5pdGlhbGl6aW5nIHRoZSBTREsgZm9yIHVzaW5nIHRoZSBHZW1pbmkgQVBJOlxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUl9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgVmVydGV4IEFJIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHtcbiAqICAgdmVydGV4YWk6IHRydWUsXG4gKiAgIHByb2plY3Q6ICdQUk9KRUNUX0lEJyxcbiAqICAgbG9jYXRpb246ICdQUk9KRUNUX0xPQ0FUSU9OJ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNsYXNzIEdvb2dsZUdlbkFJIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAvLyBWYWxpZGF0ZSBleHBsaWNpdGx5IHNldCBpbml0aWFsaXplciB2YWx1ZXMuXG4gICAgICAgIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QvbG9jYXRpb24gYW5kIEFQSSBrZXkgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBpbiB0aGUgY2xpZW50IGluaXRpYWxpemVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4YWkgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gb3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2V0Qm9vbGVhbkVudignR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSScpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgZW52QXBpS2V5ID0gZ2V0QXBpS2V5RnJvbUVudigpO1xuICAgICAgICBjb25zdCBlbnZQcm9qZWN0ID0gZ2V0RW52KCdHT09HTEVfQ0xPVURfUFJPSkVDVCcpO1xuICAgICAgICBjb25zdCBlbnZMb2NhdGlvbiA9IGdldEVudignR09PR0xFX0NMT1VEX0xPQ0FUSU9OJyk7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gKF9jID0gb3B0aW9ucy5hcGlLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGVudkFwaUtleTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKF9kID0gb3B0aW9ucy5wcm9qZWN0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBlbnZQcm9qZWN0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gKF9lID0gb3B0aW9ucy5sb2NhdGlvbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZW52TG9jYXRpb247XG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRvIHVzZSBWZXJ0ZXggQUkgaW4gZXhwcmVzcyBtb2RlIChhcGkga2V5KVxuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaWYgKChfZiA9IG9wdGlvbnMuZ29vZ2xlQXV0aE9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGNyZWRlbnRpYWxzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgR29vZ2xlIENsb3VkIGNyZWRlbnRpYWxzIHdpbGwgdGFrZSBwcmVjZWRlbmNlJyArXG4gICAgICAgICAgICAgICAgICAgICcgb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgYW5kIGV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gYWxyZWFkeSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICAgICAgaWYgKChlbnZQcm9qZWN0IHx8IGVudkxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IHByb2plY3QvbG9jYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgVmVydGV4IEFJIEFQSSBrZXkgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlcicgK1xuICAgICAgICAgICAgICAgICAgICAnIHRoZSBwcm9qZWN0L2xvY2F0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvcHRpb25zLnByb2plY3QgfHwgb3B0aW9ucy5sb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgdXNlciBwcm92aWRlZCBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2lsbCB0YWtlJyArXG4gICAgICAgICAgICAgICAgICAgICcgcHJlY2VkZW5jZSBvdmVyIHRoZSBBUEkga2V5IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhdGlvbiAmJiAhdGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gJ2dsb2JhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwob3B0aW9ucy5odHRwT3B0aW9ucywgb3B0aW9ucy52ZXJ0ZXhhaSwgZ2V0RW52KCdHT09HTEVfVkVSVEVYX0JBU0VfVVJMJyksIGdldEVudignR09PR0xFX0dFTUlOSV9CQVNFX1VSTCcpKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBvcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIGNvbnN0IGF1dGggPSBuZXcgTm9kZUF1dGgoe1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGdvb2dsZUF1dGhPcHRpb25zOiBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KHtcbiAgICAgICAgICAgIGF1dGg6IGF1dGgsXG4gICAgICAgICAgICBwcm9qZWN0OiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgIGFwaVZlcnNpb246IHRoaXMuYXBpVmVyc2lvbixcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB2ZXJ0ZXhhaTogdGhpcy52ZXJ0ZXhhaSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiBvcHRpb25zLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgdXNlckFnZW50RXh0cmE6IExBTkdVQUdFX0xBQkVMX1BSRUZJWCArIHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgICAgIHVwbG9hZGVyOiBuZXcgTm9kZVVwbG9hZGVyKCksXG4gICAgICAgICAgICBkb3dubG9hZGVyOiBuZXcgTm9kZURvd25sb2FkZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1vZGVscyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMubGl2ZSA9IG5ldyBMaXZlKHRoaXMuYXBpQ2xpZW50LCBhdXRoLCBuZXcgTm9kZVdlYlNvY2tldEZhY3RvcnkoKSk7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG5ldyBCYXRjaGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5jaGF0cyA9IG5ldyBDaGF0cyh0aGlzLm1vZGVscywgdGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IG5ldyBDYWNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEZpbGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gbmV3IE9wZXJhdGlvbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbnMgPSBuZXcgVG9rZW5zKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy50dW5pbmdzID0gbmV3IFR1bmluZ3ModGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudihlbnYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Vudl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW5FbnYoZW52KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQm9vbGVhbihnZXRFbnYoZW52KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0Jvb2xlYW4oc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlGcm9tRW52KCkge1xuICAgIGNvbnN0IGVudkdvb2dsZUFwaUtleSA9IGdldEVudignR09PR0xFX0FQSV9LRVknKTtcbiAgICBjb25zdCBlbnZHZW1pbmlBcGlLZXkgPSBnZXRFbnYoJ0dFTUlOSV9BUElfS0VZJyk7XG4gICAgaWYgKGVudkdvb2dsZUFwaUtleSAmJiBlbnZHZW1pbmlBcGlLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCb3RoIEdPT0dMRV9BUElfS0VZIGFuZCBHRU1JTklfQVBJX0tFWSBhcmUgc2V0LiBVc2luZyBHT09HTEVfQVBJX0tFWS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudkdvb2dsZUFwaUtleSB8fCBlbnZHZW1pbmlBcGlLZXkgfHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgeyBBY3Rpdml0eUhhbmRsaW5nLCBBZGFwdGVyU2l6ZSwgQXBpRXJyb3IsIEFwaVNwZWMsIEF1dGhUeXBlLCBCYXRjaGVzLCBCZWhhdmlvciwgQmxvY2tlZFJlYXNvbiwgQ2FjaGVzLCBDaGF0LCBDaGF0cywgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlLCBDb250ZW50UmVmZXJlbmNlSW1hZ2UsIENvbnRyb2xSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZVR5cGUsIENvdW50VG9rZW5zUmVzcG9uc2UsIENyZWF0ZUZpbGVSZXNwb25zZSwgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlLCBEZWxldGVGaWxlUmVzcG9uc2UsIERlbGV0ZU1vZGVsUmVzcG9uc2UsIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlLCBFZGl0SW1hZ2VSZXNwb25zZSwgRWRpdE1vZGUsIEVtYmVkQ29udGVudFJlc3BvbnNlLCBFbmRTZW5zaXRpdml0eSwgRW52aXJvbm1lbnQsIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlLCBGaWxlU291cmNlLCBGaWxlU3RhdGUsIEZpbGVzLCBGaW5pc2hSZWFzb24sIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUsIEZ1bmN0aW9uUmVzcG9uc2UsIEZ1bmN0aW9uUmVzcG9uc2VCbG9iLCBGdW5jdGlvblJlc3BvbnNlRmlsZURhdGEsIEZ1bmN0aW9uUmVzcG9uc2VQYXJ0LCBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZywgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UsIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2ssIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSwgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSwgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24sIEdlbmVyYXRlVmlkZW9zUmVzcG9uc2UsIEdvb2dsZUdlbkFJLCBIYXJtQmxvY2tNZXRob2QsIEhhcm1CbG9ja1RocmVzaG9sZCwgSGFybUNhdGVnb3J5LCBIYXJtUHJvYmFiaWxpdHksIEhhcm1TZXZlcml0eSwgSHR0cFJlc3BvbnNlLCBJbWFnZVByb21wdExhbmd1YWdlLCBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2UsIElubGluZWRSZXNwb25zZSwgSm9iU3RhdGUsIExhbmd1YWdlLCBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UsIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlLCBMaXN0RmlsZXNSZXNwb25zZSwgTGlzdE1vZGVsc1Jlc3BvbnNlLCBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlLCBMaXZlLCBMaXZlQ2xpZW50VG9vbFJlc3BvbnNlLCBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wsIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIExpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycywgTGl2ZVNlcnZlck1lc3NhZ2UsIE1hc2tSZWZlcmVuY2VJbWFnZSwgTWFza1JlZmVyZW5jZU1vZGUsIE1lZGlhTW9kYWxpdHksIE1lZGlhUmVzb2x1dGlvbiwgTW9kYWxpdHksIE1vZGUsIE1vZGVscywgTXVzaWNHZW5lcmF0aW9uTW9kZSwgT3BlcmF0aW9ucywgT3V0Y29tZSwgUGFnZWRJdGVtLCBQYWdlciwgUGVyc29uR2VuZXJhdGlvbiwgUmF3UmVmZXJlbmNlSW1hZ2UsIFJlY29udGV4dEltYWdlUmVzcG9uc2UsIFJlcGxheVJlc3BvbnNlLCBTYWZldHlGaWx0ZXJMZXZlbCwgU2NhbGUsIFNlZ21lbnRJbWFnZVJlc3BvbnNlLCBTZWdtZW50TW9kZSwgU2Vzc2lvbiwgU2luZ2xlRW1iZWRDb250ZW50UmVzcG9uc2UsIFN0YXJ0U2Vuc2l0aXZpdHksIFN0eWxlUmVmZXJlbmNlSW1hZ2UsIFN1YmplY3RSZWZlcmVuY2VJbWFnZSwgU3ViamVjdFJlZmVyZW5jZVR5cGUsIFRva2VucywgVHJhZmZpY1R5cGUsIFR1bmluZ01ldGhvZCwgVHVuaW5nTW9kZSwgVHVuaW5nVGFzaywgVHVybkNvbXBsZXRlUmVhc29uLCBUdXJuQ292ZXJhZ2UsIFR5cGUsIFVwc2NhbGVJbWFnZVJlc3BvbnNlLCBVcmxSZXRyaWV2YWxTdGF0dXMsIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5LCBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSwgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSwgY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tQmFzZTY0LCBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21VcmksIGNyZWF0ZU1vZGVsQ29udGVudCwgY3JlYXRlUGFydEZyb21CYXNlNjQsIGNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCwgY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSwgY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwsIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZSwgY3JlYXRlUGFydEZyb21UZXh0LCBjcmVhdGVQYXJ0RnJvbVVyaSwgY3JlYXRlVXNlckNvbnRlbnQsIG1jcFRvVG9vbCwgc2V0RGVmYXVsdEJhc2VVcmxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;